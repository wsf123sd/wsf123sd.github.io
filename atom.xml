<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wsf123sd.github.io/</id>
    <title>Gridea</title>
    <updated>2020-05-05T15:15:44.383Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wsf123sd.github.io/"/>
    <link rel="self" href="https://wsf123sd.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wsf123sd.github.io/images/avatar.png</logo>
    <icon>https://wsf123sd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[pat 乙级--c++知识总结]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji-czhi-shi-zong-jie/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji-czhi-shi-zong-jie/">
        </link>
        <updated>2020-05-05T15:09:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1判断a是否为数字字符和a是否为字母">## 1.判断A是否为数字字符和A是否为字母</h1>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a,b,c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    cout &lt;&lt; isalpha(a[0]) &lt;&lt; endl;  //小写字母返回2
    cout &lt;&lt; isalpha(b[0]) &lt;&lt; endl;  //大写字母返回1
    cout &lt;&lt; isalpha(c[0]) &lt;&lt; endl;  //非字母返回0
    return 0;
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200505230919328.png" alt="image-20200505230919328" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat 乙级 1011~1015]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji-1011~1015/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji-1011~1015/">
        </link>
        <updated>2020-05-05T14:35:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1011">1011</h2>
<h3 id="解题思路">解题思路：</h3>
<h3 id="参考代码">参考代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n;
 scanf(&quot;%d&quot;, &amp;n);
 for (int i = 0; i &lt; n; i++) {
 long long int a, b, c;
 scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c);
 printf(&quot;Case #%d: %s\n&quot;, i + 1, a + b &gt; c ? &quot;true&quot; : &quot;false&quot;);
 }
 return 0; }

</code></pre>
<h2 id="1012">1012</h2>
<h3 id="解题思路-2">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">    1.将输入的数字存放到对5求余对应下标的二维数组中</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.计算A1--A5<br>
1.A2：就是下标为偶数的加 - 下标为奇数的和</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">3.输出，用printf简单</font></p>
<h3 id="参考代码-2">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,digit,A1=0,A2=0,A3=0,A5=-1;   //对应的变量注意设置出来
    double A4=0.0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a[5];

    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; digit;
        a[digit%5].push_back(digit);      //这里使用push_back就是将数字压入，自动生成一个二维数组
                                        //注意写法：数组[下标].push_back(要填入的数字);
    }

    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;a[i].size(); j++)
        {
            if(i==0 &amp;&amp; a[i][j]%2==0)
                A1+=a[i][j];
            if(i==1 &amp;&amp; j%2==0)
                A2+=a[i][j];
            if(i==1 &amp;&amp; j%2!=0)
                A2-=a[i][j];
            if(i==2)
                A3++;
            if(i==3)
                A4+=a[i][j];
            if(i==4 &amp;&amp; a[i][j]&gt;A5)     //一定要是大于A5
                A5=a[i][j];
        }
    for(int i=0; i&lt;5; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        if(i==0 &amp;&amp; A1==0 || i!=0 &amp;&amp; a[i].size()==0)
        {
            cout &lt;&lt; &quot;N&quot;;
            continue;
        }
        if(i==0)
            printf(&quot;%d&quot;,A1);
        if(i==1)
            printf(&quot;%d&quot;, A2);  //计算出结果为何不直接输出值？因为每一次输出都有条件限制，对于不存在的数输出N，
                            //为了保证思路的理解，就设置成循环，如果不满足条件就输出N，否则按照对应的值输出
        if(i==2)
            printf(&quot;%d&quot;,A3);
        if(i==3)
            printf(&quot;%.1f&quot;,A4/a[i].size());
        if(i==4)
            printf(&quot;%d&quot;,A5);
    }
    return 0;
}
</code></pre>
<h2 id="1013">1013</h2>
<h3 id="解题思路-3">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体"> 将从第M个素数到第N个素数放到数组中</font></p>
<h3 id="参考代码-3">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

bool isprime(int a)
{
    for(int i=2; i*i&lt;=a; i++)
        if(a%i == 0)
            return false;
    return true;
}

int main()
{
    int M,N,num=2,cnt=0;
    cin &gt;&gt; M &gt;&gt; N;
    vector&lt;int&gt; v;
    /*
        1.从素数列中找到第m个到第n个放到数组中
        2.用while循环，含义是循环至少执行N次，也就是M=5，N=27，循环至少执行27次，表示
          从第一素数到第27个素数，而且cnt必须从0开始，因为num初值为2，进入到isprime函数中，
          cnt++表示1与2为第一个素数相对应
        3.num++与循环的判断条件无关，循环的判断条件是第几个素数，其中cnt为N-1就表示第N个素数
          因为cnt从0开始
    */
    while(cnt &lt; N)       //cnt的值从0开始，自然要小于N
    {
        if(isprime(num))
        {
            cnt++;
            if(cnt &gt;= M)
                v.push_back(num);
        }
        num++;
    }
    cnt=0;
    /*
        对于每次先输出数字再输出空格，且最后一个不为空格，且每行10个的思想:
        1.将输出空格代码放前面，用if的一个条件判断（避开第一次输出空格），
          然后紧接着输出数字，依次循环
        2.对于每次换行，都希望能与1中的if语句相关联。这样保证每次换行时不会先输出一个空格，
          再输出数值，对于每次输出10个，那么每行的第一个就是1,11，21,31.....求余为1
          这样在if中可以设置%10!=1输出空格，当然在最后要有如果求余10就输出换行
    */
    for(int i=0; i&lt;v.size(); i++)
    {
        cnt++;
        if(cnt%10 != 1)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
        if(cnt%10 == 0)
            cout &lt;&lt; endl;
    }
}


/**********我的代码但是超时**********/
/*
    解题思路：
    1.素数公式判断
    2.从第m个素数到第n个素数
    主要是找到第一个
        1.用while，条件是k==n;k=0
*/
#include&lt;iostream&gt;
using namespace std;
bool f(int n)
{

    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
           return false;
    return true;
}

int s(int n)  //找到第n个素数
{
    int k=1,i=3;
    if(n==1)
    {
        return 2;
    }
    while(k!=n)
    {
        if(f(i))
            k++;
        i+=2;
    }
    return i-=2;
}

int main()
{

    int m,n,now=0,flag=0;
    cin &gt;&gt; m &gt;&gt; n;
    for(int i=s(m); i&lt;=s(n); i++)
    {
        if(f(i))
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; i;
            flag=1;
            now++;
    /*
        之前是换行后，先输出空格然后再输出值，我改为每次换行后，将flag的值修改，这样进入
        下次循环时，就不会输出空格，并且按照最后一个不为空格的方式输出
    */
            if(now%10==0)
            {
                cout &lt;&lt; endl;
                flag=0;
            }
        }

    }


    return 0;
}
</code></pre>
<h2 id="1014">1014</h2>
<h3 id="解题思路-4">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">    1.用两次while分别找出a,b字符串中第一个和第二个相同字符</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.同样也用while遍历循环c，d两个字符串</font></p>
<h3 id="参考代码-4">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用两次while分别找出a,b字符串中第一个和第二个相同字符
    2.同样也用while遍历循环c，d两个字符串
*/
int main()
{
    string a,b,c,d;
    char t[2];
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    int i=0,j=0,e=0;
    //找到第一个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i] &amp;&amp; ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='G'))
        {
            t[0]=a[i];
            break;
        }
        i++;
    }
    i++;

    //找到第二个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i])
        {
            if(isdigit(a[i]) || ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='N'))  //isdigit(a[i])判断a[i]是否为数字字符
            {
                t[1]=a[i];
                break;
            }
        }
        i++;
    }

    //找到第三个字符
    while(j&lt;c.length() &amp;&amp; j&lt;d.length())
    {
        if(c[j]==d[j] &amp;&amp; isalpha(c[j]))          //isalpha(c[j])判断c[j]是否为字母
        {
            e=j;
            break;
        }
        j++;
    }


    char sa[7][5]={&quot;MON &quot;,&quot;TUE &quot;,&quot;WED &quot;,&quot;THU &quot;,&quot;FRI &quot;,&quot;SAT &quot;,&quot;SUN &quot;};
    cout &lt;&lt; sa[t[0]-'A'];
    int m=isdigit(t[1])? t[1]-'0': t[1]- 'A' + 10;    //切记这里用一个整形变量m来接受条件判断的结果，最后在输出
    printf(&quot;%02d:%02d&quot;,m,j);       //采用c的方式输出，是为了当数字为1位时，前面有0补充；否则直接输出2位数

    return 0;
}

</code></pre>
<h3 id="知识总结">知识总结：</h3>
<pre><code class="language-c++">isdigit(A)   //判断A是否为数字字符
isalpha(A)   //判断A是否为字母
</code></pre>
<h2 id="1015">1015</h2>
<h3 id="解题思路-5">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体"> 1.用一个结构stu来存放数据信息</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.设置一个排序函数，总分不同按照从大到小排列，总分相同，按照按照德分从大到小排列；德分相同，按照<br>
学号从小到大输出</font></p>
<p><font color=\#7FFF00 size=3 face="黑体"> 3.设置1个结构数组，一个临时变量结构用来存放每次的输入；循环中嵌套if判断，将对应的结构压入栈中，也就形成了二维数组</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.最后压栈进行排序后并输出</font></p>
<h3 id="参考代码-5">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
/*
    解题思路：

*/
struct node
{
    int num,de,cai;
};

int cmp(struct node a, struct node b)
{
    if((a.de+a.cai)!=(b.de+b.cai))
        return (a.de+a.cai) &gt; (b.de+b.cai);   //如果总分数不同，就按照最大到小的顺序排列
    else if(a.de!=b.de)                    //如果总分数相同，但德分不同，按照德分从大到小排列
        return a.de&gt;b.de;         //从大到小
    else
        return a.num&lt;b.num;            //从小到大
}


int main()
{
    int low,high,n;
    cin &gt;&gt; n &gt;&gt; low &gt;&gt; high;
    node temp;
    vector&lt;node&gt; v[4];
    int total=n;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d&quot;, &amp;temp.num,&amp;temp.de, &amp;temp.cai);
        if(temp.de &lt; low || temp.cai &lt; low)
            total--;
        else if(temp.de &gt;= high &amp;&amp; temp.cai &gt;= high)
            v[0].push_back(temp);
        else if(temp.de &gt;= high &amp;&amp; temp.cai &lt; high)
            v[1].push_back(temp);
        else if(temp.de &lt; high &amp;&amp; temp.cai &lt; high &amp;&amp; temp.de &gt;= temp.cai)
            v[2].push_back(temp);
        else
            v[3].push_back(temp);

    }
    cout &lt;&lt; total &lt;&lt; endl;
    for(int i=0; i&lt;4; i++)
    {
        sort(v[i].begin(),v[i].end(),cmp);
        for(int j=0; j&lt;v[i].size(); j++)
            cout &lt;&lt; v[i][j].num &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].de &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].cai &lt;&lt;endl;
    }
    return 0;

}

</code></pre>
<pre><code class="language-c++">
</code></pre>
<h3 id="注意事项">注意事项：</h3>
<blockquote>
<p>在输入时，用scanf格式控制字符来输入，不会超时</p>
</blockquote>
<h3 id="知识总结-2">知识总结：</h3>
<h4 id="1自定义排序">1.自定义排序</h4>
<pre><code class="language-c++">struct stu
{
	int mark,num;
};
bool cmp(stu a, stu b)
{
	if(a.mark != b.mark)
		return a.mark &gt; b.mark  //降序排列
	else
		return a.num&lt;b.num      //mark相同按照num的升序排列
}
vector&lt;stu&gt; v[4];   //结构数组
sort(v[i].begin(),v[i].end(),cmp);  //对数组进行相应的排序
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat 乙级 1006~1010]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji-1006~1010/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji-1006~1010/">
        </link>
        <updated>2020-05-05T14:22:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1006">1006</h2>
<h3 id="解题思路">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n</font></p>
<h3 id="参考代码">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
/*
    思路就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i=1; i&lt;=n/100; i++)
        cout &lt;&lt; 'B';
    for(int j=1; j&lt;=n%100/10; j++)
            cout &lt;&lt; 'S';
    for(int k=1; k&lt;=n%10; k++)
            cout &lt;&lt; k;
    return 0;
}

</code></pre>
<h2 id="1007">1007</h2>
<h3 id="解题思路-2">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">ans表示有多少对数字<br>
遍历从0--n相邻且相差2的数字，然后判断是否为素数</font></p>
<h3 id="参考代码-2">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
/*
  解题思路：ans表示有多少对数字
        遍历从0--n相邻且相差2的数字，然后判断是否为素数
*/
int f(int n)
{
    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
            return 0;
    return 1;
}
int main()
{
    int n,ans=0;
    cin &gt;&gt; n;
    for(int i=2; i&lt;=n-2; i++)
    {
        if(f(i) &amp;&amp; f(i+2))
            ans++;
    }
    cout &lt;&lt; ans;
    return 0;
}

</code></pre>
<h2 id="1008">1008</h2>
<h3 id="解题思路-3">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">先把数组倒叙，再把前m为倒叙，再把后面的倒叙即可。（客观规律，记住即可）<br>
之前的思路是向后移数组，在把超出部分放到前面，但这样部分正确。我分析是：使用太多的数组，因为题目要求程序移动的次数竟可能少</font></p>
<h3 id="参考代码-3">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;algorithm&gt;  //reverse()使用此头件
#include&lt;vector&gt;  //vector使用此头文件
using namespace std;
int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;int &gt; a(n);
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    m%=n;
    if(m!=0)
    {
        reverse(a.begin(),a.end());  //a.begin()是指针，指向数组第一个元素；a.end()也是指针，指向a[6]
        reverse(a.begin(),begin(a)+m);  //reverse中不会将第2部分的值也倒转，而是把他之前的值倒转
        reverse(begin(a)+m,a.end());  //从上一位置开始
    }
    for(int i=0; i&lt;n-1; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; a[n-1];
    return 0;
}

</code></pre>
<h2 id="1009">1009</h2>
<h3 id="解题思路-4">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">利用栈先进后出的思想来倒叙输出字符串<br>
首先，将字符串压入栈，访问栈顶元素，弹出当前栈顶元素。<br>
由于题目要求，字符串之间有空格并且最后一个字符串没有空格，下面就循环先输出空格再输出字符串然后弹出</font></p>
<h3 id="参考代码-4">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

int main()
{
    stack&lt;string&gt; v;
    string s;
    while(cin &gt;&gt; s)
        v.push(s);
    cout &lt;&lt; v.top();
    v.pop();
    while(!v.empty())
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; v.top();
        v.pop();
    }
    return 0;
}
</code></pre>
<h2 id="1010">1010</h2>
<h3 id="解题思路-5">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体"> 1.每次输入两个变量，不用存放到数组中，规律是每次输出第一个变量*第二个变量；第二个变量-1</font></p>
<p><font color=\#7FFF00 size=3 face="黑体"> 2.对于上面规律使用前提是第二个变量不为0，若为0，不执行语句，进入下一次循环，看，在这里并不是</font></p>
<p><font color=\#7FFF00 size=3 face="黑体"> 3. 使用continue，而是循环中嵌套一个if，这样当条件不满足时，自动不执行if中的语句，直接进入下一次循环</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.对于先输出数值，后输出空格，但在最后不能有空格的套路是用flag标记（你懂的）</font></p>
<p><font color=\#7FFF00 size=3 face="黑体"> 5.对于零项多项式和全部都是常数项而言，当整个循环结束后还是用flag==0判断，并输出0 0</font></p>
<h3 id="参考代码-5">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int flag=0;
    int a,b;
    while(cin &gt;&gt; a &gt;&gt; b)
    {
        if(b!=0)
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a*b &lt;&lt; &quot; &quot; &lt;&lt; b-1;
            flag=1;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;0 0&quot;;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat 乙级 1001~1005]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji-1001~1005/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji-1001~1005/">
        </link>
        <updated>2020-05-05T14:10:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1001">1001</h2>
<h3 id="解题思路">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">用while+if-else来控制循环次数（砍得的次数）和判断奇数偶数</font></p>
<h3 id="参考代码">参考代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt; 
using namespace std;

int main()
{
	int n,step=0;
	cin &gt;&gt; n;
	while(n!=1)
	{ 
		if(n%2==0)
			n/=2;
		else
			n=(3*n+1)/2;
		step++;
	} 
	cout &lt;&lt; step;
	return 0;
}
</code></pre>
<h3 id="别人代码">别人代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, count = 0;
 cin &gt;&gt; n;
 while (n != 1)
  {
	 if (n % 2 != 0)      //这个循环就是判断奇数的，n为奇数*3+1完了，在下一句除2 这样就省掉了加括号的麻烦 抓住了不管奇数还是偶数                         
//都有除2的特点 如果n为偶数不执行此语句，直接再下面除2
		 n = 3 * n + 1;   
	 n = n / 2;
	 count++;
 }
 cout &lt;&lt; count;
 return 0; }
</code></pre>
<h2 id="1002">1002</h2>
<h3 id="解题思路-2">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.用string类来存储数据，不然的话double，long long类型的长度不够</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.用for循环来计算各位数字之和</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">3.用string类定义一个数组，其中成员是数字的拼音</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.将数字和变量改为字符串类型，方便调用每个位数字，不用对数字除或求余</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">5.通过循环从数字和的字符串中对应找到string类的数字拼音</font></p>
<h3 id="参考代码-2">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int main()
{
	string s;
	cin &gt;&gt; s;
	int i,sum=0;
	for(i=0; i&lt;s.length(); i++)     //s.length()计算字符串长度 
	{
		sum+=s[i]-'0';
	}
	string name[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};  //字符串用双引号括起来，字符用单引号括起来 
	
	string a = to_string(sum);
	
	for(i=0; i&lt;a.length(); i++)
	{
		cout &lt;&lt; name[a[i]-'0'];   //将数字转变为字符去存储方便调用每个位置上的数字，不用再除或求余啥的 
		if (i != a.length()-1)
			cout &lt;&lt; ' ';
	}
	

	return 0;
}
</code></pre>
<h3 id="别人代码-2">别人代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() 
{
	 string s;
	 cin &gt;&gt; s;
	 int sum = 0;
	 string str[10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;};   //
	 for (int i = 0; i &lt; s.length(); i++)
	 	sum += (s[i] - '0');
	 	
	 string num = to_string(sum);
	 
	 for (int i = 0; i &lt; num.length(); i++)
	 {
		 if (i != 0)        //题目要求最后一个拼音不能有空格，所以是先输出拼音，后输出空格，提前加一个if判断，当输入完最后一个拼音，循环都已经结束了
		 	cout &lt;&lt; &quot; &quot;;
		 cout &lt;&lt; str[num[i] - '0'];
	 }
	 
	 return 0; 
 }
</code></pre>
<h2 id="1003">1003</h2>
<h3 id="解题思路-3">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.本题难点在于找规律，首先明确一点不是AAA...AAPAA...AATAA...AA这么简单的规律。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.突破点在于aPbTc正确和aPbATca正确，显然第二个在P与A之间多加了一个A，后面多了一个a，而a又是第一个的P之前的部分，其实这里a,b,c均是狗（宇哥替换）。观察例子：AAPATAA与AAPAATAAAA，这里a相当于AA，b相当于A，c相当于AA。在第二个中P,T之间多加了A，则后面多加AA。所以规律是在P,T之间多加一个A，则原来字符串T后面多 补充 原来字符串P之前的部分。比如对于AAPAATAAAA而言，AAPAAATAAAAAA也是对的，AAPAAATAAAAAAAA也是对的。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">3.如果P之前没有A，则无论在P,T之间加多少的A，T之后也不会有A,所以形如PAAA...AAAT都对</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.xPATx这种形式告诉我们，AAA...AAAPATAAA...AAA是可以的，只要PAT前和后的AAA对称。二一个当x为空格是PAT也是正确。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">5.通过例子可知有且仅有P,A,T三种字符，其中P,T的个数只能为1，而A的个数不能0，P,T之间至少一个A，对于APAAATAA我们可知可以由APAATA得来，但是例子表示APAAATAA是错误，所以APAATA也是错误</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">6.总之，就是P之前A的个数*P与T之间A的个数等于T之后A的个数 （这规律我估计也不是他想出来的，或者就是偶然想到的</font></p>
<h3 id="参考代码-3">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

int main()
{
	int n,i,j,p,t;
	cin &gt;&gt; n;
	string s;
	for(i=0; i&lt;n; i++)
	{
		cin &gt;&gt; s;
		map&lt;char, int &gt; m;
		for(j=0; j&lt;s.length(); j++)
		{
			m[s[j]]++;
			if(s[j]=='P')
				p=j;
			if(s[j]=='T')
				t=j;
		}
		if(m['P']==1 &amp;&amp; m['A']!=0 &amp;&amp; m['T']==1 &amp;&amp; m.size()==3 &amp;&amp; t-p!=1 &amp;&amp; p*(t-p-1)==s.length()-t-1)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h2 id="1004">1004</h2>
<h3 id="解题思路-4">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.首先根本不用存储每次输入的学生的信息，重点是要知道成绩最值的学生的姓名和学号，所以用变量来存储这些信息。“铁打的营盘流水的兵”恰如其分描述铁打的营盘类似成绩最值的姓名和学号，而流水类似不断敲入的学生成绩，姓名和学号</font></p>
<h3 id="参考代码-4">参考代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, max = -1, min = 101, score;
 cin &gt;&gt; n;
 string maxname, minname, maxnum, minnum, name, num;
 for (int i = 0; i &lt; n; i++) {
 cin &gt;&gt; name &gt;&gt; num &gt;&gt; score;
 if (max &lt; score) {
 max = score;
 maxname = name;
 maxnum = num;
 }
 if (min &gt; score) {
 min = score;
 minname = name;
 minnum = num;
 }
 }
 cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnum &lt;&lt; endl &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnum;
    return 0; }
</code></pre>
<h2 id="1005">1005</h2>
<h3 id="解题思路-5">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.设置一个数组arr[]其中表示对输入数字进行c式处理后对应下标为1<br>
比如：输入5 ，第一次c式处理后为8，则将arr[8]的值为1<br>
先判断arr值是否为1，是则退出循环，输入下一个值判断，不是另其值为1</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.注意arr数组的空间大小为10000否则只是部分正确</font></p>
<h3 id="参考代码-5">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int arr[10000];
bool cmp(int a, int b)
{
    return a&gt;b;
}

int main()
{
    int k,n,flag=0;
    cin &gt;&gt; k;
    vector&lt;int&gt; v(k);//定义一个数组
    //for中嵌套while，外面一共循环k次，里面就是对数字处理并且标记对应arr数组中的值为1
    //如果在while中判断数字有1则直接输入下一个数
    for(int i=0; i&lt;k; i++)
    {
        cin &gt;&gt; n;
        v[i]=n;   //数组存放对应的数字
        while(n!=1)
        {
            if(n%2!=0)
                n=3*n+1;
            n/=2;
            /*?*/
            if(arr[n]==1)
                break;
            arr[n]=1;
        }
    }
    sort(v.begin(), v.end(), cmp); //将数组按照从大到小的顺序排列
    for(int i=0; i&lt; v.size(); i++)
    {
        if(arr[v[i]]==0) //表示
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; v[i];
            flag=1;

        }
    }
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://wsf123sd.github.io/post/ce-shi/</id>
        <link href="https://wsf123sd.github.io/post/ce-shi/">
        </link>
        <updated>2020-03-16T17:04:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一章-朝花夕拾">第一章 朝花夕拾</h2>
<h3 id="1小于">1.小于</h3>
<h3 id="1小于打开四六级">1.小于打开四六级</h3>
<h3 id="1小于九分裤">1.小于九分裤</h3>
<h3 id="1小于了">1.小于，；了</h3>
<h3 id="1小于没考虑">1.小于没考虑</h3>
<h2 id="第二章-呐喊">第二章 呐喊</h2>
<h3 id="1jkcj">1.jkcj</h3>
<h3 id="1jkcasf-dlk">1.jkcasf dlk</h3>
<h3 id="1jkcjj-klm">1.jkcjj klm</h3>
<h3 id="1jkcjjklrjklw">1.jkcjjklrjklw</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

/*
    构造结点：
    1.两个int类型
    2.还有一个next指针
*/
struct LinkList
{
    int z;
    int fu;
    LinkList *next;
};

/*
    构造链表：
    1.定义一个LinkList的头指针
    2.定义两个临时变量存放每次的输入
    3.while循环：
        1.输入两个值
        2.动态分配一个结点空间
        3.如果结点空间分配失败，
*/
LinkList *BuildList(int n)
{
    LinkList *head=NULL;
    int zheng,fushu;
    while(n--)
    {
       cin &gt;&gt; zheng &gt;&gt; fushu;
       LinkList *new_node=(LinkList *)malloc(sizeof(LinkList));
        if(new_node==NULL)
        {
            cout &lt;&lt; &quot;filed!&quot;;
            return head;
        }
        new_node-&gt;z=zheng;
        new_node-&gt;fu=fushu;
        LinkList *p;
    if(head==NULL)
    {
        new_node-&gt;next=NULL;
        head=new_node;
        p=head;
    }
    else
    {

        p-&gt;next=new_node;
        new_node-&gt;next=NULL;
        p=new_node;
    }
  }
    return head;
}

//对构造的链表进行相加
void CountList(LinkList *head)
{
    LinkList *p=head;
    int zheng=0,fu=0;
    while(p)
    {
        zheng+=p-&gt;z;
        fu+=p-&gt;fu;
        p=p-&gt;next;
    }
    cout&lt;&lt;zheng&lt;&lt;&quot;+&quot;&lt;&lt;fu&lt;&lt;&quot;i&quot;&lt;&lt;endl;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    LinkList *head=BuildList(n);
    CountList(head);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第三章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/">
        </link>
        <updated>2020-03-16T13:03:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.函数定义：返回abc中最大值</a></p>
<p><a href="#jump2">2.函数重载</a></p>
<p><a href="#jump3">3.带默认参数函数和一个函数不能即是带默认参数函数又是函数重载</a></p>
<p><a href="#jump4">4.变量的使用</a></p>
<p><a href="#jump5">5.register和static</a></p>
<p><a href="#jump6">6.关键字extern：扩大作用域的范围</a></p>
<p><span id="jump1">1.函数定义：返回abc中最大值</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

\#include&lt;iomanip&gt;

using namespace std;

int fun(int a, int b, int c);

/*

   函数定义：返回值类型 函数名 形参表

   函数定义顺序：函数声明-&gt;主函数-&gt;函数定义

   函数的思想：低耦合，高为聚（函数之间耦合度要低，高维聚表示函数的功能尽可能集中）

*/

int main()

{

​    int a,b,c;

​    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

​    cout &lt;&lt; fun(a,b,c);

​    return 0;

}

int fun(int a, int b, int c)

{

   return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;

}



</code></pre>
<p><span id="jump2">2.函数重载</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

using namespace std;

//函数重载:一物多用



/*

​    1.保证函数名形同，形参的个数或类型不同,函数的类型也可以不同

​    2.对于调用时，若两个数就使用第2个判断，若3个数就使用第一个判断

*/



int fun(int a,int b,int c);

int fun(int a, int b);

double fun(double a, double b, double c);

int main()

{

​    cout &lt;&lt; fun(5.0,1.0,11.11) &lt;&lt; endl;

​    return 0;

}



int fun(int a,int b)

{

​    return a&gt;b?a:b;

}



int fun(int a, int b, int c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;

​    return a;

}



double fun(double a,double b, double c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;double&quot; &lt;&lt; endl;

​    return a;

}



</code></pre>
<p><span id="jump3">3.带默认参数函数和一个函数不能即是带默认参数函数又是函数重载</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

using namespace std;

/*

​    带默认参数的函数使用

​    1.在函数声明的过程中，就放上参数，而在函数定义和函数调用过程的过程中不要放参数

​    这样最后的结果就是参数的函数值

​    2.如果函数调用中，传部分值也可以

​    3.给函数申明赋初值时，优先从右至左

​    4.函数调用时将实参赋值给形参的顺序是从左至右

​    5.有实参用实参没实参用形参

​    6.特别注意一个函数不能即做函数重载又做带默认值函数

*/

int fun(int a=1, int b=1, int c=2);

int fun(int a,int b);  //6.函数调用时是用上面还是用下面？

int main()

{

​    cout &lt;&lt; fun(5,2) &lt;&lt; endl;

​    return 0;

}



int fun(int a, int b, int c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;

​    return a;

}





</code></pre>
<p><span id="jump4">4.变量的使用</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

\#include&lt;iomanip&gt;

using namespace std;

int a=15;     //全局变量,函数外部，作用范围： 全局变量的生命周期是整个程序

/*



*/

int fun()

{

​    int a;

​    a=20;

}

int main()

{

​    auto int b;   //auto动态存储类别，不写也可以就是平时用的

​    static int a;  //静态类型，只初始化一次

​    int a;      //局部变量，就在它自身的函数内可用,如果全局变量和局部变量重名时，以函数内的局部变量为准

​    a=10;          //当函数运行完，局部变量生命周期就结束

​    cout &lt;&lt; a &lt;&lt; endl;

​    return 0;

}



</code></pre>
<p><span id="jump5">5.register和static</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;



int fun()

{

   static int a=10;  //只初始化一次，第2次调用此函数值为12不是11

   register int a=10;   //把变量设置为register可以高效的读取该变量,建议性的动作，每次调用函数后都会重新设置a=10，即两次调用的结果都为11

   extern 

   for(a=10; a&lt;1000; a++)

   {

​       

   }

​    a++;

​    cout &lt;&lt; a &lt;&lt; endl;

​    return 0;

}





int main()

{

​    fun();

​    fun();

​    return 0;

}



</code></pre>
<p><span id="jump6">6.关键字extern：扩大作用域的范围</span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://wsf123sd.github.io/post/markdown-yu-fa/</id>
        <link href="https://wsf123sd.github.io/post/markdown-yu-fa/">
        </link>
        <updated>2020-03-01T15:28:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一级标题ctrl1">一级标题（Ctrl+1）</h1>
<p>快速生成目录（[toc]+回车）</p>
<p>[toc]</p>
<h2 id="二级标题ctrl2">二级标题（Ctrl+2）</h2>
<h3 id="三级标题ctrl3">三级标题（Ctrl+3）</h3>
<p><u>这是下划线（Ctrl+u）</u></p>
<p><s>这是删除线(alt+shift+5)</s></p>
<p><strong>字体加粗（ctrl+b）</strong></p>
<p><em>字体倾斜（Ctrl+i）</em></p>
<ul>
<li>牛奶（先输入-再输入空格就是无序列表）</li>
<li>面包</li>
<li>蛋糕
<ul>
<li>包子（再输入-和空格都是无序列表的嵌套）</li>
<li>鸡蛋</li>
</ul>
</li>
</ul>
<ol>
<li>你好（数字+.+空格）</li>
<li>我好</li>
<li>他也好
<ol>
<li>电脑（再输入数字+.+空格就是有序列表嵌套）</li>
<li>鼠标</li>
</ol>
</li>
</ol>
<blockquote>
<p>引用（&gt;+空格）</p>
</blockquote>
<p><a href="https://wsf123sad.github.io/">这是链接</a></p>
<p>直接粘贴复制</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200228122119497.png" alt="image-20200228122119497" loading="lazy"></figure>
<pre><code class="language-c++">//ctrl+shift+k(代码块)
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a,int b;
}
</code></pre>
<p>home family 沙墟（ctrl+d选中英文单词或者中文）</p>
<p>asdkjklj(ctrl+l按行选中)</p>
<p>快速搜索（ctrl+f）</p>
<p>替换（ctrl+h）</p>
<p>快速生成表格（ctrl+t）</p>
<table>
<thead>
<tr>
<th style="text-align:center">asd</th>
<th style="text-align:center">ds</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdfasd</td>
<td style="text-align:center">sdaf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>快速打开文件（ctrl+p）</p>
<p><code>关键字</code>爱神的箭（ctrl+shift+tab键上面的反引号）</p>
<p>表情符号：（在微软的输入法下，ctrl+shift+b）</p>
<p>😍❤</p>
<p>ctrl+n创建新文件，ctrl+w关闭文件</p>
<p>ctrl+shift+l显示和隐藏侧边栏</p>
<p>f11全屏</p>
<p>三个---+回车是分割线</p>
<hr>
<p><mark>高亮</mark> (俩个=+文字+俩个=)</p>
<p>爱是考虑到（ctrl+0段落标签）</p>
<p>脚注：</p>
<p>Jobs<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>先输入Jobs+[]+中括号内写^1,然后回车后有自动提示</p>
<p>文件导出：文件-&gt;导出（选择格式）</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>苹果公司的创始人 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第一，二章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:27:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.开始介绍c++</a></p>
<p><a href="#jump2">2.各种云算符</a></p>
<p><a href="#jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</a></p>
<p><a href="#jump4">4.switch结构</a></p>
<p><a href="#jump5">5.打印水仙花的两种算法</a></p>
<p><span id="jump1">1.开始介绍c++</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       头文件   

using namespace std;        std名称空间



int main(int argc, char** argv)

{

  int a=5;

  char b='N';

  float c=3.14;

  double d=56.789;

  

  bool e;  //布尔值 

  

  e=true;

  cout &lt;&lt; e &lt;&lt; endl;

  e=false;

  cout &lt;&lt; e &lt;&lt; endl;

  

  /*

  cout &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt; '\n' &lt;&lt; endl;

  cout &lt;&lt; b &lt;&lt; endl;

  cout &lt;&lt; c &lt;&lt; endl;

  cout &lt;&lt; d &lt;&lt; endl; 

  */



  return 0;

} 

</code></pre>
<p><span id="jump2">2.各种运算符</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       

#include&lt;iomanip&gt;   

using namespace std;        



int main(int argc, char** argv)

{

  //赋值运算符 从右至左

  int a=10;

  a=98; 

  //算术运算符

  //+ - * / % (双目运算符)  ++ -- (单目运算符) 

  //关系运算符

  //&gt; &lt; &lt;= &gt;= == != (双目运算符) 

  //逻辑运算符

  //&amp;&amp;(左右都为真，则为真) //(有一个为真，就为真) !

  //位运算符 

  //&lt;&lt;(将数字变为2进制，左移右补0) &gt;&gt; &amp; / ^ (将数字转变为2进制计算) 

  //&amp;:两个结果都为1，则值为1  

  // /:有一个为1，则为1

  // ^:两个相同则为0，不同为1 

  //三目运算符

  //?:

  //  1&gt;2? 5:6 

  //逗号运算符  2+3,9  这个表示一个式子，结果是最后一个值 

  //求字节运算符:sizeof()

  

  

  //逗号运算符：整个逗号表达式的值为系列中最后一个表达式的值。 





  int i,j;

  

  j=10;

  i=(j++,j+100,999+j);   //j自增1，完了j加上100变为111， 最后j再加上999， 结果为1010 

  

  cout &lt;&lt; i;

 

  return 0;

} 

</code></pre>
<p><span id="jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include &lt;iomanip&gt;      //使用setprecision的头文件 

using namespace std;



int main(int argc, char** argv)

{

  double a=356.1415926535897932;    //默认为保存6位 

  double b=25.2222365; 

  //cout &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;   //  setprecision(保存的位数) 设置整体的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl; // 只设置小数点后的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right)&lt;&lt;setw(10)&lt;&lt;a&lt;&lt;endl;   //设置数字向右靠，一共设置10位 

  

  /* 在第14行设置好，下面a，b输出都按照要求输出，主要若将setw(10)写在第14行，只有a的是保留10位靠右输出 

​    cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right);

  cout &lt;&lt;setw(10) &lt;&lt; setfill('0') &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  */

  

  //使用字符&amp;来补充，setfill(要填充的内容) 

  cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right) &lt;&lt; setfill('&amp;') ;

  cout &lt;&lt;setw(10) &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  

  return 0;

}

</code></pre>
<p>‘A’65</p>
<p>‘Z’90</p>
<p>'0'48</p>
<p><span id="jump4">4.switch结构</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main(int argc, char** argv)

{

​    int a;

​    cin &gt;&gt; a;

​    switch(a)

​    {

​        case 1:

​        case 2:

​        case 3: cout &lt;&lt; &quot;spring&quot; &lt;&lt; endl;break;

​        case 4:

​        case 5:

​        case 6: cout &lt;&lt; &quot;summer&quot; &lt;&lt; endl;break;

​        case 7:

​        case 8:

​        case 9: cout &lt;&lt; &quot;autumn&quot; &lt;&lt; endl;break;

​        case 10:

​        case 11:

​        case 12: cout &lt;&lt; &quot;winter&quot; &lt;&lt; endl;break;

​        default:cout &lt;&lt; &quot;others&quot; &lt;&lt; endl;break;



​    }

​    return 0;

}

</code></pre>
<p><span id="jump5">5.打印水仙花数的两种算法</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main()

{

​    /*

​    int i=100;

​    int a,b,c;

​     while(i&lt;1000)

​     {

​         a=i/100;

​         b=i%100/10;

​         c=i%10;

​         if(a*a*a+b*b*b+c*c*c==i)

​            cout &lt;&lt; i &lt;&lt; endl;

​         i++;

​     }

​     return 0;

​     */

/*

​    下面的三次循环效率比上面高，因为while循环内部运算次数远远大于下面，上面每次都要计算出a,b,c的值，而下没有一步是要算出确切的值

*/     

​     

​     int a=1,b=1,c=1;

​     for(a=1; a&lt;10; a++)

​     {

​         for(b=0; b&lt;10; b++)

​         {

​             for(c=0; c&lt;10; c++)

​             {

​                 if(a*a*a+b*b*b+c*c*c == a*100+b*10+c)

​                        cout &lt;&lt; a*100+b*10+c &lt;&lt; endl;

​             }

​         }

​     }

​     return 0;

}





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第四章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:25:40.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.二维数组</a><br>
<a href="#jump2">2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</a><br>
<a href="#jump3">3.string类的字符串翻转</a><br>
<a href="#jump4">4.字符串的使用</a><br>
<a href="#jump5">5.指针的使用</a><br>
<a href="#jump6">6.输出字符数组的三种写法+二维数组的指针使用</a><br>
<a href="#jump7">7.二维数组指针作为函数参数的使用</a><br>
<a href="#jump8">8.引用+引用作为参数进行数字交换</a><br>
<a href="#jump9">9.new和delete分配和释放空间</a><br>
<a href="#jump10">10.结构的使用</a><br>
<a href="#jump11">11.共用体</a><br>
<a href="#jump12">12.枚举类型</a></p>
<p>9.new和delete分配和释放空间</p>
<p>8.引用+引用作为参数进行数字交换8.引用+引用作为参数进行数字交换</p>
<p><span id="jump1">1.二维数组</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;


int main()
{
    int b[3][4]={1,2,3,4,5};  //二维数组用双层for循环
    
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;4; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p><span id="jump2">2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;  //一定是cstring不是string
#include&lt;iomanip&gt;
using namespace std;

int main ()
{
    //strcmp
    //strlen
    //strcpy
    //strcat
    char a[100]=&quot;hello&quot;;
    char b[100]=&quot;helleajsdkl&quot;;
    /*
        字符串比较，如果相同返回0‘如果第一个大，返回1,；如果第2个大，返回负值。
        从左到右比较时第一个不同比较完就完
    */
    cout &lt;&lt; strcmp(a,b) &lt;&lt; endl;
    cout &lt;&lt; strlen(a) &lt;&lt; endl;  //字符串实际长度

    /*
        要想重新给字符数组赋值，只能一个一个赋，别无他法，如下代码
    */
    a[0]='w';
    a[1]='o';
    a[2]='r';
    a[3]='l';
    a[4]='d';

    /*
        或者也可以这样,如下代码
    */
    strcpy(a,&quot;fuck you&quot;);
    cout &lt;&lt; a &lt;&lt; endl;

    //字符串连接
    strcat(a,b);
    cout &lt;&lt; a;
   
    return 0;
}

</code></pre>
<p><span id="jump3">3.string类的字符串翻转</span></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
    string str = &quot;song&quot;;
    reverse(str.begin(), str.end());
    cout &lt;&lt; str;
    return 0;
}

</code></pre>
<p><span id="jump4">4.字符串的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a=&quot;fuck you&quot;,b;  //string是一个类，不用考虑开辟多少存储空间
    a=&quot;asdfkasdkl&quot;;   //string的赋值使用
    b=&quot;world&quot;;
    /*
        字符串的比较
    
    if(a==b)
        cout &lt;&lt; &quot;==&quot;;
    else
        cout &lt;&lt; &quot;!=&quot;;*/
        
    /*拼接字符a与b
    a=a+b;   
    cout &lt;&lt; a;
    */
    return 0;
}

//****************string的小用法********************
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string user;
    string passwd;

    cin &gt;&gt; user;  //string使用空格和回车结束
    cin &gt;&gt; passwd;

    if(user==&quot;admin&quot; &amp;&amp; passwd==&quot;dotcpp&quot;)
    {
        cout &lt;&lt; &quot;yes&quot;;
    }
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}


</code></pre>
<p><span id="jump5">5.指针的使用</span><br>
1.指针基本使用<br>
2.数组的指针的使用<br>
3.指针作为函数参数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int swap(int *a, int *b)
{
    /*当函数结束，不会交换值
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;*/
    
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    return 0;

}
int main()
{
    /*指针基本使用
    int a;
    int *p;
    p=&amp;a;   //&amp;取地址运算符,p存放a的地址或p指向a
    *p=99;   //相当于对a进行赋值
    cout &lt;&lt; *p &lt;&lt; endl;*/

    /*数组的指针的使用
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    int *p;
    p=&amp;a[0];
    for(int i=0; i&lt;10; i++)
        cout &lt;&lt; *(p+i) &lt;&lt; endl;  //*(p+i) == a[i] */

    int a=10,b=20;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;

    return 0;
}

</code></pre>
<p><span id="jump6">6.输出字符数组的三种写法+二维数组的指针使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()
{
    /*输出字符数组的三种写法
    char str[100]=&quot;www.dotcpp.com&quot;;
    char *p;
    p=str; //相当于p=&amp;str[0];
    for(int i=0; i&lt;strlen(str); i++)
    {
        //cout &lt;&lt; *(p+i) &lt;&lt; endl; 第一种写法

        第二种写法
        cout &lt;&lt; *p &lt;&lt; endl;
        p++;

        cout &lt;&lt; p[i] &lt;&lt; endl;    //基址+偏移  第三种写法
    }*/

    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同
    p=str;         //相当于将str[0]行赋给p

    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(str[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);  //p+i就是向下走行，后面+j表示走列
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p><span id="jump7">7.二维数组指针作为函数参数的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int fun(char (*p)[100])
{
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(p[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);
        cout &lt;&lt; endl;
    }
    return 0;
}
int main()
{
    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同

    fun(str);
    return 0;
}

</code></pre>
<p><span id="jump8">8.引用+引用作为参数进行数字交换</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int fun(int &amp;a, int &amp;b)     //使用引用来传递参数
{
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;
}
int main()
{
    /*
    int a;
    int &amp;b=a;  //引用用法，a与b共用一个存储单元，必须初始化
    a=10;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    a=99;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;*/
    int a=20;
    int b=30;
    fun(a,b);         //直接调用时输出a,b
    cout &lt;&lt; a &lt;&lt; b;
    return 0;
}




</code></pre>
<p><span id="jump9">9.new和delete分配和释放空间</span></p>
<pre><code class="language-cpp">1.普通变量的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    //栈空间
    //int a;
    //char b[100];

    //堆空间
    int *p;
    //p=new int;  //申请一个四个字节空间来存整数，并返回四个字节空间首地址
    p=new int(50);  //申请空间时，直接赋值
    //*p=90;
    cout &lt;&lt; *p &lt;&lt; endl;

    delete p;     //一定要释放空间，释放掉指针，new和delete成双成对出现

    return 0;
}

2.数组的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int *p2;
    //p2=new int[100](); //给数组初始化为0
    
    p2=new int[100]{8,7,3,4,5};  //给数组赋不同的值
    
    cout &lt;&lt; p2[0] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];
    
    delete []p2;  //释放定义数组的空间，注意【】不能少
    
    return 0;
}


&lt;span id=&quot;10&quot;&gt;10.结构的使用&lt;/span&gt;
#include&lt;iostream&gt;
using namespace std;
struct stu
{
    string name;
    int num;
    char sex;
};
int main()
{
    stu *p3;
    p3=new stu;
    //p3=new stu{&quot;zhangsan&quot;,1001,'W'}; 不推荐这样赋值，需要c11标准

    p3-&gt;name=&quot;zhangsan&quot;;
    p3-&gt;num=1001;
    p3-&gt;sex='w';

    cout &lt;&lt; p3-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;sex;

    delete p3;
    return 0;
}

</code></pre>
<p><span id="jump10">10.结构的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{
    //struct student A;   //struct student是一个类型，相当于int
    
    student A={1001,&quot;zhangxiaosan&quot;,'W'};     //C++允许这样定义,赋值的时候要和定义时的相同

    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex &lt;&lt; endl;

    /*赋值的一种方式*/
    A.name=&quot;wangxiaoer&quot;;
    A.num=1001;
    A.sex='M';
    
    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex;
    return 0;
}


2.结构指针的使用
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A={1001,&quot;zhangxiaosan&quot;,'W'};
    student *p;
    p=&amp;A;
    
    //以下是指针的两种使用方式
    cout &lt;&lt; (*p).num &lt;&lt; &quot; &quot; &lt;&lt; (*p).name &lt;&lt; &quot; &quot; &lt;&lt; (*p).sex &lt;&lt; endl;
    cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex;
    return 0;
}

3.结构数组的使用
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;    //占位宽setw函数
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A[100]={{1000,&quot;zhangxiaosan&quot;,'W'},{1001,&quot;zhangsan&quot;,'M'},{1002,&quot;lisi&quot;,'W'},{1003,&quot;wangwu&quot;,'W'},{1004,&quot;xiapliu&quot;,'W'}};
    student *p;
    p=A;
    for(int i=0; i&lt;5; i++)
    {
        //cout &lt;&lt; A[i].num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; A[i].name &lt;&lt; &quot; &quot; &lt;&lt; A[i].sex &lt;&lt; endl;
        
        /*使用指针来输出
         cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex &lt;&lt; endl;
         p++;   //p每次走一个结构体  */
    }
    return 0;
}


</code></pre>
<p><span id="jump11">11.公共体</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//共用体:num和s共用一个4个字节内存
union stu
{
    int num;
    char s;
};
int main()
{
    stu A;
    A.num=10;
    cout &lt;&lt; A.num &lt;&lt; endl;   //00000000 00000000 00000000 00001010
    A.s='B';             //66 00000000 00000000 00000000 01000010
    cout &lt;&lt; A.s &lt;&lt; endl;
    cout &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.s;  //最后输出的时候01000010会替换00001010，则前面的sum该为66，后面输出字符
    return 0;
}


</code></pre>
<p><span id="jump12">12.枚举类型</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

//枚举类型:默认从0开始，但也可以赋值
enum week
{
    Sun=30,Mon,Tue,Wed,Thu,Fri,Sat
} ;

int main()
{
    week W;
    W=Tue;
    W=Sat;
    cout &lt;&lt; W;
    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第五章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:24:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.sort和reverse函数</a><br>
<a href="#jump2">2.accumulate函数</a><br>
<a href="#jump3">3.find函数</a><br>
<a href="#jump4">4.vector用法+push_back()输入+迭代器输出</a><br>
<a href="#jump5">5.vector中v.front()返回首元素和v.back()返回尾元素</a><br>
<a href="#jump6">6.vector中v.empty()函数（判断vector是否为空）</a><br>
<a href="#jump7">7.v.size()+删除某个元素v.erase()+清空整个vector：v.clear()+删除最后一个元素v.pop_back()</a><br>
<a href="#jump8">1033</a></p>
<p><span id="jump1">1.sort和reverse函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//STL(标准模板库):容器（链表，堆，栈....），迭代器（类似于指针），算法
//sort
//reverse
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    
    //sort排序中要放两个指针，第一个是起始地址，第二个是结束地址，但是要给数组最后一个元素的下一个地址,sort默认为升序排列
    sort(&amp;a[0],&amp;a[5]);     
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;

    //reverse用法：sort+reverse可以降序排列
    reverse(&amp;a[0],&amp;a[5]);
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;
    return 0;
}

</code></pre>
<p><span id="jump2">2.accumulate函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;numeric&gt;

using namespace std;
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    /*
        1.accumulate里面有三个值：第一个还是数组的第一个地址，第二个是最后一个元素的下一个地址，第三个如果累加和就写0
        2.accumulate是以参数的形式返回
        3.要加头文件numeric
    */
    int i=accumulate(&amp;a[0],&amp;a[4],0);

    cout &lt;&lt; i;
    return 0;
}

</code></pre>
<p><span id="jump3">3.find函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//find

int main()
{
    int *i;
    int a[5]={1,3,5,4,2};
    /*
        1.find中有三个值：第一个数组的地址，第二个是数组中最后一个元素的下一个地址，第三个是要查找的数字
        2.如果数组中有要找的数字，则返回该数字的地址；如果没有则返回数组中最后一个元素的下一个地址
        3.头文件algorithm
    */
    i=find(&amp;a[0],&amp;a[5],1);
    if(i==&amp;a[5])
        cout &lt;&lt; &quot;can't find!&quot;;
    else
        cout &lt;&lt; &quot;success!&quot;;
    return 0;
}

</code></pre>
<p><span id="jump4">4.vector用法+push_back()输入+迭代器输出</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v; //自动调整数组的大小
    vector&lt;int&gt;::iterator it;      //迭代器，指向vector的int类型的指针
    for(int i=0; i&lt;5; i++)
    {
        cin &gt;&gt; a;
        v.push_back(a);      //用v.push_back()对vector进行输入
    }
    
    sort(v.begin(),v.end());     //使用vector和sort结合使用其中v.end()表示最后一个元素的下一个地址
    
    //使用迭代器的方式进行数组访问
    for(it=v.begin(); it!=v.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    
    return 0;
}

</code></pre>
<p><span id="jump5">5.vector中v.front()返回首元素和v.back()返回尾元素</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    /*
        1.v.front()返回首元素
        2.v.back()返回尾元素
    */
    cout &lt;&lt; v.front() &lt;&lt; endl;
    cout &lt;&lt; v.back() &lt;&lt; endl;
    return 0;
}

</code></pre>
<p><span id="jump6">6.vector中v.empty()函数（判断vector是否为空）</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;

    if(v.empty()==true)
        cout &lt;&lt; &quot;yes&quot;;
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}

</code></pre>
<p><span id="jump7">7.v.size()+删除某个元素v.erase()+清空整个vector：v.clear()+删除最后一个元素v.pop_back()</span><br>
注意事项：<br>
1.v.erase()删除某个指定元素后再读取此位置的数字则是下一个位置的数字;<br>
如果要删除其他位置元素：<br>
1.使用迭代器    vector<int>::iterator it<br>
2.it=v.begin()+1; 表示删除v[1]这个元素<br>
3.it=v.begin()+2; 表示删除v[2]这个元素<br>
2.v.pop_back()删除最后一个元素，但是读取的话仍能读取，但是vector的长度会变小</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout &lt;&lt; v.size(); //判断vector的大小

    it=v.begin();
    v.erase(it);    //删除指定的元素
    cout &lt;&lt; *v.begin();

    v.pop_back();    //删除最后一个元素

    v.clear();    //清空vector数组
    cout &lt;&lt; v.size();
    return 0;
}

</code></pre>
<p><span id="jump8">1033</span><br>
解题思路：<br>
1.字符串bad，should<br>
2.以should为主循环遍历，如果bad字符串中含有should中的字符就跳过；如果should中的字符是大写，并且有上档键则跳过<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    string bad,should;
    getline(cin,bad);
    getline(cin,should);
    for(int i=0; i&lt;should.length(); i++)
    {
        if(bad.find(toupper(should[i]))!=string::npos)
            continue;
        if(isupper(should[i])&amp;&amp;bad.find('+')!=string::npos)
            continue;
        cout &lt;&lt; should[i];
    }
    return 0;
}


</code></pre>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string a,b;
bool isTrue(char c)
{
    for(int i=0; i&lt;a.length(); i++)
    {
        /*如果a中有上档键且字符是大写则不输出*/
        if(a[i]=='+')
            if('A'&lt;=c &amp;&amp; c&lt;='Z')
                return false;
        /*a[i]==c包含两种情况，一种数数字字符+一种是大写字符*/
        if(a[i]==c || (a[i]-'A'==c-'a'))
            return false;
    }
    return true;
}
int main()
{
    cin &gt;&gt; a &gt;&gt; b;
    for(int i=0; i&lt;b.length(); i++)
    {
        if(isTrue(b[i]))
            cout &lt;&lt; b[i];
    }
    return 0;
}


/*
    解题思路：
    1.设置一个函数里面包含上档键坏掉，返回false和坏掉的键返回false
*/

</code></pre>
<p>注意事项：<br>
1.在输入字符串时可能会有空格，所以用getline<br>
2.如果改掉字符串的输入方式，我的代码只能得到17分，剩下的3分看不出来</p>
<p>知识总结：<br>
1.getline()与cin的区别：<br>
cin在输入字符串时，遇到空格、制表符或换行符就结束<br>
getline()可以输入时敲入空格，回车，制表符<br>
2.isupper(k)含义：<br>
判断字符k是否为大写字母，是返回1，否则返回0<br>
3.string中find含义：<br>
bad.find('+')表示在字符串bad中找是否含有+这个字符，有，返会+所在的字符串下标，否则，返回npos</p>
]]></content>
    </entry>
</feed>