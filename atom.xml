<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wsf123sd.github.io/</id>
    <title>Gridea</title>
    <updated>2020-05-05T14:12:09.201Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wsf123sd.github.io/"/>
    <link rel="self" href="https://wsf123sd.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wsf123sd.github.io/images/avatar.png</logo>
    <icon>https://wsf123sd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[pat 乙级 1001~1005]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji-1001~1005/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji-1001~1005/">
        </link>
        <updated>2020-05-05T14:10:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1001">1001</h2>
<h3 id="解题思路">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">用while+if-else来控制循环次数（砍得的次数）和判断奇数偶数</font></p>
<h3 id="参考代码">参考代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt; 
using namespace std;

int main()
{
	int n,step=0;
	cin &gt;&gt; n;
	while(n!=1)
	{ 
		if(n%2==0)
			n/=2;
		else
			n=(3*n+1)/2;
		step++;
	} 
	cout &lt;&lt; step;
	return 0;
}
</code></pre>
<h3 id="别人代码">别人代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, count = 0;
 cin &gt;&gt; n;
 while (n != 1)
  {
	 if (n % 2 != 0)      //这个循环就是判断奇数的，n为奇数*3+1完了，在下一句除2 这样就省掉了加括号的麻烦 抓住了不管奇数还是偶数                         
//都有除2的特点 如果n为偶数不执行此语句，直接再下面除2
		 n = 3 * n + 1;   
	 n = n / 2;
	 count++;
 }
 cout &lt;&lt; count;
 return 0; }
</code></pre>
<h2 id="1002">1002</h2>
<h3 id="解题思路-2">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.用string类来存储数据，不然的话double，long long类型的长度不够</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.用for循环来计算各位数字之和</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">3.用string类定义一个数组，其中成员是数字的拼音</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.将数字和变量改为字符串类型，方便调用每个位数字，不用对数字除或求余</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">5.通过循环从数字和的字符串中对应找到string类的数字拼音</font></p>
<h3 id="参考代码-2">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int main()
{
	string s;
	cin &gt;&gt; s;
	int i,sum=0;
	for(i=0; i&lt;s.length(); i++)     //s.length()计算字符串长度 
	{
		sum+=s[i]-'0';
	}
	string name[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};  //字符串用双引号括起来，字符用单引号括起来 
	
	string a = to_string(sum);
	
	for(i=0; i&lt;a.length(); i++)
	{
		cout &lt;&lt; name[a[i]-'0'];   //将数字转变为字符去存储方便调用每个位置上的数字，不用再除或求余啥的 
		if (i != a.length()-1)
			cout &lt;&lt; ' ';
	}
	

	return 0;
}
</code></pre>
<h3 id="别人代码-2">别人代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() 
{
	 string s;
	 cin &gt;&gt; s;
	 int sum = 0;
	 string str[10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;};   //
	 for (int i = 0; i &lt; s.length(); i++)
	 	sum += (s[i] - '0');
	 	
	 string num = to_string(sum);
	 
	 for (int i = 0; i &lt; num.length(); i++)
	 {
		 if (i != 0)        //题目要求最后一个拼音不能有空格，所以是先输出拼音，后输出空格，提前加一个if判断，当输入完最后一个拼音，循环都已经结束了
		 	cout &lt;&lt; &quot; &quot;;
		 cout &lt;&lt; str[num[i] - '0'];
	 }
	 
	 return 0; 
 }
</code></pre>
<h2 id="1003">1003</h2>
<h3 id="解题思路-3">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.本题难点在于找规律，首先明确一点不是AAA...AAPAA...AATAA...AA这么简单的规律。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.突破点在于aPbTc正确和aPbATca正确，显然第二个在P与A之间多加了一个A，后面多了一个a，而a又是第一个的P之前的部分，其实这里a,b,c均是狗（宇哥替换）。观察例子：AAPATAA与AAPAATAAAA，这里a相当于AA，b相当于A，c相当于AA。在第二个中P,T之间多加了A，则后面多加AA。所以规律是在P,T之间多加一个A，则原来字符串T后面多 补充 原来字符串P之前的部分。比如对于AAPAATAAAA而言，AAPAAATAAAAAA也是对的，AAPAAATAAAAAAAA也是对的。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">3.如果P之前没有A，则无论在P,T之间加多少的A，T之后也不会有A,所以形如PAAA...AAAT都对</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">4.xPATx这种形式告诉我们，AAA...AAAPATAAA...AAA是可以的，只要PAT前和后的AAA对称。二一个当x为空格是PAT也是正确。</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">5.通过例子可知有且仅有P,A,T三种字符，其中P,T的个数只能为1，而A的个数不能0，P,T之间至少一个A，对于APAAATAA我们可知可以由APAATA得来，但是例子表示APAAATAA是错误，所以APAATA也是错误</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">6.总之，就是P之前A的个数*P与T之间A的个数等于T之后A的个数 （这规律我估计也不是他想出来的，或者就是偶然想到的</font></p>
<h3 id="参考代码-3">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

int main()
{
	int n,i,j,p,t;
	cin &gt;&gt; n;
	string s;
	for(i=0; i&lt;n; i++)
	{
		cin &gt;&gt; s;
		map&lt;char, int &gt; m;
		for(j=0; j&lt;s.length(); j++)
		{
			m[s[j]]++;
			if(s[j]=='P')
				p=j;
			if(s[j]=='T')
				t=j;
		}
		if(m['P']==1 &amp;&amp; m['A']!=0 &amp;&amp; m['T']==1 &amp;&amp; m.size()==3 &amp;&amp; t-p!=1 &amp;&amp; p*(t-p-1)==s.length()-t-1)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<h2 id="1004">1004</h2>
<h3 id="解题思路-4">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.首先根本不用存储每次输入的学生的信息，重点是要知道成绩最值的学生的姓名和学号，所以用变量来存储这些信息。“铁打的营盘流水的兵”恰如其分描述铁打的营盘类似成绩最值的姓名和学号，而流水类似不断敲入的学生成绩，姓名和学号</font></p>
<h3 id="参考代码-4">参考代码：</h3>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, max = -1, min = 101, score;
 cin &gt;&gt; n;
 string maxname, minname, maxnum, minnum, name, num;
 for (int i = 0; i &lt; n; i++) {
 cin &gt;&gt; name &gt;&gt; num &gt;&gt; score;
 if (max &lt; score) {
 max = score;
 maxname = name;
 maxnum = num;
 }
 if (min &gt; score) {
 min = score;
 minname = name;
 minnum = num;
 }
 }
 cout &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; maxnum &lt;&lt; endl &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; minnum;
    return 0; }
</code></pre>
<h2 id="1005">1005</h2>
<h3 id="解题思路-5">解题思路：</h3>
<p><font color=\#7FFF00 size=3 face="黑体">1.设置一个数组arr[]其中表示对输入数字进行c式处理后对应下标为1<br>
比如：输入5 ，第一次c式处理后为8，则将arr[8]的值为1<br>
先判断arr值是否为1，是则退出循环，输入下一个值判断，不是另其值为1</font></p>
<p><font color=\#7FFF00 size=3 face="黑体">2.注意arr数组的空间大小为10000否则只是部分正确</font></p>
<h3 id="参考代码-5">参考代码：</h3>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int arr[10000];
bool cmp(int a, int b)
{
    return a&gt;b;
}

int main()
{
    int k,n,flag=0;
    cin &gt;&gt; k;
    vector&lt;int&gt; v(k);//定义一个数组
    //for中嵌套while，外面一共循环k次，里面就是对数字处理并且标记对应arr数组中的值为1
    //如果在while中判断数字有1则直接输入下一个数
    for(int i=0; i&lt;k; i++)
    {
        cin &gt;&gt; n;
        v[i]=n;   //数组存放对应的数字
        while(n!=1)
        {
            if(n%2!=0)
                n=3*n+1;
            n/=2;
            /*?*/
            if(arr[n]==1)
                break;
            arr[n]=1;
        }
    }
    sort(v.begin(), v.end(), cmp); //将数组按照从大到小的顺序排列
    for(int i=0; i&lt; v.size(); i++)
    {
        if(arr[v[i]]==0) //表示
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; v[i];
            flag=1;

        }
    }
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试]]></title>
        <id>https://wsf123sd.github.io/post/ce-shi/</id>
        <link href="https://wsf123sd.github.io/post/ce-shi/">
        </link>
        <updated>2020-03-16T17:04:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一章-朝花夕拾">第一章 朝花夕拾</h2>
<h3 id="1小于">1.小于</h3>
<h3 id="1小于打开四六级">1.小于打开四六级</h3>
<h3 id="1小于九分裤">1.小于九分裤</h3>
<h3 id="1小于了">1.小于，；了</h3>
<h3 id="1小于没考虑">1.小于没考虑</h3>
<h2 id="第二章-呐喊">第二章 呐喊</h2>
<h3 id="1jkcj">1.jkcj</h3>
<h3 id="1jkcasf-dlk">1.jkcasf dlk</h3>
<h3 id="1jkcjj-klm">1.jkcjj klm</h3>
<h3 id="1jkcjjklrjklw">1.jkcjjklrjklw</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

/*
    构造结点：
    1.两个int类型
    2.还有一个next指针
*/
struct LinkList
{
    int z;
    int fu;
    LinkList *next;
};

/*
    构造链表：
    1.定义一个LinkList的头指针
    2.定义两个临时变量存放每次的输入
    3.while循环：
        1.输入两个值
        2.动态分配一个结点空间
        3.如果结点空间分配失败，
*/
LinkList *BuildList(int n)
{
    LinkList *head=NULL;
    int zheng,fushu;
    while(n--)
    {
       cin &gt;&gt; zheng &gt;&gt; fushu;
       LinkList *new_node=(LinkList *)malloc(sizeof(LinkList));
        if(new_node==NULL)
        {
            cout &lt;&lt; &quot;filed!&quot;;
            return head;
        }
        new_node-&gt;z=zheng;
        new_node-&gt;fu=fushu;
        LinkList *p;
    if(head==NULL)
    {
        new_node-&gt;next=NULL;
        head=new_node;
        p=head;
    }
    else
    {

        p-&gt;next=new_node;
        new_node-&gt;next=NULL;
        p=new_node;
    }
  }
    return head;
}

//对构造的链表进行相加
void CountList(LinkList *head)
{
    LinkList *p=head;
    int zheng=0,fu=0;
    while(p)
    {
        zheng+=p-&gt;z;
        fu+=p-&gt;fu;
        p=p-&gt;next;
    }
    cout&lt;&lt;zheng&lt;&lt;&quot;+&quot;&lt;&lt;fu&lt;&lt;&quot;i&quot;&lt;&lt;endl;
}

int main()
{
    int n;
    cin&gt;&gt;n;
    LinkList *head=BuildList(n);
    CountList(head);
    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第三章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/">
        </link>
        <updated>2020-03-16T13:03:54.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.函数定义：返回abc中最大值</a></p>
<p><a href="#jump2">2.函数重载</a></p>
<p><a href="#jump3">3.带默认参数函数和一个函数不能即是带默认参数函数又是函数重载</a></p>
<p><a href="#jump4">4.变量的使用</a></p>
<p><a href="#jump5">5.register和static</a></p>
<p><a href="#jump6">6.关键字extern：扩大作用域的范围</a></p>
<p><span id="jump1">1.函数定义：返回abc中最大值</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

\#include&lt;iomanip&gt;

using namespace std;

int fun(int a, int b, int c);

/*

   函数定义：返回值类型 函数名 形参表

   函数定义顺序：函数声明-&gt;主函数-&gt;函数定义

   函数的思想：低耦合，高为聚（函数之间耦合度要低，高维聚表示函数的功能尽可能集中）

*/

int main()

{

​    int a,b,c;

​    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;

​    cout &lt;&lt; fun(a,b,c);

​    return 0;

}

int fun(int a, int b, int c)

{

   return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;

}



</code></pre>
<p><span id="jump2">2.函数重载</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

using namespace std;

//函数重载:一物多用



/*

​    1.保证函数名形同，形参的个数或类型不同,函数的类型也可以不同

​    2.对于调用时，若两个数就使用第2个判断，若3个数就使用第一个判断

*/



int fun(int a,int b,int c);

int fun(int a, int b);

double fun(double a, double b, double c);

int main()

{

​    cout &lt;&lt; fun(5.0,1.0,11.11) &lt;&lt; endl;

​    return 0;

}



int fun(int a,int b)

{

​    return a&gt;b?a:b;

}



int fun(int a, int b, int c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;

​    return a;

}



double fun(double a,double b, double c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;double&quot; &lt;&lt; endl;

​    return a;

}



</code></pre>
<p><span id="jump3">3.带默认参数函数和一个函数不能即是带默认参数函数又是函数重载</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

using namespace std;

/*

​    带默认参数的函数使用

​    1.在函数声明的过程中，就放上参数，而在函数定义和函数调用过程的过程中不要放参数

​    这样最后的结果就是参数的函数值

​    2.如果函数调用中，传部分值也可以

​    3.给函数申明赋初值时，优先从右至左

​    4.函数调用时将实参赋值给形参的顺序是从左至右

​    5.有实参用实参没实参用形参

​    6.特别注意一个函数不能即做函数重载又做带默认值函数

*/

int fun(int a=1, int b=1, int c=2);

int fun(int a,int b);  //6.函数调用时是用上面还是用下面？

int main()

{

​    cout &lt;&lt; fun(5,2) &lt;&lt; endl;

​    return 0;

}



int fun(int a, int b, int c)

{

​    if(b&gt;a)

​        a=b;

​    if(c&gt;a)

​        a=c;

​    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;

​    return a;

}





</code></pre>
<p><span id="jump4">4.变量的使用</span></p>
<pre><code class="language-cpp">
\#include&lt;iostream&gt;

\#include&lt;iomanip&gt;

using namespace std;

int a=15;     //全局变量,函数外部，作用范围： 全局变量的生命周期是整个程序

/*



*/

int fun()

{

​    int a;

​    a=20;

}

int main()

{

​    auto int b;   //auto动态存储类别，不写也可以就是平时用的

​    static int a;  //静态类型，只初始化一次

​    int a;      //局部变量，就在它自身的函数内可用,如果全局变量和局部变量重名时，以函数内的局部变量为准

​    a=10;          //当函数运行完，局部变量生命周期就结束

​    cout &lt;&lt; a &lt;&lt; endl;

​    return 0;

}



</code></pre>
<p><span id="jump5">5.register和static</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;



int fun()

{

   static int a=10;  //只初始化一次，第2次调用此函数值为12不是11

   register int a=10;   //把变量设置为register可以高效的读取该变量,建议性的动作，每次调用函数后都会重新设置a=10，即两次调用的结果都为11

   extern 

   for(a=10; a&lt;1000; a++)

   {

​       

   }

​    a++;

​    cout &lt;&lt; a &lt;&lt; endl;

​    return 0;

}





int main()

{

​    fun();

​    fun();

​    return 0;

}



</code></pre>
<p><span id="jump6">6.关键字extern：扩大作用域的范围</span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://wsf123sd.github.io/post/markdown-yu-fa/</id>
        <link href="https://wsf123sd.github.io/post/markdown-yu-fa/">
        </link>
        <updated>2020-03-01T15:28:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一级标题ctrl1">一级标题（Ctrl+1）</h1>
<p>快速生成目录（[toc]+回车）</p>
<p>[toc]</p>
<h2 id="二级标题ctrl2">二级标题（Ctrl+2）</h2>
<h3 id="三级标题ctrl3">三级标题（Ctrl+3）</h3>
<p><u>这是下划线（Ctrl+u）</u></p>
<p><s>这是删除线(alt+shift+5)</s></p>
<p><strong>字体加粗（ctrl+b）</strong></p>
<p><em>字体倾斜（Ctrl+i）</em></p>
<ul>
<li>牛奶（先输入-再输入空格就是无序列表）</li>
<li>面包</li>
<li>蛋糕
<ul>
<li>包子（再输入-和空格都是无序列表的嵌套）</li>
<li>鸡蛋</li>
</ul>
</li>
</ul>
<ol>
<li>你好（数字+.+空格）</li>
<li>我好</li>
<li>他也好
<ol>
<li>电脑（再输入数字+.+空格就是有序列表嵌套）</li>
<li>鼠标</li>
</ol>
</li>
</ol>
<blockquote>
<p>引用（&gt;+空格）</p>
</blockquote>
<p><a href="https://wsf123sad.github.io/">这是链接</a></p>
<p>直接粘贴复制</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200228122119497.png" alt="image-20200228122119497" loading="lazy"></figure>
<pre><code class="language-c++">//ctrl+shift+k(代码块)
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a,int b;
}
</code></pre>
<p>home family 沙墟（ctrl+d选中英文单词或者中文）</p>
<p>asdkjklj(ctrl+l按行选中)</p>
<p>快速搜索（ctrl+f）</p>
<p>替换（ctrl+h）</p>
<p>快速生成表格（ctrl+t）</p>
<table>
<thead>
<tr>
<th style="text-align:center">asd</th>
<th style="text-align:center">ds</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdfasd</td>
<td style="text-align:center">sdaf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>快速打开文件（ctrl+p）</p>
<p><code>关键字</code>爱神的箭（ctrl+shift+tab键上面的反引号）</p>
<p>表情符号：（在微软的输入法下，ctrl+shift+b）</p>
<p>😍❤</p>
<p>ctrl+n创建新文件，ctrl+w关闭文件</p>
<p>ctrl+shift+l显示和隐藏侧边栏</p>
<p>f11全屏</p>
<p>三个---+回车是分割线</p>
<hr>
<p><mark>高亮</mark> (俩个=+文字+俩个=)</p>
<p>爱是考虑到（ctrl+0段落标签）</p>
<p>脚注：</p>
<p>Jobs<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>先输入Jobs+[]+中括号内写^1,然后回车后有自动提示</p>
<p>文件导出：文件-&gt;导出（选择格式）</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>苹果公司的创始人 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第一，二章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:27:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.开始介绍c++</a></p>
<p><a href="#jump2">2.各种云算符</a></p>
<p><a href="#jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</a></p>
<p><a href="#jump4">4.switch结构</a></p>
<p><a href="#jump5">5.打印水仙花的两种算法</a></p>
<p><span id="jump1">1.开始介绍c++</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       头文件   

using namespace std;        std名称空间



int main(int argc, char** argv)

{

  int a=5;

  char b='N';

  float c=3.14;

  double d=56.789;

  

  bool e;  //布尔值 

  

  e=true;

  cout &lt;&lt; e &lt;&lt; endl;

  e=false;

  cout &lt;&lt; e &lt;&lt; endl;

  

  /*

  cout &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt; '\n' &lt;&lt; endl;

  cout &lt;&lt; b &lt;&lt; endl;

  cout &lt;&lt; c &lt;&lt; endl;

  cout &lt;&lt; d &lt;&lt; endl; 

  */



  return 0;

} 

</code></pre>
<p><span id="jump2">2.各种运算符</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       

#include&lt;iomanip&gt;   

using namespace std;        



int main(int argc, char** argv)

{

  //赋值运算符 从右至左

  int a=10;

  a=98; 

  //算术运算符

  //+ - * / % (双目运算符)  ++ -- (单目运算符) 

  //关系运算符

  //&gt; &lt; &lt;= &gt;= == != (双目运算符) 

  //逻辑运算符

  //&amp;&amp;(左右都为真，则为真) //(有一个为真，就为真) !

  //位运算符 

  //&lt;&lt;(将数字变为2进制，左移右补0) &gt;&gt; &amp; / ^ (将数字转变为2进制计算) 

  //&amp;:两个结果都为1，则值为1  

  // /:有一个为1，则为1

  // ^:两个相同则为0，不同为1 

  //三目运算符

  //?:

  //  1&gt;2? 5:6 

  //逗号运算符  2+3,9  这个表示一个式子，结果是最后一个值 

  //求字节运算符:sizeof()

  

  

  //逗号运算符：整个逗号表达式的值为系列中最后一个表达式的值。 





  int i,j;

  

  j=10;

  i=(j++,j+100,999+j);   //j自增1，完了j加上100变为111， 最后j再加上999， 结果为1010 

  

  cout &lt;&lt; i;

 

  return 0;

} 

</code></pre>
<p><span id="jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include &lt;iomanip&gt;      //使用setprecision的头文件 

using namespace std;



int main(int argc, char** argv)

{

  double a=356.1415926535897932;    //默认为保存6位 

  double b=25.2222365; 

  //cout &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;   //  setprecision(保存的位数) 设置整体的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl; // 只设置小数点后的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right)&lt;&lt;setw(10)&lt;&lt;a&lt;&lt;endl;   //设置数字向右靠，一共设置10位 

  

  /* 在第14行设置好，下面a，b输出都按照要求输出，主要若将setw(10)写在第14行，只有a的是保留10位靠右输出 

​    cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right);

  cout &lt;&lt;setw(10) &lt;&lt; setfill('0') &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  */

  

  //使用字符&amp;来补充，setfill(要填充的内容) 

  cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right) &lt;&lt; setfill('&amp;') ;

  cout &lt;&lt;setw(10) &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  

  return 0;

}

</code></pre>
<p>‘A’65</p>
<p>‘Z’90</p>
<p>'0'48</p>
<p><span id="jump4">4.switch结构</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main(int argc, char** argv)

{

​    int a;

​    cin &gt;&gt; a;

​    switch(a)

​    {

​        case 1:

​        case 2:

​        case 3: cout &lt;&lt; &quot;spring&quot; &lt;&lt; endl;break;

​        case 4:

​        case 5:

​        case 6: cout &lt;&lt; &quot;summer&quot; &lt;&lt; endl;break;

​        case 7:

​        case 8:

​        case 9: cout &lt;&lt; &quot;autumn&quot; &lt;&lt; endl;break;

​        case 10:

​        case 11:

​        case 12: cout &lt;&lt; &quot;winter&quot; &lt;&lt; endl;break;

​        default:cout &lt;&lt; &quot;others&quot; &lt;&lt; endl;break;



​    }

​    return 0;

}

</code></pre>
<p><span id="jump5">5.打印水仙花数的两种算法</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main()

{

​    /*

​    int i=100;

​    int a,b,c;

​     while(i&lt;1000)

​     {

​         a=i/100;

​         b=i%100/10;

​         c=i%10;

​         if(a*a*a+b*b*b+c*c*c==i)

​            cout &lt;&lt; i &lt;&lt; endl;

​         i++;

​     }

​     return 0;

​     */

/*

​    下面的三次循环效率比上面高，因为while循环内部运算次数远远大于下面，上面每次都要计算出a,b,c的值，而下没有一步是要算出确切的值

*/     

​     

​     int a=1,b=1,c=1;

​     for(a=1; a&lt;10; a++)

​     {

​         for(b=0; b&lt;10; b++)

​         {

​             for(c=0; c&lt;10; c++)

​             {

​                 if(a*a*a+b*b*b+c*c*c == a*100+b*10+c)

​                        cout &lt;&lt; a*100+b*10+c &lt;&lt; endl;

​             }

​         }

​     }

​     return 0;

}





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第四章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:25:40.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.二维数组</a><br>
<a href="#jump2">2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</a><br>
<a href="#jump3">3.string类的字符串翻转</a><br>
<a href="#jump4">4.字符串的使用</a><br>
<a href="#jump5">5.指针的使用</a><br>
<a href="#jump6">6.输出字符数组的三种写法+二维数组的指针使用</a><br>
<a href="#jump7">7.二维数组指针作为函数参数的使用</a><br>
<a href="#jump8">8.引用+引用作为参数进行数字交换</a><br>
<a href="#jump9">9.new和delete分配和释放空间</a><br>
<a href="#jump10">10.结构的使用</a><br>
<a href="#jump11">11.共用体</a><br>
<a href="#jump12">12.枚举类型</a></p>
<p>9.new和delete分配和释放空间</p>
<p>8.引用+引用作为参数进行数字交换8.引用+引用作为参数进行数字交换</p>
<p><span id="jump1">1.二维数组</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;


int main()
{
    int b[3][4]={1,2,3,4,5};  //二维数组用双层for循环
    
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;4; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p><span id="jump2">2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</span></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;  //一定是cstring不是string
#include&lt;iomanip&gt;
using namespace std;

int main ()
{
    //strcmp
    //strlen
    //strcpy
    //strcat
    char a[100]=&quot;hello&quot;;
    char b[100]=&quot;helleajsdkl&quot;;
    /*
        字符串比较，如果相同返回0‘如果第一个大，返回1,；如果第2个大，返回负值。
        从左到右比较时第一个不同比较完就完
    */
    cout &lt;&lt; strcmp(a,b) &lt;&lt; endl;
    cout &lt;&lt; strlen(a) &lt;&lt; endl;  //字符串实际长度

    /*
        要想重新给字符数组赋值，只能一个一个赋，别无他法，如下代码
    */
    a[0]='w';
    a[1]='o';
    a[2]='r';
    a[3]='l';
    a[4]='d';

    /*
        或者也可以这样,如下代码
    */
    strcpy(a,&quot;fuck you&quot;);
    cout &lt;&lt; a &lt;&lt; endl;

    //字符串连接
    strcat(a,b);
    cout &lt;&lt; a;
   
    return 0;
}

</code></pre>
<p><span id="jump3">3.string类的字符串翻转</span></p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
    string str = &quot;song&quot;;
    reverse(str.begin(), str.end());
    cout &lt;&lt; str;
    return 0;
}

</code></pre>
<p><span id="jump4">4.字符串的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a=&quot;fuck you&quot;,b;  //string是一个类，不用考虑开辟多少存储空间
    a=&quot;asdfkasdkl&quot;;   //string的赋值使用
    b=&quot;world&quot;;
    /*
        字符串的比较
    
    if(a==b)
        cout &lt;&lt; &quot;==&quot;;
    else
        cout &lt;&lt; &quot;!=&quot;;*/
        
    /*拼接字符a与b
    a=a+b;   
    cout &lt;&lt; a;
    */
    return 0;
}

//****************string的小用法********************
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string user;
    string passwd;

    cin &gt;&gt; user;  //string使用空格和回车结束
    cin &gt;&gt; passwd;

    if(user==&quot;admin&quot; &amp;&amp; passwd==&quot;dotcpp&quot;)
    {
        cout &lt;&lt; &quot;yes&quot;;
    }
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}


</code></pre>
<p><span id="jump5">5.指针的使用</span><br>
1.指针基本使用<br>
2.数组的指针的使用<br>
3.指针作为函数参数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int swap(int *a, int *b)
{
    /*当函数结束，不会交换值
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;*/
    
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    return 0;

}
int main()
{
    /*指针基本使用
    int a;
    int *p;
    p=&amp;a;   //&amp;取地址运算符,p存放a的地址或p指向a
    *p=99;   //相当于对a进行赋值
    cout &lt;&lt; *p &lt;&lt; endl;*/

    /*数组的指针的使用
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    int *p;
    p=&amp;a[0];
    for(int i=0; i&lt;10; i++)
        cout &lt;&lt; *(p+i) &lt;&lt; endl;  //*(p+i) == a[i] */

    int a=10,b=20;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;

    return 0;
}

</code></pre>
<p><span id="jump6">6.输出字符数组的三种写法+二维数组的指针使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()
{
    /*输出字符数组的三种写法
    char str[100]=&quot;www.dotcpp.com&quot;;
    char *p;
    p=str; //相当于p=&amp;str[0];
    for(int i=0; i&lt;strlen(str); i++)
    {
        //cout &lt;&lt; *(p+i) &lt;&lt; endl; 第一种写法

        第二种写法
        cout &lt;&lt; *p &lt;&lt; endl;
        p++;

        cout &lt;&lt; p[i] &lt;&lt; endl;    //基址+偏移  第三种写法
    }*/

    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同
    p=str;         //相当于将str[0]行赋给p

    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(str[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);  //p+i就是向下走行，后面+j表示走列
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p><span id="jump7">7.二维数组指针作为函数参数的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int fun(char (*p)[100])
{
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(p[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);
        cout &lt;&lt; endl;
    }
    return 0;
}
int main()
{
    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同

    fun(str);
    return 0;
}

</code></pre>
<p><span id="jump8">8.引用+引用作为参数进行数字交换</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int fun(int &amp;a, int &amp;b)     //使用引用来传递参数
{
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;
}
int main()
{
    /*
    int a;
    int &amp;b=a;  //引用用法，a与b共用一个存储单元，必须初始化
    a=10;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    a=99;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;*/
    int a=20;
    int b=30;
    fun(a,b);         //直接调用时输出a,b
    cout &lt;&lt; a &lt;&lt; b;
    return 0;
}




</code></pre>
<p><span id="jump9">9.new和delete分配和释放空间</span></p>
<pre><code class="language-cpp">1.普通变量的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    //栈空间
    //int a;
    //char b[100];

    //堆空间
    int *p;
    //p=new int;  //申请一个四个字节空间来存整数，并返回四个字节空间首地址
    p=new int(50);  //申请空间时，直接赋值
    //*p=90;
    cout &lt;&lt; *p &lt;&lt; endl;

    delete p;     //一定要释放空间，释放掉指针，new和delete成双成对出现

    return 0;
}

2.数组的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int *p2;
    //p2=new int[100](); //给数组初始化为0
    
    p2=new int[100]{8,7,3,4,5};  //给数组赋不同的值
    
    cout &lt;&lt; p2[0] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];
    
    delete []p2;  //释放定义数组的空间，注意【】不能少
    
    return 0;
}


&lt;span id=&quot;10&quot;&gt;10.结构的使用&lt;/span&gt;
#include&lt;iostream&gt;
using namespace std;
struct stu
{
    string name;
    int num;
    char sex;
};
int main()
{
    stu *p3;
    p3=new stu;
    //p3=new stu{&quot;zhangsan&quot;,1001,'W'}; 不推荐这样赋值，需要c11标准

    p3-&gt;name=&quot;zhangsan&quot;;
    p3-&gt;num=1001;
    p3-&gt;sex='w';

    cout &lt;&lt; p3-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;sex;

    delete p3;
    return 0;
}

</code></pre>
<p><span id="jump10">10.结构的使用</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{
    //struct student A;   //struct student是一个类型，相当于int
    
    student A={1001,&quot;zhangxiaosan&quot;,'W'};     //C++允许这样定义,赋值的时候要和定义时的相同

    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex &lt;&lt; endl;

    /*赋值的一种方式*/
    A.name=&quot;wangxiaoer&quot;;
    A.num=1001;
    A.sex='M';
    
    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex;
    return 0;
}


2.结构指针的使用
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A={1001,&quot;zhangxiaosan&quot;,'W'};
    student *p;
    p=&amp;A;
    
    //以下是指针的两种使用方式
    cout &lt;&lt; (*p).num &lt;&lt; &quot; &quot; &lt;&lt; (*p).name &lt;&lt; &quot; &quot; &lt;&lt; (*p).sex &lt;&lt; endl;
    cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex;
    return 0;
}

3.结构数组的使用
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;    //占位宽setw函数
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A[100]={{1000,&quot;zhangxiaosan&quot;,'W'},{1001,&quot;zhangsan&quot;,'M'},{1002,&quot;lisi&quot;,'W'},{1003,&quot;wangwu&quot;,'W'},{1004,&quot;xiapliu&quot;,'W'}};
    student *p;
    p=A;
    for(int i=0; i&lt;5; i++)
    {
        //cout &lt;&lt; A[i].num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; A[i].name &lt;&lt; &quot; &quot; &lt;&lt; A[i].sex &lt;&lt; endl;
        
        /*使用指针来输出
         cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex &lt;&lt; endl;
         p++;   //p每次走一个结构体  */
    }
    return 0;
}


</code></pre>
<p><span id="jump11">11.公共体</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//共用体:num和s共用一个4个字节内存
union stu
{
    int num;
    char s;
};
int main()
{
    stu A;
    A.num=10;
    cout &lt;&lt; A.num &lt;&lt; endl;   //00000000 00000000 00000000 00001010
    A.s='B';             //66 00000000 00000000 00000000 01000010
    cout &lt;&lt; A.s &lt;&lt; endl;
    cout &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.s;  //最后输出的时候01000010会替换00001010，则前面的sum该为66，后面输出字符
    return 0;
}


</code></pre>
<p><span id="jump12">12.枚举类型</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

//枚举类型:默认从0开始，但也可以赋值
enum week
{
    Sun=30,Mon,Tue,Wed,Thu,Fri,Sat
} ;

int main()
{
    week W;
    W=Tue;
    W=Sat;
    cout &lt;&lt; W;
    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第五章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:24:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.sort和reverse函数</a><br>
<a href="#jump2">2.accumulate函数</a><br>
<a href="#jump3">3.find函数</a><br>
<a href="#jump4">4.vector用法+push_back()输入+迭代器输出</a><br>
<a href="#jump5">5.vector中v.front()返回首元素和v.back()返回尾元素</a><br>
<a href="#jump6">6.vector中v.empty()函数（判断vector是否为空）</a><br>
<a href="#jump7">7.v.size()+删除某个元素v.erase()+清空整个vector：v.clear()+删除最后一个元素v.pop_back()</a><br>
<a href="#jump8">1033</a></p>
<p><span id="jump1">1.sort和reverse函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//STL(标准模板库):容器（链表，堆，栈....），迭代器（类似于指针），算法
//sort
//reverse
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    
    //sort排序中要放两个指针，第一个是起始地址，第二个是结束地址，但是要给数组最后一个元素的下一个地址,sort默认为升序排列
    sort(&amp;a[0],&amp;a[5]);     
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;

    //reverse用法：sort+reverse可以降序排列
    reverse(&amp;a[0],&amp;a[5]);
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;
    return 0;
}

</code></pre>
<p><span id="jump2">2.accumulate函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;numeric&gt;

using namespace std;
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    /*
        1.accumulate里面有三个值：第一个还是数组的第一个地址，第二个是最后一个元素的下一个地址，第三个如果累加和就写0
        2.accumulate是以参数的形式返回
        3.要加头文件numeric
    */
    int i=accumulate(&amp;a[0],&amp;a[4],0);

    cout &lt;&lt; i;
    return 0;
}

</code></pre>
<p><span id="jump3">3.find函数</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//find

int main()
{
    int *i;
    int a[5]={1,3,5,4,2};
    /*
        1.find中有三个值：第一个数组的地址，第二个是数组中最后一个元素的下一个地址，第三个是要查找的数字
        2.如果数组中有要找的数字，则返回该数字的地址；如果没有则返回数组中最后一个元素的下一个地址
        3.头文件algorithm
    */
    i=find(&amp;a[0],&amp;a[5],1);
    if(i==&amp;a[5])
        cout &lt;&lt; &quot;can't find!&quot;;
    else
        cout &lt;&lt; &quot;success!&quot;;
    return 0;
}

</code></pre>
<p><span id="jump4">4.vector用法+push_back()输入+迭代器输出</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v; //自动调整数组的大小
    vector&lt;int&gt;::iterator it;      //迭代器，指向vector的int类型的指针
    for(int i=0; i&lt;5; i++)
    {
        cin &gt;&gt; a;
        v.push_back(a);      //用v.push_back()对vector进行输入
    }
    
    sort(v.begin(),v.end());     //使用vector和sort结合使用其中v.end()表示最后一个元素的下一个地址
    
    //使用迭代器的方式进行数组访问
    for(it=v.begin(); it!=v.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    
    return 0;
}

</code></pre>
<p><span id="jump5">5.vector中v.front()返回首元素和v.back()返回尾元素</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    /*
        1.v.front()返回首元素
        2.v.back()返回尾元素
    */
    cout &lt;&lt; v.front() &lt;&lt; endl;
    cout &lt;&lt; v.back() &lt;&lt; endl;
    return 0;
}

</code></pre>
<p><span id="jump6">6.vector中v.empty()函数（判断vector是否为空）</span></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;

    if(v.empty()==true)
        cout &lt;&lt; &quot;yes&quot;;
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}

</code></pre>
<p><span id="jump7">7.v.size()+删除某个元素v.erase()+清空整个vector：v.clear()+删除最后一个元素v.pop_back()</span><br>
注意事项：<br>
1.v.erase()删除某个指定元素后再读取此位置的数字则是下一个位置的数字;<br>
如果要删除其他位置元素：<br>
1.使用迭代器    vector<int>::iterator it<br>
2.it=v.begin()+1; 表示删除v[1]这个元素<br>
3.it=v.begin()+2; 表示删除v[2]这个元素<br>
2.v.pop_back()删除最后一个元素，但是读取的话仍能读取，但是vector的长度会变小</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout &lt;&lt; v.size(); //判断vector的大小

    it=v.begin();
    v.erase(it);    //删除指定的元素
    cout &lt;&lt; *v.begin();

    v.pop_back();    //删除最后一个元素

    v.clear();    //清空vector数组
    cout &lt;&lt; v.size();
    return 0;
}

</code></pre>
<p><span id="jump8">1033</span><br>
解题思路：<br>
1.字符串bad，should<br>
2.以should为主循环遍历，如果bad字符串中含有should中的字符就跳过；如果should中的字符是大写，并且有上档键则跳过<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    string bad,should;
    getline(cin,bad);
    getline(cin,should);
    for(int i=0; i&lt;should.length(); i++)
    {
        if(bad.find(toupper(should[i]))!=string::npos)
            continue;
        if(isupper(should[i])&amp;&amp;bad.find('+')!=string::npos)
            continue;
        cout &lt;&lt; should[i];
    }
    return 0;
}


</code></pre>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string a,b;
bool isTrue(char c)
{
    for(int i=0; i&lt;a.length(); i++)
    {
        /*如果a中有上档键且字符是大写则不输出*/
        if(a[i]=='+')
            if('A'&lt;=c &amp;&amp; c&lt;='Z')
                return false;
        /*a[i]==c包含两种情况，一种数数字字符+一种是大写字符*/
        if(a[i]==c || (a[i]-'A'==c-'a'))
            return false;
    }
    return true;
}
int main()
{
    cin &gt;&gt; a &gt;&gt; b;
    for(int i=0; i&lt;b.length(); i++)
    {
        if(isTrue(b[i]))
            cout &lt;&lt; b[i];
    }
    return 0;
}


/*
    解题思路：
    1.设置一个函数里面包含上档键坏掉，返回false和坏掉的键返回false
*/

</code></pre>
<p>注意事项：<br>
1.在输入字符串时可能会有空格，所以用getline<br>
2.如果改掉字符串的输入方式，我的代码只能得到17分，剩下的3分看不出来</p>
<p>知识总结：<br>
1.getline()与cin的区别：<br>
cin在输入字符串时，遇到空格、制表符或换行符就结束<br>
getline()可以输入时敲入空格，回车，制表符<br>
2.isupper(k)含义：<br>
判断字符k是否为大写字母，是返回1，否则返回0<br>
3.string中find含义：<br>
bad.find('+')表示在字符串bad中找是否含有+这个字符，有，返会+所在的字符串下标，否则，返回npos</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat乙级]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji/">
        </link>
        <updated>2020-03-01T15:20:42.000Z</updated>
        <content type="html"><![CDATA[<p>1001解题思路：<br>
1.用while+if-else来控制循环次数（砍得的次数）和判断奇数偶数</p>
<p>我的代码如下：</p>
<p>#include <iostream><br>
using namespace std;</p>
<p>int main()<br>
{<br>
int n,step=0;<br>
cin &gt;&gt; n;<br>
while(n!=1)<br>
{<br>
if(n%2<mark>0)<br>
n/=2;<br>
else<br>
n=(3*n+1)/2;<br>
step++;<br>
}<br>
cout &lt;&lt; step;<br>
return 0;<br>
}<br>
#include <iostream><br>
using namespace std;<br>
​<br>
int main()<br>
{<br>
int n,step=0;<br>
cin &gt;&gt; n;<br>
while(n!=1)<br>
{<br>
if(n%2</mark>0)<br>
n/=2;<br>
else<br>
n=(3*n+1)/2;<br>
step++;<br>
}<br>
cout &lt;&lt; step;<br>
return 0;<br>
}<br>
别人的代码：</p>
<p>#include <iostream><br>
using namespace std;<br>
int main() {<br>
int n, count = 0;<br>
cin &gt;&gt; n;<br>
while (n != 1)<br>
{<br>
if (n % 2 != 0)      //这个循环就是判断奇数的，n为奇数*3+1完了，在下一句除2 这样就省掉了加括号的麻烦 抓住了不管奇数还是偶数<br>
//都有除2的特点 如果n为偶数不执行此语句，直接再下面除2<br>
n = 3 * n + 1;<br>
n = n / 2;<br>
count++;<br>
}<br>
cout &lt;&lt; count;<br>
return 0; }<br>
1002解题思路：<br>
1.用string类来存储数据，不然的话double，long long类型的长度不够</p>
<p>用for循环来计算各位数字之和</p>
<p>用string类定义一个数组，其中成员是数字的拼音</p>
<p>将数字和变量改为字符串类型，方便调用每个位数字，不用对数字除或求余</p>
<p>通过循环从数字和的字符串中对应找到string类的数字拼音</p>
<p>my code:</p>
<p>#include<iostream><br>
using namespace std;<br>
​<br>
int main()<br>
{<br>
string s;<br>
cin &gt;&gt; s;<br>
int i,sum=0;<br>
for(i=0; i&lt;s.length(); i++)     //s.length()计算字符串长度<br>
{<br>
sum+=s[i]-'0';<br>
}<br>
string name[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};  //字符串用双引号括起来，字符用单引号括起来</p>
<pre><code>string a = to_string(sum);

for(i=0; i&lt;a.length(); i++)
{
    cout &lt;&lt; name[a[i]-'0'];   //将数字转变为字符去存储方便调用每个位置上的数字，不用再除或求余啥的 
    if (i != a.length()-1)
        cout &lt;&lt; ' ';
}
</code></pre>
<p>​<br>
return 0;<br>
}<br>
other's</p>
<p>#include <iostream><br>
#include <string><br>
using namespace std;<br>
int main()<br>
{<br>
string s;<br>
cin &gt;&gt; s;<br>
int sum = 0;<br>
string str[10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;};   //<br>
for (int i = 0; i &lt; s.length(); i++)<br>
sum += (s[i] - '0');</p>
<pre><code> string num = to_string(sum);
 
 for (int i = 0; i &lt; num.length(); i++)
 {
     if (i != 0)        //题目要求最后一个拼音不能有空格，所以是先输出拼音，后输出空格，提前加一个if判断，当输入完最后一个拼音，循环都已经结束了
        cout &lt;&lt; &quot; &quot;;
     cout &lt;&lt; str[num[i] - '0'];
 }
 
 return 0; 
</code></pre>
<p>}<br>
1003解题思路：<br>
1.本题难点在于找规律，首先明确一点不是AAA...AAPAA...AATAA...AA这么简单的规律。<br>
2.突破点在于aPbTc正确和aPbATca正确，显然第二个在P与A之间多加了一个A，后面多了一个a，而a又是第一个的P之前的部分，其实这里a,b,c均是狗（宇哥替换）。观察例子：AAPATAA与AAPAATAAAA，这里a相当于AA，b相当于A，c相当于AA。在第二个中P,T之间多加了A，则后面多加AA。所以规律是在P,T之间多加一个A，则原来字符串T后面多 补充 原来字符串P之前的部分。比如对于AAPAATAAAA而言，AAPAAATAAAAAA也是对的，AAPAAATAAAAAAAA也是对的。<br>
3.如果P之前没有A，则无论在P,T之间加多少的A，T之后也不会有A,所以形如PAAA...AAAT都对<br>
4.xPATx这种形式告诉我们，AAA...AAAPATAAA...AAA是可以的，只要PAT前和后的AAA对称。二一个当x为空格是PAT也是正确。<br>
5.通过例子可知有且仅有P,A,T三种字符，其中P,T的个数只能为1，而A的个数不能0，P,T之间至少一个A，对于APAAATAA我们可知可以由APAATA得来，但是例子表示APAAATAA是错误，所以APAATA也是错误<br>
6.总之，就是P之前A的个数*P与T之间A的个数等于T之后A的个数 （这规律我估计也不是他想出来的，或者就是偶然想到的）</p>
<p>我的代码：</p>
<p>#include<iostream><br>
#include<map><br>
using namespace std;<br>
​<br>
int main()<br>
{<br>
int n,i,j,p,t;<br>
cin &gt;&gt; n;<br>
string s;<br>
for(i=0; i&lt;n; i++)<br>
{<br>
cin &gt;&gt; s;<br>
map&lt;char, int &gt; m;<br>
for(j=0; j&lt;s.length(); j++)<br>
{<br>
m[s[j]]++;<br>
if(s[j]<mark>'P')<br>
p=j;<br>
if(s[j]</mark>'T')<br>
t=j;<br>
}<br>
if(m['P']==1 &amp;&amp; m['A']!=0 &amp;&amp; m['T']==1 &amp;&amp; m.size()==3 &amp;&amp; t-p!=1 &amp;&amp; p*(t-p-1)==s.length()-t-1)<br>
cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;<br>
else<br>
cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;<br>
}<br>
return 0;<br>
}<br>
1004解题思路：<br>
1.首先根本不用存储每次输入的学生的信息，重点是要知道成绩最值的学生的姓名和学号，所以用变量来存储这些信息。“铁打的营盘流水的兵”恰如其分描述铁打的营盘类似成绩最值的姓名和学号，而流水类似不断敲入的学生成绩，姓名和学号</p>
<p>1005解题思路：<br>
1.设置一个数组arr[]其中表示对输入数字进行c式处理后对应下标为1<br>
比如：输入5 ，第一次c式处理后为8，则将arr[8]的值为1<br>
先判断arr值是否为1，是则退出循环，输入下一个值判断，不是另其值为1<br>
2.注意arr数组的空间大小为10000否则只是部分正确<br>
代码：</p>
<p>#include<iostream><br>
#include<vector><br>
#include<algorithm><br>
using namespace std;<br>
int arr[10000];<br>
bool cmp(int a, int b)<br>
{<br>
return a&gt;b;<br>
}<br>
​<br>
int main()<br>
{<br>
int k,n,flag=0;<br>
cin &gt;&gt; k;<br>
vector<int> v(k);//定义一个数组<br>
//for中嵌套while，外面一共循环k次，里面就是对数字处理并且标记对应arr数组中的值为1<br>
//如果在while中判断数字有1则直接输入下一个数<br>
for(int i=0; i&lt;k; i++)<br>
{<br>
cin &gt;&gt; n;<br>
v[i]=n;   //数组存放对应的数字<br>
while(n!=1)<br>
{<br>
if(n%2!=0)<br>
n=3<em>n+1;<br>
n/=2;<br>
/</em>?*/<br>
if(arr[n]==1)<br>
break;<br>
arr[n]=1;<br>
}<br>
}<br>
sort(v.begin(), v.end(), cmp); //将数组按照从大到小的顺序排列<br>
for(int i=0; i&lt; v.size(); i++)<br>
{<br>
if(arr[v[i]]<mark>0) //表示<br>
{<br>
if(flag</mark>1)<br>
cout &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; v[i];<br>
flag=1;<br>
​<br>
}<br>
}<br>
return 0;<br>
}<br>
​<br>
1006<br>
解题思路：就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n<br>
参考代码：</p>
<p>#include<iostream><br>
using namespace std;<br>
/*<br>
思路就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n<br>
*/<br>
int main()<br>
{<br>
int n;<br>
cin &gt;&gt; n;<br>
for(int i=1; i&lt;=n/100; i++)<br>
cout &lt;&lt; 'B';<br>
for(int j=1; j&lt;=n%100/10; j++)<br>
cout &lt;&lt; 'S';<br>
for(int k=1; k&lt;=n%10; k++)<br>
cout &lt;&lt; k;<br>
return 0;<br>
}<br>
​<br>
1007<br>
解题思路：ans表示有多少对数字<br>
遍历从0--n相邻且相差2的数字，然后判断是否为素数</p>
<p>参考代码：</p>
<p>#include<iostream><br>
using namespace std;<br>
/*<br>
解题思路：ans表示有多少对数字<br>
遍历从0--n相邻且相差2的数字，然后判断是否为素数<br>
<em>/<br>
int f(int n)<br>
{<br>
for(int i=2; i</em>i&lt;=n; i++)<br>
if(n%i==0)<br>
return 0;<br>
return 1;<br>
}<br>
int main()<br>
{<br>
int n,ans=0;<br>
cin &gt;&gt; n;<br>
for(int i=2; i&lt;=n-2; i++)<br>
{<br>
if(f(i) &amp;&amp; f(i+2))<br>
ans++;<br>
}<br>
cout &lt;&lt; ans;<br>
return 0;<br>
}<br>
​<br>
1008.<br>
解题思路：<br>
先把数组倒叙，再把前m为倒叙，再把后面的倒叙即可。（客观规律，记住即可）<br>
之前的思路是向后移数组，在把超出部分放到前面，但这样部分正确。我分析是：使用太多的数组，因为题目要求程序移动的次数竟可能少</p>
<p>参考代码：</p>
<p>#include<iostream><br>
#include<algorithm>  //reverse()使用此头件<br>
#include<vector>  //vector使用此头文件<br>
using namespace std;<br>
int main()<br>
{<br>
int n,m;<br>
cin &gt;&gt; n &gt;&gt; m;<br>
vector<int > a(n);<br>
for(int i=0; i&lt;n; i++)<br>
cin &gt;&gt; a[i];<br>
m%=n;<br>
if(m!=0)<br>
{<br>
reverse(a.begin(),a.end());  //a.begin()是指针，指向数组第一个元素；a.end()也是指针，指向a[6]<br>
reverse(a.begin(),begin(a)+m);  //reverse中不会将第2部分的值也倒转，而是把他之前的值倒转<br>
reverse(begin(a)+m,a.end());  //从上一位置开始<br>
}<br>
for(int i=0; i&lt;n-1; i++)<br>
cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; a[n-1];<br>
return 0;<br>
}<br>
​<br>
1009<br>
解题思路：<br>
利用栈先进后出的思想来倒叙输出字符串<br>
首先，将字符串压入栈，访问栈顶元素，弹出当前栈顶元素。<br>
由于题目要求，字符串之间有空格并且最后一个字符串没有空格，下面就循环先输出空格再输出字符串然后弹出<br>
参考代码：</p>
<p>​<br>
#include<iostream><br>
#include<stack><br>
using namespace std;<br>
​<br>
int main()<br>
{<br>
stack<string> v;<br>
string s;<br>
while(cin &gt;&gt; s)<br>
v.push(s);<br>
cout &lt;&lt; v.top();<br>
v.pop();<br>
while(!v.empty())<br>
{<br>
cout &lt;&lt; &quot; &quot; &lt;&lt; v.top();<br>
v.pop();<br>
}<br>
return 0;<br>
}<br>
​<br>
1010<br>
解题思路：<br>
1.每次输入两个变量，不用存放到数组中，规律是每次输出第一个变量*第二个变量；第二个变量-1<br>
2.对于上面规律使用前提是第二个变量不为0，若为0，不执行语句，进入下一次循环，看，在这里并不是<br>
3. 使用continue，而是循环中嵌套一个if，这样当条件不满足时，自动不执行if中的语句，直接进入下一次循环<br>
4.对于先输出数值，后输出空格，但在最后不能有空格的套路是用flag标记（你懂的）<br>
5.对于零项多项式和全部都是常数项而言，当整个循环结束后还是用flag==0判断，并输出0 0</p>
<p>注意事项：<br>
1 . 0项多项式表示前面没有式子，这样在循环到最后一个式子时输出 0 0<br>
2.对于前面有式子最后一个是0项多项式，这根本不叫0项多项式<br>
3.对于目前这个程序而言根本无法测试出输出&quot;0 0&quot;这个式子因为循环一直不结束，之所以能输出想要的结果那是因为在循环内部就给出值了</p>
<p>参考代码：</p>
<p>#include<iostream><br>
using namespace std;<br>
int main()<br>
{<br>
int flag=0;<br>
int a,b;<br>
while(cin &gt;&gt; a &gt;&gt; b)<br>
{<br>
if(b!=0)<br>
{<br>
if(flag<mark>1)<br>
cout &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; a*b &lt;&lt; &quot; &quot; &lt;&lt; b-1;<br>
flag=1;<br>
}<br>
}<br>
if(flag</mark>0)<br>
cout &lt;&lt; &quot;0 0&quot;;<br>
}<br>
​<br>
1012<br>
解题思路：<br>
1.将输入的数字存放到对5求余对应下标的二维数组中<br>
2.计算A1--A5<br>
1.A2：就是下标为偶数的加 - 下标为奇数的和<br>
3.输出，用printf简单<br>
注意事项：<br>
1.==不是=<br>
2.对于某个点一直过不去，重新敲一遍</p>
<p>/*<br>
解题思路：<br>
1.将输入的数字存放到对5求余对应下标的二维数组中<br>
2.计算A1--A5<br>
1.A2：就是下标为偶数的加 - 下标为奇数的和<br>
3.输出，用printf简单<br>
*/<br>
#include<iostream><br>
#include<vector><br>
using namespace std;<br>
int main()<br>
{<br>
int n,digit,A1=0,A2=0,A3=0,A5=-1;   //对应的变量注意设置出来<br>
double A4=0.0;<br>
cin &gt;&gt; n;<br>
vector<int> a[5];<br>
​<br>
for(int i=0; i&lt;n; i++)<br>
{<br>
cin &gt;&gt; digit;<br>
a[digit%5].push_back(digit);      //这里使用push_back就是将数字压入，自动生成一个二维数组<br>
//注意写法：数组[下标].push_back(要填入的数字);<br>
}<br>
​<br>
for(int i=0; i&lt;5; i++)<br>
for(int j=0; j&lt;a[i].size(); j++)<br>
{<br>
if(i<mark>0 &amp;&amp; a[i][j]%2</mark>0)<br>
A1+=a[i][j];<br>
if(i<mark>1 &amp;&amp; j%2</mark>0)<br>
A2+=a[i][j];<br>
if(i<mark>1 &amp;&amp; j%2!=0)<br>
A2-=a[i][j];<br>
if(i</mark>2)<br>
A3++;<br>
if(i<mark>3)<br>
A4+=a[i][j];<br>
if(i</mark>4 &amp;&amp; a[i][j]&gt;A5)     //一定要是大于A5<br>
A5=a[i][j];<br>
}<br>
for(int i=0; i&lt;5; i++)<br>
{<br>
if(i!=0)<br>
cout &lt;&lt; &quot; &quot;;<br>
if(i<mark>0 &amp;&amp; A1</mark>0 || i!=0 &amp;&amp; a[i].size()<mark>0)<br>
{<br>
cout &lt;&lt; &quot;N&quot;;<br>
continue;<br>
}<br>
if(i</mark>0)<br>
printf(&quot;%d&quot;,A1);<br>
if(i<mark>1)<br>
printf(&quot;%d&quot;, A2);  //计算出结果为何不直接输出值？因为每一次输出都有条件限制，对于不存在的数输出N，<br>
//为了保证思路的理解，就设置成循环，如果不满足条件就输出N，否则按照对应的值输出<br>
if(i</mark>2)<br>
printf(&quot;%d&quot;,A3);<br>
if(i<mark>3)<br>
printf(&quot;%.1f&quot;,A4/a[i].size());<br>
if(i</mark>4)<br>
printf(&quot;%d&quot;,A5);<br>
}<br>
return 0;<br>
}<br>
​<br>
1013<br>
解题思路：<br>
将从第M个素数到第N个素数放到数组中</p>
<p>参考代码：</p>
<p>#include<iostream><br>
#include<vector><br>
using namespace std;<br>
​<br>
bool isprime(int a)<br>
{<br>
for(int i=2; i<em>i&lt;=a; i++)<br>
if(a%i == 0)<br>
return false;<br>
return true;<br>
}<br>
​<br>
int main()<br>
{<br>
int M,N,num=2,cnt=0;<br>
cin &gt;&gt; M &gt;&gt; N;<br>
vector<int> v;<br>
/</em><br>
1.从素数列中找到第m个到第n个放到数组中<br>
2.用while循环，含义是循环至少执行N次，也就是M=5，N=27，循环至少执行27次，表示<br>
从第一素数到第27个素数，而且cnt必须从0开始，因为num初值为2，进入到isprime函数中，<br>
cnt++表示1与2为第一个素数相对应<br>
3.num++与循环的判断条件无关，循环的判断条件是第几个素数，其中cnt为N-1就表示第N个素数<br>
因为cnt从0开始<br>
<em>/<br>
while(cnt &lt; N)       //cnt的值从0开始，自然要小于N<br>
{<br>
if(isprime(num))<br>
{<br>
cnt++;<br>
if(cnt &gt;= M)<br>
v.push_back(num);<br>
}<br>
num++;<br>
}<br>
cnt=0;<br>
/</em><br>
对于每次先输出数字再输出空格，且最后一个不为空格，且每行10个的思想:<br>
1.将输出空格代码放前面，用if的一个条件判断（避开第一次输出空格），<br>
然后紧接着输出数字，依次循环<br>
2.对于每次换行，都希望能与1中的if语句相关联。这样保证每次换行时不会先输出一个空格，<br>
再输出数值，对于每次输出10个，那么每行的第一个就是1,11，21,31.....求余为1<br>
这样在if中可以设置%10!=1输出空格，当然在最后要有如果求余10就输出换行<br>
<em>/<br>
for(int i=0; i&lt;v.size(); i++)<br>
{<br>
cnt++;<br>
if(cnt%10 != 1)<br>
cout &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; v[i];<br>
if(cnt%10 == 0)<br>
cout &lt;&lt; endl;<br>
}<br>
}<br>
​<br>
​<br>
/<strong><strong><strong><strong><strong>我的代码但是超时</strong></strong></strong></strong></strong>/<br>
/</em><br>
解题思路：<br>
1.素数公式判断<br>
2.从第m个素数到第n个素数<br>
主要是找到第一个<br>
1.用while，条件是k<mark>n;k=0<br>
<em>/<br>
#include<iostream><br>
using namespace std;<br>
bool f(int n)<br>
{<br>
​<br>
for(int i=2; i</em>i&lt;=n; i++)<br>
if(n%i</mark>0)<br>
return false;<br>
return true;<br>
}<br>
​<br>
int s(int n)  //找到第n个素数<br>
{<br>
int k=1,i=3;<br>
if(n<mark>1)<br>
{<br>
return 2;<br>
}<br>
while(k!=n)<br>
{<br>
if(f(i))<br>
k++;<br>
i+=2;<br>
}<br>
return i-=2;<br>
}<br>
​<br>
int main()<br>
{<br>
​<br>
int m,n,now=0,flag=0;<br>
cin &gt;&gt; m &gt;&gt; n;<br>
for(int i=s(m); i&lt;=s(n); i++)<br>
{<br>
if(f(i))<br>
{<br>
if(flag</mark>1)<br>
cout &lt;&lt; &quot; &quot;;<br>
cout &lt;&lt; i;<br>
flag=1;<br>
now++;<br>
/*<br>
之前是换行后，先输出空格然后再输出值，我改为每次换行后，将flag的值修改，这样进入<br>
下次循环时，就不会输出空格，并且按照最后一个不为空格的方式输出<br>
*/<br>
if(now%10==0)<br>
{<br>
cout &lt;&lt; endl;<br>
flag=0;<br>
}<br>
}<br>
​<br>
}<br>
​<br>
​<br>
return 0;<br>
}<br>
​<br>
1014<br>
解题思路：<br>
1.用两次while分别找出a,b字符串中第一个和第二个相同字符<br>
2.同样也用while遍历循环c，d两个字符串<br>
参考代码：</p>
<p>#include<iostream><br>
#include<string><br>
using namespace std;<br>
/*<br>
解题思路：<br>
1.用两次while分别找出a,b字符串中第一个和第二个相同字符<br>
2.同样也用while遍历循环c，d两个字符串<br>
*/<br>
int main()<br>
{<br>
string a,b,c,d;<br>
char t[2];<br>
cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>
int i=0,j=0,e=0;<br>
//找到第一个相同的字符<br>
while(i&lt;a.length() &amp;&amp; i&lt;b.length())<br>
{<br>
if(a[i]==b[i] &amp;&amp; ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='G'))<br>
{<br>
t[0]=a[i];<br>
break;<br>
}<br>
i++;<br>
}<br>
i++;<br>
​<br>
//找到第二个相同的字符<br>
while(i&lt;a.length() &amp;&amp; i&lt;b.length())<br>
{<br>
if(a[i]==b[i])<br>
{<br>
if(isdigit(a[i]) || ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='N'))  //isdigit(a[i])判断a[i]是否为数字字符<br>
{<br>
t[1]=a[i];<br>
break;<br>
}<br>
}<br>
i++;<br>
}<br>
​<br>
//找到第三个字符<br>
while(j&lt;c.length() &amp;&amp; j&lt;d.length())<br>
{<br>
if(c[j]==d[j] &amp;&amp; isalpha(c[j]))          //isalpha(c[j])判断c[j]是否为字母<br>
{<br>
e=j;<br>
break;<br>
}<br>
j++;<br>
}<br>
​<br>
​<br>
char sa[7][5]={&quot;MON &quot;,&quot;TUE &quot;,&quot;WED &quot;,&quot;THU &quot;,&quot;FRI &quot;,&quot;SAT &quot;,&quot;SUN &quot;};<br>
cout &lt;&lt; sa[t[0]-'A'];<br>
int m=isdigit(t[1])? t[1]-'0': t[1]- 'A' + 10;    //切记这里用一个整形变量m来接受条件判断的结果，最后在输出<br>
printf(&quot;%02d:%02d&quot;,m,j);       //采用c的方式输出，是为了当数字为1位时，前面有0补充；否则直接输出2位数<br>
​<br>
return 0;<br>
}<br>
​<br>
​<br>
知识总结：</p>
<p>isdigit(A)   //判断A是否为数字字符<br>
isalpha(A)   //判断A是否为字母<br>
1015德才论<br>
解题思路：<br>
1.用一个结构stu来存放数据信息<br>
2.设置一个排序函数，总分不同按照从大到小排列，总分相同，按照按照德分从大到小排列；德分相同，按照<br>
学号从小到大输出<br>
3.设置1个结构数组，一个临时变量结构用来存放每次的输入；循环中嵌套if判断，将对应的结构压入栈中，也就形成了二维数组<br>
4.最后压栈进行排序后并输出<br>
注意事项：<br>
在输入时，用scanf格式控制字符来输入，不会超时<br>
参考代码：</p>
<p>#include<iostream><br>
#include<algorithm><br>
#include<vector><br>
using namespace std;<br>
/*<br>
解题思路：<br>
​<br>
*/<br>
struct node<br>
{<br>
int num,de,cai;<br>
};<br>
​<br>
int cmp(struct node a, struct node b)<br>
{<br>
if((a.de+a.cai)!=(b.de+b.cai))<br>
return (a.de+a.cai) &gt; (b.de+b.cai);   //如果总分数不同，就按照最大到小的顺序排列<br>
else if(a.de!=b.de)                    //如果总分数相同，但德分不同，按照德分从大到小排列<br>
return a.de&gt;b.de;         //从大到小<br>
else<br>
return a.num&lt;b.num;            //从小到大<br>
}<br>
​<br>
​<br>
int main()<br>
{<br>
int low,high,n;<br>
cin &gt;&gt; n &gt;&gt; low &gt;&gt; high;<br>
node temp;<br>
vector<node> v[4];<br>
int total=n;<br>
for(int i=0; i&lt;n; i++)<br>
{<br>
scanf(&quot;%d %d %d&quot;, &amp;temp.num,&amp;temp.de, &amp;temp.cai);<br>
if(temp.de &lt; low || temp.cai &lt; low)<br>
total--;<br>
else if(temp.de &gt;= high &amp;&amp; temp.cai &gt;= high)<br>
v[0].push_back(temp);<br>
else if(temp.de &gt;= high &amp;&amp; temp.cai &lt; high)<br>
v[1].push_back(temp);<br>
else if(temp.de &lt; high &amp;&amp; temp.cai &lt; high &amp;&amp; temp.de &gt;= temp.cai)<br>
v[2].push_back(temp);<br>
else<br>
v[3].push_back(temp);<br>
​<br>
}<br>
cout &lt;&lt; total &lt;&lt; endl;<br>
for(int i=0; i&lt;4; i++)<br>
{<br>
sort(v[i].begin(),v[i].end(),cmp);<br>
for(int j=0; j&lt;v[i].size(); j++)<br>
cout &lt;&lt; v[i][j].num &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].de &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].cai &lt;&lt;endl;<br>
}<br>
return 0;<br>
​<br>
}<br>
​<br>
知识总结：</p>
<p>自定义排序：<br>
struct stu<br>
{<br>
int mark,num;<br>
};<br>
bool cmp(stu a, stu b)<br>
{<br>
if(a.mark != b.mark)<br>
return a.mark &gt; b.mark  //降序排列<br>
else<br>
return a.num&lt;b.num      //mark相同按照num的升序排列<br>
}<br>
vector<stu> v[4];   //结构数组<br>
sort(v[i].begin(),v[i].end(),cmp);  //对数组进行相应的排序<br>
1016<br>
解题思路：<br>
1.用string存放要输入的字符串数组，用int来存放其他类型<br>
2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来<br>
3.两次循环记录相同数字的个数<br>
4.根据相同数字个数是否为0，否就再循环算出对应的值<br>
参考代码</p>
<p>#include<iostream><br>
#include<string><br>
using namespace std;<br>
/*<br>
解题思路：<br>
1.用string存放要输入的字符串数组，用int来存放其他类型<br>
2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来<br>
<em>/<br>
int main()<br>
{<br>
string a,b;<br>
int a1,b1,num1=0,num2=0,suma=0,sumb=0;    //a1,b1表示要找的数字,num1,num2表示个数，suma,sumb表示和<br>
cin &gt;&gt; a &gt;&gt; a1 &gt;&gt; b &gt;&gt; b1;<br>
for(int i=0; i&lt;a.size(); i++)      //记录相同数字的个数<br>
{<br>
if(a1 == a[i]-'0')<br>
num1++;<br>
}<br>
for(int i=0; i&lt;b.size(); i++)        //记录相同数字的个数<br>
{<br>
if(b1 == b[i]-'0')<br>
num2++;<br>
}<br>
​<br>
if(num1!=0)<br>
suma=a1;<br>
if(num2!=0)<br>
sumb=b1;<br>
for(int i=1; i&lt;num1; i++)<br>
suma=suma</em>10+a1;<br>
for(int i=1; i&lt;num2; i++)<br>
sumb=sumb*10+b1;<br>
cout &lt;&lt; suma+sumb;<br>
return 0;<br>
}<br>
​<br>
1017<br>
解题思路：<br>
1.模拟手动求余的过程<br>
2.对于1000位的数字，用string；对于输出商，不用变量存储，直接输出<br>
参考代码：</p>
<p>int main()<br>
{<br>
string s;<br>
int a,t=0,temp=0;<br>
cin &gt;&gt; s &gt;&gt; a;<br>
t=(s[0]-'0')/a;    //t就是商<br>
/*<br>
1.对于只有一位的数，直接输出商t<br>
2.对于2位及2位以上，如17 ，93 这种情况，前者就不输出，后者输出1<br>
<em>/<br>
if((t != 0 &amp;&amp; s.length() &gt; 1) || s.length() == 1)<br>
cout &lt;&lt; t;<br>
temp = (s[0]-'0')%a;    //保存余数<br>
/</em><br>
i从1开始，先计算下一位数的数，输出商，保存余数<br>
<em>/<br>
for(int i=1; i&lt;s.length(); i++)<br>
{<br>
t=(temp</em>10+s[i]-'0')/a;<br>
cout &lt;&lt; t;<br>
temp=(temp*10+s[i]-'0')%a;<br>
}<br>
cout &lt;&lt; &quot; &quot; &lt;&lt; temp;<br>
return 0;<br>
}<br>
1018<br>
解题思路：<br>
1.统计甲赢的次数，乙赢的次数。甲输的次数就是赢的次数，同理，乙也是如此。平的次数就是总数-甲赢的次数-乙赢的次数<br>
2.如何确定赢次数最多的手势？<br>
答：将BCJ默认为012，在统计赢的次数时，记录甲乙赢的时候，对应手势所对应的下标的数组++，最后选出最大的个数，并且记住<br>
下标，最后定义一个字符数组&quot;BCJ&quot;这样刚才统计的下标就可以字符数组相对应<br>
参考代码：</p>
<p>#include<iostream><br>
using namespace std;<br>
/*<br>
解题思路：<br>
1.jiawin  yiwin 分别记录甲赢的次数和已赢的次数<br>
2.a[]  b[]两个数组分别统计B,J,C赢的次数，默认为012<br>
3.最后对数组元素比较得出最大的数组下标，同时设计一个变量，也是BJC这样就输出了对应的值<br>
*/<br>
int main()<br>
{<br>
int jiawin=0,yiwin=0;<br>
int jia[3]={0};<br>
int yi[3]={0};<br>
char s,t;<br>
int n;<br>
cin &gt;&gt; n;<br>
for(int i=0; i&lt;n; i++)<br>
{<br>
cin &gt;&gt; s &gt;&gt; t;<br>
if(s=='B' &amp;&amp; t=='C')<br>
{<br>
jiawin++;<br>
jia[0]++;<br>
}<br>
else if(s=='C' &amp;&amp; t=='J')<br>
{<br>
jiawin++;<br>
jia[1]++;<br>
}<br>
else if(s=='J' &amp;&amp; t=='B')<br>
{<br>
jiawin++;<br>
jia[2]++;<br>
}<br>
else if(s=='C' &amp;&amp; t=='B')<br>
{<br>
yiwin++;<br>
yi[0]++;<br>
}<br>
else if(s=='J' &amp;&amp; t=='C')<br>
{<br>
yiwin++;<br>
yi[1]++;<br>
}<br>
else if(s=='B' &amp;&amp; t=='J')<br>
{<br>
yiwin++;<br>
yi[2]++;<br>
}<br>
}<br>
cout &lt;&lt; jiawin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; yiwin &lt;&lt; endl &lt;&lt; yiwin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; jiawin &lt;&lt; endl;<br>
int maxjia=jia[0]&gt;=jia[1]?0:1;    //设计大于等于的目的是：首先字母已经从字母序从小到大排列，当a[0]==a[1]时，结果max1还是0，不然最后max1就指向j<br>
maxjia=jia[maxjia]&gt;=jia[2]?maxjia:2;<br>
​<br>
int maxyi=yi[0]&gt;=yi[1]?0:1;<br>
maxyi=yi[maxyi]&gt;=yi[2]?maxyi:2;<br>
char k[4]={&quot;BCJ&quot;};<br>
cout &lt;&lt; k[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; k[maxyi];<br>
return 0;<br>
}<br>
注意：BCJ对应012</p>
<p>1019<br>
解题思路：<br>
1.还是用string类来存放输入的数字<br>
2.自定义函数降序排列+结合sort升序排列+字符串转化为数字函数stoi()+数字转化为字符串函数to_string()+对不足四位的数补充0的相关函数s.insert(i,j,k)（题目要求四位输出）+do-while（当先输入0000时，还可以输出）<br>
参考代码：</p>
<p>#include<iostream><br>
#include<algorithm><br>
using namespace std;<br>
bool cmp(char a, char b)<br>
{<br>
return a&gt;b;<br>
}<br>
int main()<br>
{<br>
string s;<br>
cin &gt;&gt; s;<br>
s.insert(0,4-s.length(),'0');    //输入的数字不满足4位，则前补充0<br>
do          //先输入do-while是为了，当输入6174时还能执行一次循环<br>
{<br>
string a=s,b=s;<br>
sort(a.begin(),a.end(),cmp);  //数字以从大到小排列<br>
sort(b.begin(),b.end());      //默认为从小到大<br>
int result=stoi(a)-stoi(b);    //stoi将字符串转化为整数<br>
s=to_string(result);            //将数字转化为字符<br>
s.insert(0,4-s.length(),'0');<br>
cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; s &lt;&lt; endl;<br>
}while(s!=&quot;6174&quot; &amp;&amp; s!=&quot;0000&quot;);<br>
return 0;<br>
}<br>
​<br>
​<br>
/*<br>
知识总结：<br>
1.对字符串第i个位置开始，插入j个k<br>
s.insert(i,k,j);<br>
2.对字符串进行排序<br>
sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列<br>
sort(s.begin(),s.end());         //默认为从小到大排列<br>
3.stoi(str)   //将字符串转化为整数<br>
4.to_string(a)          //将数字转化为字符串<br>
*/<br>
​<br>
知识总结：</p>
<pre><code class="language-cpp">    1.对字符串第i个位置开始，插入j个k
        s.insert(i,k,j);
    2.对字符串进行排序
        sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列
        sort(s.begin(),s.end());         //默认为从小到大排列
    3.stoi(str)   //将字符串转化为整数
    4.to_string(a)          //将数字转化为字符串
​
  
1020
解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
   参考代码：
   
​
```cpp
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
*/
​
struct mooncake
{
    float mount,price,unit;
};
int cmp(mooncake a, mooncake b)
{
    return a.unit &gt; b.unit;
}
int main()
{
    int n,need;
    cin &gt;&gt; n &gt;&gt; need;
    vector&lt;mooncake&gt; a(n); //且记要定义数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].mount);  //切记，float类型的scanf是%f
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].price);
    for(int i=0; i&lt;n; i++)
        a[i].unit=a[i].price/a[i].mount;
​
    sort(a.begin(),a.end(),cmp);
​
    float result=0.0;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i].mount &lt;= need)
            result = result+a[i].price;
        else
        {
            result=result+a[i].unit*need;
            break;
        }
        need=need-a[i].mount;
    }
    printf(&quot;%.2f&quot;,result);
    return 0;
}
​
知识总结：
对于vector定义的数组连续for输入需要指明数组长度

#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
​
int main()
{
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);  //不定以数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; b[i];
    return 0;
}
​
1021
解题思路：
用string存储整数，for遍历循环，定义9个长度的数组，对应的值++，最后按顺序输出数组元素不为0的

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.
*/
int main()
{
    string s;
    int a[10]={0};
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
        a[s[i]-'0']++;
    for(int i=0; i&lt;10; i++)
    {
        if(a[i]!=0)
            cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; a[i] &lt;&lt; endl;
    }
    return 0;
}

注意事项：
有时候，用vector发生错误，就直接用普通数组定义法

1022
解题思路：
    1.将余数存入数组，while的判断条件sum!=0
    2.将数组倒叙输出，j=i-1，
    3.不要忘记sum的0，输出0，return 0
    4.不要用VEctor压栈
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.将余数存入数组，while的判断条件sum!=0
    2.将数组倒叙输出，j=i-1，
    3.不要忘记sum的0，输出0，return 0
    4.不要用VEctor压栈
*/

int main()
{
    int sum,A,B,D,i=0;
    cin &gt;&gt; A &gt;&gt; B &gt;&gt; D;
    int a[100];
    sum=A+B;
    if(sum==0)
    {
        cout &lt;&lt; 0;
        return 0;
    }
    while(sum!=0)
    {
        a[i++]=sum%D;
        sum/=D;
    }
    for(int j=i-1; j&gt;=0; j--)
        cout &lt;&lt; a[j];
    return 0;
}


1023
解题思路：
    1.没理解题意，切记数组是存放数字的个数
    2.先找出第一个不为0的数，并输出
    3.将所有0输出
    4.再输出所有第一个不为0的数
    5.双层for循环输出剩下的所有数，第一层for表示要输出的数字，第二层for表示要输出的个数
    参考代码：

#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a[10];
    int t;
    for(int i=0; i&lt;10; i++)
        cin &gt;&gt; a[i];
    for(int i=1; i&lt;10; i++)
    {
        if(a[i]!=0)
        {
            cout &lt;&lt; i;
            t=i;           //t存放第一个不为0的数
            break;
        }
    }
​
    for(int i=0; i&lt;a[0]; i++)   //输出所有的0
        cout &lt;&lt; 0;
    for(int i=0; i&lt;a[t]-1; i++)   //输出所有第一个不为0的数，因为之前输出了一个，所以这里就少输出1个
        cout &lt;&lt; t;
    for(int i=t+1; i&lt;10; i++)
        for(int j=0; j&lt;a[i]; j++)
            cout &lt;&lt; i;
    return 0;
​
}
​
知识总结：

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.将余数压栈，sum&gt;D
*/
​
int main()
{
    vector&lt;int&gt; a(5);      //用vector定义数组长度就是后面加（n）n表示数组长度
    for(int i=0; i&lt;a.size(); i++)    //遍历数组时，i&lt;a.size()而不是a.end()
        cout &lt;&lt; a[i];
    int k=333;
    string s=to_string(k);      //将数字转化为字符串时用to_string切记是小写的to_string
    cout &lt;&lt; s;
    return 0;
}
​
1024
解题思路：
        1.从E将字符串一分为2，但第一个字符串不包括符号位
        2.将后面的字符串转化为整数放到n
        3.根据n 的正负，选择输出不同的情况
        4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出
 参考代码：

#include&lt;iostream&gt;
using namespace std;
int main()
{
    /*
        解题思路：
        1.从E将字符串一分为2，但第一个字符串不包括符号位
        2.将后面的字符串转化为整数放到n
        3.根据n 的正负，选择输出不同的情况
        4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出
    */
    string s;
    cin &gt;&gt; s;
    int i=0;
​
    while(s[i]!='E')     //此时i表示E所在的位
        i++;
​
    string t=s.substr(1,i-1);     //t保存E之前的字符串，不包括符号位
​
    int n=stoi(s.substr(i+1));     //将E之后下一位开始到字符串结束的转化为数字
​
    if(s[0]=='-')
        cout &lt;&lt; &quot;-&quot;;
​
    cout &lt;&lt; n &lt;&lt; endl;
    if(n&lt;0)
    {
        cout &lt;&lt; &quot;0.&quot;;
​
        for(int j=0; j&lt;abs(n)-1; j++)  //输出0
            cout &lt;&lt; '0';
​
        for(int j=0; j&lt;t.length(); j++)   //遇到.就不输出
            if(t[j] != '.')
                cout &lt;&lt; t[j];
    }
    else
    {
        cout &lt;&lt; t[0];
        int cnt,j;
​
        for(j=2, cnt=0; j&lt;t.length() &amp;&amp; cnt&lt;n; j++,cnt++)  //若.和E之间的数字个数大于n，则只输出n个数字来
            cout &lt;&lt; t[j];
​
        /*
            根据上面for结束的情况，一种是j==t.length()表示.和E之间的数字个数小于n，后面直接输出（n-cnt）个0;
            另一种是cnt==n,表示.和E之间的数字个数大于或等于n，就得先输出. 然后从i=j开始一直到字符完输出
        */
        if(j==t.length())
        {
            for(int k=0; k&lt;n-cnt; k++)
                cout &lt;&lt; '0';
        }
        else
        {
            cout &lt;&lt; '.';
            for(int k=j; k&lt;t.length(); k++)
                cout &lt;&lt; t[k];
        }
    }
    return 0;
}
​
/*
​
​
知识总结：

知识总结：
1.s.substr() 截取字符串中的子串
    s.substr(4)  //表示从4开始到下标结束
    s.substr(5,3)   //表示从5开始3个字符*/
我的代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用string存放输入，判断E之后是+还是-
    2.若为-，
        先输出0. + （后面的值-符号和.之间有几位）*输出0  + 输出s[1]  + 输出s[3]--&gt;s[E所在的前一位]
      若为+，
        先输出s[1] + （输出第3位开始到E之前的所有数字) + （后面的值-小数点和E之间的数字个数）*输出0
    3.若第一个字符为-，必须先输出-
​
*/
​
int main()
{
    string s,s1;
    cin &gt;&gt; s;
    int t,m,k;
    int sum=0;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='E')
        {
            t=i;
            break;
        }
    }
    //计算E之后符号后的数值
    for(int i=t+2; i&lt;s.length(); i++)
    {
        sum+=s[i]-'0';
        sum*=10;
    }
    sum/=10;
    if(s[0]=='-')
        cout &lt;&lt; '-';
    if(s[t+1]=='-')
    {
        cout &lt;&lt; 0 &lt;&lt; '.';
        for(int i=1; i&lt;=sum-1; i++)
            cout &lt;&lt; 0;
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
    }
    else
    {
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
        for(int i=1; i&lt;=sum-(t-3); i++)
            cout &lt;&lt; 0;
    }
    return 0;
}
​
​
1027
    解题思路：
    1.i表示从中间一行向外扩展的层数，比如样例中i为2
    2.3+5+7+...+2i+1=i(i+2)这是上半部分字符的个数，一共有2i(i+2)+1个字符。当2i(i+2)+1&gt;N时，令row=i-1表示向外扩大的
    最大层数
    3.通过3个for嵌套循环输出字符：第一for控制打印的层数；第二个for控制打印空格(row-i)；第三for控制打印字符(2i+1)（注意在每一行的最后面
    不需要打印空格，直接换行就能形成样例的效果）
    4.打印最中间一行
    5.打印最后下半部分
    6.输出剩余个数N-（2i(i+2)+1）

参考代码：

#include&lt;iostream&gt;
using namespace std;
​
int main()
{
    int N,row=0;   //对row初始化否则超时
    char c;
    cin &gt;&gt; N &gt;&gt; c;
    for(int i=1; i&lt;N; i++)
    {
        if((2*i*(i+2)+1)&gt;N)
        {
            row=i-1;
            break;
        }
    }
    for(int i=row; i&gt;=1; i--)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    for(int i=0; i&lt;row; i++)
        cout &lt;&lt; ' ';
    cout &lt;&lt; c &lt;&lt; endl;
    for(int i=1; i&lt;=row; i++)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; N-(2*row*(row+2)+1);
    return 0;
}
​
注意事项：
1.对row要赋初值，否则运行超时

1028
解题思路：
 1.用字符串来存储，还是用铁打的营盘流水兵的思想
    2.maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;都是string类的,string的比较从左至右；对于输入判断&quot;1814/09/06&quot;&lt;=tempbirth&lt;=&quot;2014/09/06&quot;
    参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
   
*/
int main()
{
    int n,cnt=0;
    cin &gt;&gt; n;
    string name,birth,maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;,maxname,minname;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; name &gt;&gt; birth;
        if(&quot;1814/09/06&quot;&lt;=birth &amp;&amp; birth&lt;=&quot;2014/09/06&quot;)
        {
            cnt++;
            if(birth&gt;maxbirth)
            {
                maxbirth=birth;
                minname=name;
            }
            if(birth&lt;minbirth)
            {
                minbirth=birth;
                maxname=name;
            }
        }
    }
    cout &lt;&lt; cnt;
    if(cnt!=0)
        cout &lt;&lt; &quot; &quot; &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; minname;
}
​
知识总结：
对于string字符串的比较是从左至右，按照ascii码比较

1029
    解题思路：
    1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;
    并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的
    2.最后输出ans
    参考代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;
    并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的
    2.最后输出ans
    3.ans表示s1与s2中不相同的字符的字符串
*/
int main()
{
    string s1,s2,ans;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)
            ans+=toupper(s1[i]);
    }
    cout &lt;&lt; ans;
    return 0;
}
​
知识总结：
1.toupper（）将小写字母转化成大写字母

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    /*
        1.toupper函数返回值为整数，在前面加个强制转化即可
    */
    char a='d';
    cout &lt;&lt; (char)toupper(a);
}

2.a.find(b)查找a字符串中是否含有b

/*
        1.a.find(b)如果字符串a中包含字符串b则值不等于string::npos，否则相同。a，b可以是字符串也可以是字符
        2.npos是一个常数，用来表示不存在的位置
        3.a字符串中如果包含b，则返回0；否则返回4294967295也就是npos
*/
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a,b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a.find(b) &lt;&lt; endl;
    cout &lt;&lt; string::npos;
    return 0;
}
​
1030
解题思路：
    1.先对数组进行排序，从小到大
    2.通过两个for+if-else来找到满足题意的个数，外层for控制遍历整个数列，每次把v[i]当成最小的数，里面的for
    就是判断当前v[i]是最小值时，所对应的满足题意的最多的个数。这里j=i+result与if(v[j]&lt;=v[i]*p)用来表示：比如
    上次循环后result=3，此时一开始就判断从当前i开始往后第3个数是否满足条件，满足就修改result的值，不满足result
    值不变
参考代码：

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,temp,result=0;
    long long p;
    cin &gt;&gt; n &gt;&gt; p;
    vector&lt;int&gt;a(n);     //用vector定义有长度的数组时，数组名后用圆括号()中写数组长度
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        for(int j=i+result; j&lt;n; j++)
        {
            if(a[j]&lt;=a[i]*p)
            {
                temp=j-i+1;
                if(temp&gt;result)
                    result=temp;
            }
            else
                break;
        }
    }
    cout &lt;&lt; result;
    return 0;
}
知识总结：
1.int：32位  0--2^32-1   long long： 64位 0--2^64-1
2.用vector定义有长度的数组时，数组名后用圆括号()中写数组长度

1031
    解题思路：
    1.定义一个函数isTrue判断字符串是否满足题意
    2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag
    3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum
    4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与检验数组中的值对应

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.定义一个函数isTrue判断字符串是否满足题意
    2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag
    3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum
    4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与
    检验数组中的值对应
*/
​
​
bool isTrue(string s)
{
    int a[17]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    int b[11]={1,0,10,9,8,7,6,5,4,3,2};
    int sum=0;
    for(int i=0; i&lt;17; i++)
    {
        if(s[i]&lt;'0' || s[i]&gt;'9')
           return false;
        sum+=(s[i]-'0')*a[i];
    }
    int temp=(s[17]=='X')?10:(s[17]-'0');
    return b[sum%11]==temp;           //如果最后一位检验相同，就返回True；否则返回false；也可以用if-else来写
​
}
int main()
{
    int n,flag=0;
    string s;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; s;
        if(!isTrue(s))
        {
            flag=1;
            cout &lt;&lt; s &lt;&lt; endl;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;All passed&quot;;
    return 0;
}
​
1032
解题思路：
1.将成绩放到学校编号对应的下标数组中，数组表示成绩之和
2.将max表示最大成绩的下标，由于题中，学校编号是从1开始，所以max初值为1，最后直接输出max1，和a[max1]。
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.学校编号school，成绩和数组a[]={0},
    2.
*/
int main()
{
    int n,tem,max1=1,school;
    cin &gt;&gt; n;
    int a[n+1]={0};
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; school &gt;&gt; tem;
        a[school]+=tem;
    }
    for(int i=2; i&lt;=n; i++)
    {
        if(a[i]&gt;a[max1])
            max1=i;
    }
    cout &lt;&lt; max1 &lt;&lt; &quot; &quot; &lt;&lt; a[max1];
    return 0;
}
​
注意事项：
1.定义数组a的长度时是n+1并且初值为0，因为题中含义是n个学生，所以学校的编号最大是n，查找最大值时的那个循环要能遍历到n，如果定义数组a的长度为n，那么最后成绩之和最大的是a[n]（未赋初值的数组元素值是任意数），而最大值下标是n。
2.假设max1=1，也就是假设第一个学校的总分最大

1034.
解题思路：
    解题思路：
    1.三个函数：gcd求出最大公约数；func对分数进行化简，main输入a b c d
    2.gcd用辗转相除求最大约数，
	      if(t20)
	        return t1;
	       else
	        gcd(t2,t1%t2);
    3.gcd函数
       1.如果m*n0,分为2种情况：分母为0或分母为0，输出时加上判断分子是否为0
       2.用flag表示异号为1，同号为0
       3.对m,n都取绝对值，并向除
    4.func函数：
        1.解决Inf与分子为0的问题
        2.定义flag，对m，n取整，x分子与分母的商
        3.解决对于分数可能添加(-的问题
        4.不论分子与分母是整除还是不整除，都先要输出x
        5.如果对于整除的情况，根据flag看输不输出),并最后退出此函数
        6.如果对于不是整除的情况，就要加上一个空格，以便让假分数的整数部分与分数分开
        7.输出真分数的问题
            1.先计算假分数去除整数部分的分子
            2.然后调用gcd函数算出此时分母与分子的最大公约数
            3.然后算出最简形式
            4.按照分数的格式输出，注意最后还要根据flag看输出输出）。
    5.main：
      1.输入四个值a b c d
      2.对于加法：通分手动算出分子分母然后将其作为参数代入func函数中求最简形式
      3.对于减法，类似只是相减
      4.对于乘法，类似根据手动的策略
      5.对于除法，类似手动求倒数然后代入
      
  参考代码：

#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
long long a, b, c, d;       //为啥要是long long类型？答：必须范围足够大
/*
​
*/
​
​
//辗转相除求最大约数
long long gcd(long long t1, long long t2) {
   if(t2==0)
    return t1;
  else
    gcd(t2,t1%t2);
}
​
//对分数进行化简
void func(long long m, long long n)
{
 if (m * n == 0)
 {
     printf(&quot;%s&quot;, n==0?&quot;Inf&quot;:&quot;0&quot;);
     return ;
 }
​
 //异号是1，同号0
 bool flag=((m&lt;0 &amp;&amp; n&gt;0) || (m&gt;0 &amp;&amp; n&lt;0));
 m=abs(m); n= abs(n);
 long long x = m/n;
​
 printf(&quot;%s&quot;, flag?&quot;(-&quot;:&quot;&quot;);
​
 if (x!=0)
    printf(&quot;%lld&quot;,x);    //注意这里的格式化输出格式是小写的LLL 不是 11111111
​
 if (m%n==0)
 {
        printf(&quot;%s&quot;,flag?&quot;)&quot;:&quot;&quot;);
    return ;
 }
​
 if (x!=0)
    printf(&quot; &quot;);
 m=m-x*n;
 long long t = gcd(m,n);
 m=m/t; n=n/t;
 printf(&quot;%lld/%lld%s&quot;,m,n,flag?&quot;)&quot;:&quot;&quot;);
}
​
int main()
{
 scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
 func(a,b); printf(&quot; + &quot;); func(c,d); printf(&quot; = &quot;); func(a*d+b*c,b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; - &quot;); func(c,d); printf(&quot; = &quot;); func(a*d-b*c,b*d); printf(&quot;\n&quot;);
 func(a,b); printf(&quot; * &quot;); func(c,d); printf(&quot; = &quot;); func(a*c, b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; / &quot;); func(c,d); printf(&quot; = &quot;); func(a*d, b*c);
 return 0;
}
​
易错点：

    if(m*n==0)
    {
        printf(&quot;%s&quot;,n==0?&quot;Inf&quot;:&quot;0&quot;);   
        return ;            // 易错：如果分子为0，或者分母为0，输出完Inf和0之后就应该退出程序；否则扣分
    }
​
​
    bool flag=((m&lt;0 &amp;&amp; n&gt;0)||(m&gt;0 &amp;&amp; n&lt;0));   //易错：flag设置为bool类型
1035.
解题思路：
    插入排序：
    i是数列b中第一个前一个数大于后一个数的位置
    j相当于从i开始一直到b数列结束a数列与b数列完全匹配
    对于插值排序：前面肯定是排好序的，也就是满足升序的序列，如果碰到前一位大于后一位则说明从此位的
    后一位开始一直到数组结束都是乱序的，所以刚好用j从此位的后一位开始一直到数组结束，判断j是否为n，
    如果是则为插序排列，然后对数组a进行sort排序（从头开始到i的下一位在排一次），表示他的下一次的插入排序，

归并排序：
1.k初值为1，每次给自己乘2，
2.由于b是排序过程中的某一此序列，所以用a数列循环和b数列进行比较，flag是一个标记，初值为1，若在循环中
a[j]!=b[j]则令flag为1（意思是还要进行循环）本来模拟一次就行，但是测试点要求模拟整个过程。
3.理解while的思路：
    1.首先要明确，测试点要求整个的算法是模拟归并排序的整个过程，但输出时是要通过此算法得出下一次归并
    排序的结果。
    2.首先设置flag为1进入循环，将flag默认为0，下来的for用于判断初始数列和b数列是否相同，若相同则为0，
    否则为1
    3.k自乘2，然后for循环+sort(a+i*k,a+(i+1)*2)排序，最后还要有sort(a+n/k*k,a+n);
参考代码：

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int n,i,j;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int j=0; j&lt;n; j++)
        cin &gt;&gt; b[j];
​
    for(i=0; i&lt;n-1 &amp;&amp; b[i]&lt;=b[i+1]; i++)
        ;
    for(j=i+1; j&lt;n &amp;&amp; a[j]==b[j]; j++)
        ;
    if(j==n)
    {
        cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl;
        sort(a,a+i+2);
    }
    else
    {
        cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;
        int k=1,flag=1;
        while(flag)
        {
            flag=0;
            for(int i=0; i&lt;n; i++)
                if(a[i]!=b[i])
                    flag=1;
            k=k*2;
            for(int i=0; i&lt;n/k; i++)
                sort(a+i*k,a+(i+1)*k);
            sort(a+n/k*k,a+n);
        }
    }
​
    for(int i=0; i&lt;n; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; a[i];
    }
    return 0;
}
​
1036
解题思路；无
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
​
*/
int main()
{
    int n;
    char c;
    cin &gt;&gt; n &gt;&gt; c;
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    cout &lt;&lt; endl;
    for(int j=0; j&lt;(n/2+n%2-2); j++)
    {
        cout &lt;&lt; c;
        for(int k=0; k&lt;(n-2); k++)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c &lt;&lt; endl;
    }
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    return 0;
}
​
易错点：

对于50%的四舍五入是：n/2+n%2。比如17而言，结果为9
但是如果只有n/2，结果为8；并非四舍五入的结果

1037
    解题思路1：
    1.scanf输入
    2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。
解题思路2：
    1.通过诸位比较，得出：实际付的钱小于应该付的钱时，要交换顺序，保证后面减的时候，是大的减小的；并且输出
    负号
    2.用实际付得钱mnt-应该付的钱abc,模拟手动减

参考代码1：

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.scanf输入
    2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。
*/
int main()
{
    int a,b,c,a1,b1,c1;
    scanf(&quot;%d.%d.%d&quot;,&amp;a,&amp;b,&amp;c);
    scanf(&quot;%d.%d.%d&quot;,&amp;a1,&amp;b1,&amp;c1);
    int P,A;
    P=c+b*29+a*17*29;
    A=c1+b1*29+a1*17*29;
    int k=A-P;
    if(k&lt;0)
    {
        cout &lt;&lt; '-';
        k=abs(k);
    }
    cout &lt;&lt; k/(17*29) &lt;&lt; '.' &lt;&lt; (k%(17*29))/29 &lt;&lt; '.' &lt;&lt; (k%(17*29))%29;
    return 0;
}
​
参考代码2；

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int a,b,c,m,n,t,x,y,z;
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;m,&amp;n,&amp;t);
    if(a&gt;m || (a==m &amp;&amp; b&gt;n) || (a==m &amp;&amp; b==n &amp;&amp; c&gt;t))
    {
        swap(a,m);
        swap(b,n);
        swap(c,t);
        cout &lt;&lt; &quot;-&quot;;
    }
    z=c&gt;t?29+t-c:t-c;
    n=c&gt;t?n-1:n;
    y=b&gt;n?17+n-b:n-b;
    x=b&gt;n?m-1-a:m-a;
    printf(&quot;%d.%d.%d&quot;,x,y,z);
    return 0;
}
​
注意事项：
1.abc表示应该付款值，mnt表示实际付款值，如果实际付款值小于应该付款值，则交换位置，并输出符号，因为最后都是用大的减去小的也就是用mnt-abc模拟手动减法

1038
解题思路1：
   1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中
    2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出

参考代码1：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中
    2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n];
    
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
        
    int k;
    cin &gt;&gt; k;
    int b[k],c[k]={0};
    
    for(int j=0; j&lt;k; j++)
        cin &gt;&gt; b[j];
    
    for(int s=0; s&lt;k; s++)
        for(int l=0; l&lt;n; l++)
        {
            if(a[l]==b[s])
                c[s]++;
        }
        
    for(int i=0; i&lt;k; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c[i];
    }
    return 0;
}
​
解题思路2：
    1.将成绩作为下标，然后对应的元素值++
    2.最后直接根据输入的值，循环输出

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int n,temp;
    cin &gt;&gt; n;
    vector&lt;int&gt;b(101);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; temp;
        b[temp]++;
    }
    int m;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        scanf(&quot;%d&quot;, &amp;temp);//这里要用scanf否则超时
        if(i!=0)
            printf(&quot; &quot;);
         printf(&quot;%d&quot;, b[temp]);
    }
    return 0;
}
​
注意事项：
对于for循环中有输入+输出，其实在输入时，只有敲回车，才会输出要输出的值，如果用空格将输入分开，则结果直接根据根据循环次数输出对应的值：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    vector&lt;int&gt;b(101);
    int m=4;
    int temp;
     for (int i = 0; i &lt; m; i++)
    {
         scanf(&quot;%d&quot;, &amp;temp);
         if (i != 0)
            printf(&quot; &quot;);
         printf(&quot;0&quot;);
     }
     return 0;
 }
​
在这里插入图片描述
在这里插入图片描述

1039
解题思路1：
    1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠
    2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#
    3.算出s1中不为#的字符个数，算出s2中为#的字符个数，
    4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果
    s2中#的个数不等于s2的字符长度，则输出剩余的字符个数

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠
    2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#
    3.算出s1中不为#的字符个数，算出s2中为#的字符个数，
    4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果
    s2中#的个数不等于s2的字符长度，则输出剩余的字符个数
*/
int main()
{
    string s1,s2;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s2.length(); i++)
    {
        for(int j=0; j&lt;s1.length(); j++)
        {
            if(s2[i]==s1[j])
            {
                s1[j]='#';
                s2[i]='#';
            }
        }
    }
    int num2=0,num1=0;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s1[i]!='#')
            num1++;
    }
​
    for(int i=0; i&lt;s2.length(); i++)
    {
        if(s2[i]=='#')
            num2++;
    }
    if(num2==s2.length())
        cout &lt;&lt; &quot;Yes &quot; &lt;&lt; num1;
    else
        cout &lt;&lt; &quot;No &quot; &lt;&lt; s2.length()-num2;
    return 0;
}
​
解题思路2：
    1.将字符串中的字符转化成ascii码，存储到数组book中
    2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示
    相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++
    3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串

参考代码：

#include &lt;iostream&gt;
using namespace std;
int book[150];   //book默认值全为0
int main() 
{
/*
    解题思路：
    1.将字符串中的字符转化成ascii码，存储到数组book中
    2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示
    相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++
    3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串
*/
​
     string a, b;
     cin &gt;&gt; a &gt;&gt; b;
     for (int i=0; i&lt;a.length(); i++)
        book[a[i]]++;
     int result = 0;
     for (int i=0; i&lt;b.length(); i++) 
     {
         if (book[b[i]] &gt; 0)
            book[b[i]]--;
         else
            result++;
     }
     if(result!=0)
        printf(&quot;No %d&quot;, result);
     else
        printf(&quot;Yes %d&quot;, a.length()-b.length());
     return 0; 
}
1040
解题思路1：
    1.先找第一个p，然后依次找A，最后找T，然后构建起来
    
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int a=1000000007,num=0,o,p;
    string s;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
        {
            o=i;
            for(int j=i+1; j&lt;s.length(); j++)
            {
                if(s[j]=='A')
                {
                    p=j;
                    for(int k=j+1; k&lt;s.length(); k++)
                    {
                        if(s[k]=='T')
                            num++;
                    }
                }
            }
        }
    }
    cout &lt;&lt; num%a;
    return 0;
}
​
解题思路2：
    1.要知道PAT的个数等于对于每一个A，A前P的个数A后T的个数累加起来即为PAT的个数
    2.先循环遍历T的个数
    3.for循环，若遇到P，则countp++，如果遇到A,则直接用countPcoutT累加到result，如果遇到T，则countT--，
    4.最后不要忘记对1000000007求余

参考代码2：

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
/*
    解题思路：
    1.要知道PAT的个数等于对于每一个A，A前P的个数*A后T的个数累加起来即为PAT的个数
    2.先循环遍历T的个数
    3.for循环，若遇到P，则countp++，如果遇到A,则直接用countP*coutT累加到result，如果遇到T，则countT--，
    4.最后不要忘记对1000000007求余
*/
int main()
{
     string s;
     cin &gt;&gt; s;
     int len=s.length(), result=0, countp=0, countt=0;
     for(int i=0; i&lt;len; i++)
     {
         if (s[i]=='T')
         countt++;
     }
     for (int i=0; i&lt;len; i++)
     {
         if (s[i]=='P')
            countp++;
         if (s[i] == 'T')
            countt--;
         if (s[i] == 'A')
            result=(result+(countp * countt))%1000000007;
     }
     cout &lt;&lt; result;
     return 0;
 }
​
1041
解题思路1：
    1.string存储一个二维数组，设置两个字符串变量s1，s2
    2.输入数据，保存在数组中
    3.输入整数，根据整数来对应数组中的值进行输出
    参考代码1：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.string存储一个二维数组，设置两个字符串变量s1，s2
    2.输入数据，保存在数组中
    3.输入整数，根据整数来对应数组中的值进行输出
*/
int main()
{
     string stu[1005][2], s1, s2;  //切记数组中的行标要超过1000
     int n, m, t;
     cin &gt;&gt; n;
     for(int i=0; i&lt;n; i++) 
     {
         cin &gt;&gt; s1 &gt;&gt; t &gt;&gt; s2;
         stu[t][0] = s1;
         stu[t][1] = s2;
     }
     cin &gt;&gt; m;
     for(int i=0; i&lt;m; i++) 
     {
         cin &gt;&gt; t;
         cout &lt;&lt; stu[t][0] &lt;&lt; &quot; &quot; &lt;&lt; stu[t][1] &lt;&lt; endl;
     }
     return 0;
 }
​
解题思路2：
    1.用结构类型来存储，然后循环找对应的输出即可
 参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用结构类型来存储，然后循环找对应的输出即可
*/
struct stu
{
    long long a;
    int b;
    int c;
};
int main()
{
    int n;
    cin &gt;&gt; n;
    stu s[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; s[i].a &gt;&gt; s[i].b &gt;&gt; s[i].c;
    int m,tem;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        cin &gt;&gt; tem;
        for(int i=0; i&lt;n; i++)
        {
            if(s[i].b==tem)
                cout &lt;&lt; s[i].a &lt;&lt; &quot; &quot; &lt;&lt; s[i].c &lt;&lt; endl;
        }
    }
    return 0;
}
1042
解题思路：
    1.通过getline输入一个字符串
    2.定义一个数组a
    3.将字符串中所有字符改成小写
    4.如果是小写字符，就按照字符的ascii码，输入到数组a中
    5.假设a[0]是最大值，通过循环找出，最大值，以及对应的字符

参考代码：

#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    string s;
    int a[26]={0};
    getline(cin,s);
    for(int i=0; i&lt;s.length(); i++)
        s[i]=tolower(s[i]);
    for(int i=0; i&lt;s.length(); i++)
        if(islower(s[i]))
            a[s[i]-'a']++;
    int max=a[0],t=0;
    for(int i=1; i&lt;26; i++)
    {
        if(a[i]&gt;max)
        {
            max=a[i];
            t=i;
        }
    }
    printf(&quot;%c %d&quot;,'a'+t,max);
    return 0;
}
​
知识总结：

tolower ，toupper， isalpha， isalnum， islower，isupper
用法

 

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main()
{
​
    /*tolower将字符改成小写
    string str=&quot;THIS IS A&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=tolower(str[i]);
    cout &lt;&lt; str;*/
​
    /*toupper将字符改成大写
    string str=&quot;this is a&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=toupper(str[i]);
    cout &lt;&lt; str;*/
​
    /*isalpha()判断一个字符是否为子母，如果是字符返回非0，否则返会0
    cout &lt;&lt; isalpha('2');  //返回0
    cout &lt;&lt; isalpha('A');   返回非0
    */
​
    /*isalnum用来判断是否为数字或者子母，
    cout &lt;&lt; isalnum('A'); 输出非0
    cout &lt;&lt; isalnum('2');  输出非0
    cout &lt;&lt; isalnum('.');  输出0
    */
​
    /*islower判断是否为小写字母，是，返回非0；不是，返回0
    cout &lt;&lt; islower('a');
    cout &lt;&lt; islower('A');
    */
​
    /*isupper判断是否为大写字母，是，返回非0，不是返回0
    cout &lt;&lt; isupper('A');
    cout &lt;&lt; isupper('a');
    */
}
​
1043
解题思路1：
    1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......
    2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为
    0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环
    
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......
    2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为
    0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环
*/
int main()
{
    string s;
    int a[6]={0};
    char c;
    int j=0;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
            a[0]++;
        if(s[i]=='A')
            a[1]++;
        if(s[i]=='T')
            a[2]++;
        if(s[i]=='e')
            a[3]++;
        if(s[i]=='s')
            a[4]++;
        if(s[i]=='t')
            a[5]++;
    }
  do
  {
    if(a[0]!=0)
    {
        cout &lt;&lt; 'P';
        a[0]--;
    }
​
    if(a[1]!=0)
    {
        cout &lt;&lt; 'A';
        a[1]--;
    }
    if(a[2]!=0)
    {
       cout &lt;&lt; 'T';
       a[2]--;
    }
    if(a[3]!=0)
    {
        cout &lt;&lt; 'e';
        a[3]--;
    }
    if(a[4]!=0)
    {
        cout &lt;&lt; 's';
        a[4]--;
    }
    if(a[5]!=0)
    {
        cout &lt;&lt; 't';
        a[5]--;
    }
​
  }while(a[0]!=0 || a[1]!=0 || a[2]!=0 || a[3]!=0 || a[4]!=0 || a[5]!=0);
​
    return 0;
}
​
解题思路2：
    1.用cin.get()将字符串中的字符保存到其ASCII码下标的数组中
    2.用while+if进行循环

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     int map[128]={0},c;
     while ((c = cin.get()) != EOF)   //表示没有到文件的结尾，判题的时候输入一个样例，就是到文件的结尾了
        map[c]++;
     while (map['P'] &gt; 0 || map['A'] &gt; 0 || map['T'] &gt; 0 || map['e'] &gt; 0 ||map['s'] &gt; 0 || map['t'] &gt; 0)
     {
         if (map['P']-- &gt;0)     //对于map['P']-- &gt;0是先比较后自减，对于--map['P'] &gt;0 是先自减后比较
            cout &lt;&lt; 'P';
         if (map['A']-- &gt;0)
           cout &lt;&lt; 'A';
         if (map['T']-- &gt;0)
           cout &lt;&lt; 'T';
         if (map['e']-- &gt;0)
           cout &lt;&lt; 'e';
         if (map['s']-- &gt;0)
           cout &lt;&lt; 's';
         if (map['t']-- &gt;0)
           cout &lt;&lt; 't';
     }
     return 0;
 }
​
1044 
解题思路：
    1.还是用字符串数组保存参数
    2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字
    3.对于func1而言：
        1.对于t/13的除数放到b数组中查找
        2.如t/13和t%13均不为0，则输出“ ”
        3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找
    4.对于func2而言：
        1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来
        2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]
        3.对于s1再在b数组中找，返回t1*13+t2;

参考代码：

#include &lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    1.还是用字符串数组保存参数
    2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字
    3.对于func1而言：
        1.对于t/13的除数放到b数组中查找
        2.如t/13和t%13均不为0，则输出“ ”
        3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找
    4.对于func2而言：
        1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来
        2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]
        3.对于s1再在b数组中找，返回t1*13+t2;
*/
string a[13] = {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string b[13] = {&quot;####&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
//将字符串和长度len设置为全局变量，这样方便调用函数时，不用传入过多的参数
string s;       
int len;

void func1(int t)
{
 if (t/13)
    cout &lt;&lt; b[t/13];
 if ((t/13) &amp;&amp; (t%13))
    cout &lt;&lt; &quot; &quot;;
 if (t%13 || t==0)
    cout &lt;&lt; a[t%13];
}

void func2()
{
     int t1=0, t2=0;
     string s1=s.substr(0,3),s2;   //substr复制字符串的函数
     if (len&gt;4)
        s2 = s.substr(4,3);
     for (int j = 1; j &lt;= 12; j++)
     {
         if (s1==a[j] || s2==a[j])    //为啥要填入s1=a[j]? 答：对于13进制以内的数有用，如feb=5;
            t2=j;
         if (s1==b[j])
            t1=j;
     }
     cout &lt;&lt; t1*13+t2;
 }

int main()
{
     int n;
     cin &gt;&gt; n;
     getchar();         //清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符
     for (int i = 0; i &lt; n; i++)
     {
         getline(cin, s);
         len=s.length();
         if (s[0]&gt;='0' &amp;&amp; s[0]&lt;='9')
            func1(stoi(s));
         else
            func2();
         cout &lt;&lt; endl;
     }
     return 0;
 }

注意事项：
1.清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符
2.注意格式，在主函数中每次循环一次输出endl，但在自身的输入时不要加endl

知识总结：
stoi（将数字字符串改为整数）+ s.substr(pos,n)（将字符串中的字符复制到另一个字符串中）

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{/*
    string str=&quot;abcdef&quot;;
    string a=str.substr(0,11);
    cout &lt;&lt; a;

0. 用途：一种构造string的方法

1. 形式：s.substr(pos, n)

2. 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）

3. 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾*/

/*字符串转化整数函数
    string s=&quot;123&quot;;
    cout &lt;&lt; stoi(s);
    */
}

1045
解题思路1：
    解题思路：
    1.设置三个数组：abv分别表示原始数组，sort排列后的数组，主元元素数组
    2.核心思路，找a与b数组中相同的数字，并且该数字大于前的最大值，因为如果a与b的某个数字相同，说明后面的元素
    都比该元素大，故只用说明该数字大于之前的最大值即可
    3.输出数组v
    注意事项：
    1.输出主元元素的个数时，要换行
    2.最后整个数组输出完后，加换行

参考代码：

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int v[1000000];
int main()
{
    int n,max=-1,cnt=0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i] &amp;&amp; b[i]&gt;max)
        {
            v[cnt++]=b[i];
        }
​
        if(b[i]&gt;max)
            max=b[i];
    }
    cout &lt;&lt; cnt &lt;&lt; endl;
    for(int i=0; i&lt;cnt; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
    }
    cout &lt;&lt; endl;
    return 0;
}
​
解题思路2；
    1.主元的判断条件：左边元素都比其小，右边的元素都比其大，或者换句话说，如果左边的某个数比其大或者右边的某个数比其小，则
    不是主元
    2.可以将合适的数组放到数组中，最后排序输出

参考代码：

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
​
*/
int main()
{
    int n,num=0;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }
​
    sort(a,&amp;a[n]);
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
            num++;
    }
    cout &lt;&lt; num &lt;&lt; endl;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
        {
            if(i!=0)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a[i];
        }
    }
    return 0;
}
​
1046
解题思路：
    1.设置四个，jiahan，jiahua，yihan，yihua, jiahe,yihe
    2.逻辑如下

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
​
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int jiahan,jiahua,yihan,yihua,jiahe=0,yihe=0;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d %d&quot;,&amp;jiahan,&amp;jiahua,&amp;yihan,&amp;yihua);
        if(jiahua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            yihe++;
        if(yihua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            jiahe++;
​
​
    }
        cout &lt;&lt; jiahe &lt;&lt; &quot; &quot; &lt;&lt; yihe &lt;&lt; endl;
    return 0;
}
​
1047
解题思路：
    1.必然有使用scanf输入
    2.完全可以将最后成绩保存在队伍编号的数组中

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
​
*/
​
int main()
{
    int n,duiwu,duiyuan,chengji,maxduiwu=0;
    cin &gt;&gt; n;
    int a[1001]={0};
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d-%d %d&quot;,&amp;duiwu,&amp;duiyuan,&amp;chengji);
        a[duiwu]+=chengji;
    }
    for(int i=0; i&lt;1001; i++)
    {
        if(a[i]&gt;a[maxduiwu])
            maxduiwu=i;
    }
    cout &lt;&lt; maxduiwu &lt;&lt; &quot; &quot; &lt;&lt; a[maxduiwu];
    return 0;
}
​
1048
解题思路：
    1.将a，b字符串倒转过来
    2.根据比较字符串长度，给较短位补0
    3.设置str保存0,1..J,Q,K
    4.对于原来的数位而言，从个位开始就是奇数位，下一位就是偶数位，如果倒转过来，第一位虽然是偶数位，但是
    还是执行的是原来奇数位的操作。
    5.每次循环时将计算结果累加到字符串c中，最后倒叙输出

参考代码：

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    string a,b,c;
    string str=&quot;0123456789JQK&quot;;
    cin &gt;&gt; a &gt;&gt; b;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());
​
    if(a.length()&gt;b.length())
        b.append(a.length()-b.length(),'0');
    else
        a.append(b.length()-a.length(),'0');
​
    for(int i=0; i&lt;b.length(); i++)
    {
        if(i%2==0)
            c+=str[(b[i]-'0'+a[i]-'0')%13];
        else
        {
            int tem=b[i]-a[i];
            if(tem&lt;0)
                tem+=10;
            c+=str[tem];       //由于对应的数字位相减，所以最大差值为9，而c是字符串，所以也可以直接用str[tem]来连接
        }
    }
    for(int i=c.length()-1; i&gt;=0; i--)
        cout &lt;&lt; c[i];
    return 0;
}
​
知识总结：
1.a.append(n,c)表示对字符串a的尾部添加n个字符c
2.reverse(a.begin(),a.end()) 对字符串a进行倒转

1049
解题思路：
    1.通过找规律，其实就是每个数字出现i*(n-i+1)次，
    2.规律如下图：

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    double sum=0.0,tem;
    for(int i=1; i&lt;=n; i++)
    {
        cin &gt;&gt; tem;
        sum+=tem*i*(n-i+1);
    }
    printf(&quot;%.2f&quot;,sum);
}
​
在这里插入图片描述

1050.
解题思路：
    1.先求合适的m,n
    2.定义一个vector数组，并对其进行递减排序
    3.用vector定义一个二维数组
    4.用如下图的双循环，对二维数组赋值(设置原始数组a中的变量为t=0,依次将a数组中的值放到合适的二维数组位置，不要忘记t&lt;N)：
        1.外层循环是以口字型顺时针循环，规律是根据行数m，通过找规律得出level=m/2+m%2
        2.对于每一个外层循环来说，又有4个内层循环，分别是左上到右上、右上到右下、右下到左下、左下到左上的顺序⼀层层填充
    5.用双层for循环输出二维数组，对j!=n-1的话，则输出空格保证最后一个数字没有多余的空格   
在这里插入图片描述
餐考代码：

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
​
​
/*
    解题思路:
​
*/
​
int cmp(int a, int b)
{
    return a &gt; b;
}
​
int main()
{
     int N, m, n, t = 0;
     scanf(&quot;%d&quot;, &amp;N);
​
     /*
        题中要求m-n的值是所有可能值中最小的，m&gt;=n; m*n=N。所以对于n取根号下N然后取整就表示想让
        n与m值最接近，此时n的值一定小于等于N开根号也就满足m&gt;=n，递减循环，如果有N整除n，则m=N/n，退出循环
     */
     for (n=sqrt(N); n&gt;=1; n--)
     {
         if (N%n==0)
         {
             m=N/n;
             break;
         }
     }
​
     vector&lt;int&gt; a(N);
     for (int i=0; i&lt;N; i++)
        cin &gt;&gt; a[i];
​
     sort(a.begin(), a.end(), cmp);  //对数组递减排序
​
     /*
     用vector初始化一个元素全为0的数组
     定义了一个vector容器，元素类型为vector&lt;int&gt;，初始化为包含m个vector&lt;int&gt;对象，
     每个对象都是一个新创立的vector&lt;int&gt;对象的拷贝，
     而这个新创立的vector&lt;int&gt;对象被初始化为包含n个0。
     */
     vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n));
​
     
     /*
        层数就是通过找规律得出，m为奇数，外层数是m/2+1；m为偶数，外层数就是m/2 则m=m/2+m%2
     */
     int level=m/2+m%2;
     
     for (int i=0; i&lt;level; i++)
     {
         /*
            第一个循环是从左上到右上，
         */
         for (int j=i; j&lt;n-i &amp;&amp; t&lt;N; j++)
            b[i][j] = a[t++];
            
        /*
            第2个循环是从右上到右下
        */
         for (int j=i+1; j&lt;m-1-i &amp;&amp; t &lt; N; j++)
            b[j][n - 1 - i] = a[t++];
​
        /*
            第3个循环是从右下到左下
        */
         for (int j=n-i-1; j&gt;=i &amp;&amp; t&lt;N; j--)
            b[m-1-i][j] = a[t++];
        /*
            第4个循环是从左下到左上
        */
         for (int j=m-2-i; j&gt;=i+1 &amp;&amp; t&lt;N; j--)
            b[j][i] = a[t++];
     }
     
     for (int i = 0; i &lt; m; i++)
     {
         for (int j=0 ; j&lt;n; j++)
         {
             printf(&quot;%d&quot;, b[i][j]);
             if (j != n - 1)
                printf(&quot; &quot;);
         }
         printf(&quot;\n&quot;);
     }
     return 0;
 }
​
 知识总结：
 1.用vector将数组按照递减排序

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
int cmp(int a, int b)
{
    return a &gt; b;
}
​
int main()
{
    vector&lt;int&gt; a;
    sort(a.begin(),a.end(),cmp);
}
2.用vector设置二维数组
     用vector初始化一个元素全为0的数组
     定义了一个vector容器，元素类型为vector&lt;int&gt;，初始化为包含m个vector&lt;int&gt;对象，
     每个对象都是一个新创立的vector&lt;int&gt;对象的拷贝，
     而这个新创立的vector&lt;int&gt;对象被初始化为包含n个0。

     vector&lt;vector&lt;int&gt; &gt; b(m, vector&lt;int&gt;(n));
1051
解题思路：
    1.通过极坐标的形式进行复数相乘，如下图
    2.对于特殊情况，比如A=-0.0001，如果直接保留2位小数，则为-0.00而非0.00，而这种情况，只针对A&lt;0且A+0.005&gt;0
    3.对于B有三种情况，大于等于0是直接输出；与A类似的一种情况；B小于0并且B小于-0.005
在这里插入图片描述
参考代码：

#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
/*
    解题思路:
​
*/
int main() 
{
     double r1, p1, r2, p2, A, B;
     cin &gt;&gt; r1 &gt;&gt; p1 &gt;&gt; r2 &gt;&gt; p2;
     A = r1 * r2 * cos(p1) * cos(p2) - r1 * r2 * sin(p1) * sin(p2);
     B = r1 * r2 * cos(p1) * sin(p2) + r1 * r2 * sin(p1) * cos(p2);
     if (A + 0.005 &gt; 0 &amp;&amp; A &lt; 0)
        printf(&quot;0.00&quot;);
     else
        printf(&quot;%.2f&quot;, A);
        
     if(B &gt;= 0)
        printf(&quot;+%.2fi&quot;, B);
     else if (B + 0.005 &gt; 0 &amp;&amp; B &lt; 0)
        printf(&quot;+0.00i&quot;);
     else
        printf(&quot;%.2fi&quot;, B);
     return 0; 
 }
1052
解题思路：
    1.将输入样例，转化为字符数组
    2.按照要求输出

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     //
​
     /*
        1.定义一个字符串的二维数组v(有3行)
        2.使用getline接受字符串
        3.设置两个循环变量j，k分别表示[和]的位置
        4.用双层while-if嵌套将表情放到row(row表示一行表情字符串)中，再将row放到v中
     */
     vector&lt;vector&lt;string&gt;&gt; v;
​
     for(int i=0; i&lt;3; i++)
     {
         string s;
         getline(cin,s);
         vector&lt;string&gt; row;    //定义一个字符数组
         int j=0, k=0;
         while(j &lt; s.length())
         {
             if(s[j] == '[')
             {
                 /*
                    k直接在此处自增是因为，如果第一次k走到]这个位置，if判断为真，压入栈，退出循环，其实
                    k已经走到下一个位置也就是下一个[处，如果将k放到if后面自增的话，那么k的值一直不变。
                 */
                 while(k++ &lt; s.length())
                 {
                     if(s[k] == ']')
                     {
                         row.push_back(s.substr(j+1, k-j-1));
                         break;
                     }
                 }
             }
             j++;
         }
         v.push_back(row);
     }
​
     int n;
     cin &gt;&gt; n;
     for(int i = 0; i &lt; n; i++)
     {
         int a, b, c, d, e;
         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;
         /*
            如果这里输入的数字，大于字符数组中字符元素的长度的话，输出Are you kidding me? @\/@，由于每个
            字符串都是从1开始，所以如果输出0，也是选择的序号不存在，就输出Are you kidding me? @\/@
         */
         if(a&gt;v[0].size() || b&gt;v[1].size() || c&gt;v[2].size() || d&gt;v[1].size() || e&gt;v[0].size() || a&lt;1 || b&lt;1 || c&lt;1 || d&lt;1 || e&lt;1)
         {
             cout &lt;&lt; &quot;Are you kidding me? @\\/@&quot; &lt;&lt; endl;
             continue;
         }
         cout &lt;&lt; v[0][a-1] &lt;&lt; &quot;(&quot; &lt;&lt; v[1][b-1] &lt;&lt; v[2][c-1] &lt;&lt; v[1][d-1] &lt;&lt; &quot;)&quot; &lt;&lt; v[0][e-1] &lt;&lt; endl;
     }
     return 0;
 }
​
知识总结：
1.用vector嵌套一个字符串数组

vector&lt;vector&lt;string&gt;&gt; v;
2.用getline接受一个字符串

getline(cin,s);
3.给字符串压栈

s.push_back(a);  //将字符串a压栈到s中
4.截取字符串

s.substr(k,j);   //表示在s字符串中，第k个位置，一共截取j个字符
法are

1053
解题思路：
    1.设置knkz，kz，
    2.利用双层for比较：N，e，D，a 先比较电量是否高于观察期的一半，如果高于，则再判断是否大于指定的天数，计算
    出knkz和kz的个数，最后再求百分比后输出

参考代码：

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    /*
        注意事项：
        1.对“可能控制”，“控制”的判断，先if判断是否存在超过一半的日子用电量低于某给定的阈值e，然后用一个
        ?:进一步判断是否观察期超过某给定阈值 D 天，然后选择是对knkz自增还是kz自增
        2.输出%时，应该输出两个%
    */
    int N,D,a;
    double e,knkz=0.0,kz=0.0;
    double temp=0.00;
    cin &gt;&gt; N &gt;&gt; e &gt;&gt; D;
    for(int i=0; i&lt;N; i++)
    {
        cin &gt;&gt; a;
        int tempcount=0;
        for(int j=0; j&lt;a; j++)
        {
            cin &gt;&gt; temp;
            if(temp&lt;e)
                tempcount++;
        }
        if(tempcount&gt;a/2)
        {
            a&gt;D?kz++:knkz++;
        }
    }
    printf(&quot;%.1f%% %.1f%%&quot;,knkz/N*100,kz/N*100);
    return 0;
}
​
注意事项：
        1.对“可能控制”，“控制”的判断，先if判断是否存在超过一半的日子用电量低于某给定的阈值e，然后用一个
        ?:进一步判断是否观察期超过某给定阈值 D 天，然后选择是对knkz自增还是kz自增
        2.输出%时，应该输出两个%

1054
解题思路:
    1.用字符数组来存放输入的值
    2.不管a是啥，都将a转化为浮点型的数放到临时变量temp中
        1.对于整数，实数而言，直接将字符类型转化为双精度浮点数
        2.对于字母串而言，转化成的双精度浮点数是一个极小的数，比如aaa，转化为7.98855e-305
        3.对于有多个小数点而言，只取到第2个小数点之前
    3.在将temp保留2位小数，放到字符数组中，以a的长度为基准，遍历循环如果，a[i]!=b[i]则flag=1
    4.如果flag=1或者temp&lt;-1000 或者temp&gt;1000，则输出：ERROR: aaa is not a legal number
    5.否则累加temp，并记录个数
    6.如果个数为1，则直接输出sum；如果个数为0，则输出undefined，否则输出：The average of 3 numbers is 1.38

参考代码：

#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    char a[50],b[50];
    double sum=0.0,temp=0.0;
    int n,cnt=0;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%s&quot;,a);
        sscanf(a,&quot;%lf&quot;,&amp;temp);
        sprintf(b,&quot;%.2f&quot;,temp);
​
        int flag=0;
​
        for(int j=0; j&lt;strlen(a); j++)      //对于字符数组而言，用strlen去求其长度
            if(a[j]!=b[j])
                flag=1;
​
        if(flag || temp&lt;-1000 || temp&gt;1000)
        {
            cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; a &lt;&lt;  &quot; is not a legal number&quot; &lt;&lt; endl;
            continue;
        }
​
        else
        {
            sum+=temp;
            cnt++;
        }
    }
    //根据上面cnt的结果，输出对于字符串，而不是对于每个字符串都要输出平均值结果
        if(cnt==1)
            printf(&quot;The average of 1 number is %.2f\n&quot;,sum);  //对于只有一个值时，直接输出sum，并且保留2位小数
        else if(cnt&gt;1)
            printf(&quot;The average of %d numbers is %.2f\n&quot;, cnt, sum / cnt);  //printf不能与endl结合
        else
            cout &lt;&lt; &quot;The average of 0 numbers is Undefined&quot; &lt;&lt; endl;
        return 0;
​
}
​
知识总结：
1.将字符数组a以浮点数的方式保存到temp中

 sscanf(a, &quot;%lf&quot;, &amp;temp);  //将a以浮点型的方式放到temp中
2.将temp变量以保留2位小数的方式输出到字符数组b中

char a[50], b[50];
sprintf(b, &quot;%.2f&quot;,temp);
注意事项：
1.后面的if-else是对于输出平均值的字符串，共3中情况：
	1.只有1个值时，则直接输出sum，保留2位小数
	2.没有值时，则直接输出The average of 0 numbers is Undefined
	3.如果cnt&gt;1则，输出sum/cnt,并保留2位小数即可

1055
解题思路：
    1.用结构数组来存储人名和身高
    2.自定义一个cmp，如果身高不同的话，则按身高降序排列（对于输出是先输出最后一排，所以按照降序排列），身高相同按照名字的升序排列，对结构数组进行排序
    3.设置两个边t，row分别表示：t表示结构数组中，按照n/k分配好的第一个下标，row表示行树，初值分别为0，k
    4.如果row==k，则让m=n-n/k*(k-1)表示最后一行人数，如果row!=k,则m=n/k表示每行的人数
    5.定义一个字符串数组ans，来存放人名。从按照n/k划分好的结构数组中将人名放到ans中，当然先一次性放完左边合适的人名，然后
    再一次性放完右边合适的人名
    6.按照输出要求输出这一排人名
    7.不要忘记row--，t+=m

参考代码：

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
/*
    解题思路：
​
*/
​
//设置一个结构
struct node 
{
     string name;
     int height;
};
​
//设置一个cmp，用:?来表示，如果身高不同的话，则按降序排列，身高相同按照名字的升序排列
int cmp(struct node a, struct node b) 
{
    return a.height != b.height ? a.height &gt; b.height : a.name &lt; b.name; 
}
​
int main() 
{
     int n, k, m;
     cin &gt;&gt; n &gt;&gt; k;
     
     //用vector来定义一个结构数组
     vector&lt;node&gt; stu(n);
     
     for(int i = 0; i &lt; n; i++) 
     {
         cin &gt;&gt; stu[i].name;
         cin &gt;&gt; stu[i].height;
     }
     
     sort(stu.begin(), stu.end(), cmp);
     
     int t = 0, row = k;
     
     while(row) 
     {
         if(row == k)   //对于最后一排而言，肯定要先输出，然后依次是n/k的个数，m表示每排的人数
         {
            m = n-n / k * (k - 1);
         } 
        else 
          {
            m = n / k;
          }
        
        //定义一个字符串数组，表示每排的人名
         vector&lt;string&gt; ans(m);
         
         //t初值是0，又因为结构数组，按照身高降序排列，名字升序排列，所以stu[t].name就表示身高在这排中最大的人名,ans[m/2]=stu[t].name就是把每排中身高最大的人放到中间
         //t在样例中的值分别是0,4,7，t表示结构数组中，按照n/k分配的第一个下标
         ans[m / 2] = stu[t].name;
         
         // 左边⼀列
         /*
            1.j是人名字符串数组ans的变量，i是结构数组stu的变量
            2.j=m/2-1,表示从紧靠中间的左边开始
            3.对于for含义是一次直接将左边合适的人名全部输出，所以变量i是递增2
                1.i=t+1; 表示从按照划分的结构数组中的第2个位置开始，都放在左边
    
         */
         int j = m / 2 - 1;
         for(int i = t + 1; i &lt; t + m; i = i + 2)
            ans[j--] = stu[i].name;
            
         // 右边⼀列
         /*
            1.j=m/2+1; 表示从紧靠中间的右边开始
            2.i从t+2开始，表示从按照划分的结构数组中的第3个位置开始，都放在右边
         */
         j = m / 2 + 1;
         for(int i = t + 2; i &lt; t + m; i = i + 2)
            ans[j++] = stu[i].name;
            
         // 输出当前排
         cout &lt;&lt; ans[0];
         for(int i = 1; i &lt; m; i++)
            cout &lt;&lt; &quot; &quot; &lt;&lt; ans[i];
         cout &lt;&lt; endl;
         t = t + m;
         row--;
     }
     return 0; 
 }
知识总结：
1.自定义cmp，对结构数组进行排序

struct node
{
    string name;
    int tall;
};
​
int cmp(node a,node b)  //是对结构进行排序，所以必须定义两个结构node类型的变量a,b。函数类型还是int。如果身高不同按照降序排列，否则按照名字的升序排列
{
    return a.tall!=b.tall?a.tall&gt;b.tall:a.name&lt;b.name;
}
int main()
{
    int m,n,k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;node&gt; stu(n);
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; stu[i].name &gt;&gt; stu[i].tall;
    sort(stu.begin(),stu.end(),cmp);
    
}
​
1056
解题思路：
1.通过观察，可知sum+=a[i] * 11 * (n-1)

参考代码：

#include&lt;iostream&gt;
using namespace std;
int main(){
    int n,sum=0;
    cin &gt;&gt; n;
    int a[n];
    for(int i=0; i&lt;n; i++){
        cin &gt;&gt; a[i];     
        sum+=a[i]*11*(n-1);           
    }
    cout &lt;&lt; sum;
    return 0;
}
​
1057
解题思路1：
    1.先计算字符串中字母的所代表值的和
    2.对其进行2进制计算，同时计算1,0的个数

参考代码1：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    string s;
    getline(cin,s);
    int sum=0,temp,ycount=0,lcount=0;
    for(int i=0; i&lt;s.size(); i++)
    {
​
        if('a'&lt;=s[i] &amp;&amp; s[i]&lt;='z')
            temp=s[i]-'a'+1;
        else if('A'&lt;=s[i] &amp;&amp; s[i]&lt;='Z')
            temp=s[i]-'A'+1;
        else
            continue;
        sum+=temp;
    }
    while(sum!=0)
    {
        if(sum%2)
            ycount++;
        else
            lcount++;
        sum/=2;
    }
    cout &lt;&lt; lcount &lt;&lt; &quot; &quot; &lt;&lt; ycount;
​
    return 0;
}
​
解题思路2:
    1.用getline输入一个字符串
    2.通过for循环，首先用isalpha判断是否为字母，若是，用toupper将字母改为大写字母，然后累加
    3.统计n为2进制时，0和1的个数

参考代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string s;
    getline(cin,s);
    int n=0;
    for(int i=0; i&lt;s.length(); i++)
        if(isalpha(s[i]))
        {
            s[i]=toupper(s[i]);
            n+=(s[i]-'A'+1);
        }
    int cnt0=0,cnt1=0;
    while(n!=0)
    {
        if(n%2==0)
            cnt0++;
        else
            cnt1++;
        n/=2;
    }
    cout &lt;&lt; cnt0 &lt;&lt; &quot; &quot; &lt;&lt; cnt1;
    return 0;
}

知识总结：
1.
isalpha()判断ch是否为英文字母，若是英文字母返回非0（小写字母为2，大写字母为1）
2.toupper()函数是将小写字母转化为大写字母

1058
1.解题思路：
    1.vector&lt;set&lt;char&gt;&gt; right(m)表示标准答案的二维数组，vector&lt;int&gt; total(m), wrongCnt(m);
    分别表示每道题的满分情况，每道题错误次数
    2.第一个双层for：输入题目的情况
            1.外层for控制m个题的循环
            2.内存for根据输入标准答案选项的个数，输入到二维数组right中
    3.第二个三层for：输入学生的答题情况，以及输出每个学生的成绩
            1.外层for控制n个人
            2.内存for控制每个人答m个题的情况
            3.最内层for根据(后的数字，往set类型的st中insert学生的具体答案
    4.第3个for找出错得最多的题目的错误次数
    5.if-else:
            如果错误次数为0，输出too simple
            否则循环遍历题目，如果本题的错误次数与max一致，则输出i+1表示题号

2.参考代码：

#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
            
    注意事项：
    1.每道题的选项个数就是一个形同虚设的值，直接用temp保存，没有实际用处
    2.特别注意第二个三层for中，scanf(&quot;\n&quot;)的使用
                                 
                                 
    知识总结：
    1.set类型的变量，只能用inset输入
​
            
        
*/
int main()
{
     int n, m, temp, k;
     cin &gt;&gt; n &gt;&gt; m;
     vector&lt;set&lt;char&gt;&gt; right(m);   //用二维数组存放正确选项
     vector&lt;int&gt; total(m), wrongCnt(m);  //用int数组存放满分
​
     //输入题目的信息
     for(int i = 0; i &lt; m; i++)
     {
         cin &gt;&gt; total[i] &gt;&gt; temp &gt;&gt; k;   //total表示满分，temp表示题目个数，k表示是正确选项个数
​
         //输入正确选项
         for(int j = 0; j &lt; k; j++)
         {
             char c;
             cin &gt;&gt; c;
             right[i].insert(c);   //想要往set中插入值，必须使用insert
         }
     }
​
    //输入学生的答题情况
    /*
​
        2.为啥没(的输入?
           仔细看41行中有没(
    */
     for(int i = 0; i &lt; n; i++)
     {
         int score = 0;
         scanf(&quot;\n&quot;);    //为了避免下一次的scanf直接读取\n而结束，保证每次都等待键盘输入……，也可以写成getchar()
         for(int j = 0; j &lt; m; j++)     //这里是输入每一行中答题内容
         {
             if(j != 0)
                scanf(&quot; &quot;);    //用法和scanf(&quot;\n&quot;); 一个意思
             scanf(&quot;(%d&quot;, &amp;k);   //输入每个括号内有多少个答案
             set&lt;char&gt; st;
             char c;
​
             for(int l = 0; l &lt; k; l++)   //将每个括号中的答案放到set中
             {
                 scanf(&quot; %c&quot;, &amp;c);
                 st.insert(c);
             }
​
             scanf(&quot;)&quot;);   //接受一个反括号
​
             if(st == right[j])    //如果括号中的答案和题目信息中的答案匹配，则该题为满分
             {
                score += total[j];
             }
            else
             {
                wrongCnt[j]++;   //如果答案不对，则记录该题错误的个数  记录每道题的错误个数
             }
         }
         printf(&quot;%d\n&quot;, score);
     }
​
​
     int maxWrongCnt = 0;       //设置一个最大变量
     
     for(int i = 0; i &lt; m; i++)        //找出错得最多的题目的错误次数
     {
         if(wrongCnt[i] &gt; maxWrongCnt)
         {
            maxWrongCnt = wrongCnt[i];
         }
     }
​
     if(maxWrongCnt == 0            //如果错得最多的题目的错误次数为0，输出Too simple
        printf(&quot;Too simple&quot;); 
     else                               //首先输出错得最多的题目的错误次数，如果本题的错误次数和maxWrongCnt一致，则输出i+1
     {
         printf(&quot;%d&quot;, maxWrongCnt);
         
         for(int i = 0; i &lt; m; i++)
         {
             if(wrongCnt[i] == maxWrongCnt)
             {
                printf(&quot; %d&quot;, i + 1);
             }
         }
     }
     return 0;
 }
​
3.知识总结
1.关于scanf(&quot;\n&quot;)与scanf(&quot; &quot;)的讨论

#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
{
     int n,k=3;
     cin &gt;&gt; n;
     /*
         此代码的含义是：
         1.输入一个n，然后循环输入(k1 (k2 (k3 .... 并输出k1 k2 k3
     */
     for(int i = 0; i &lt; n; i++)
     {
        scanf(&quot;\n&quot;);    //吃掉上面那个输入n时的回车，加入此行代码，只针对于输入带有符号的输入
        scanf(&quot;(%d&quot;, &amp;k);  
        cout &lt;&lt; k &lt;&lt; endl;
​
     }
     return 0;
}
​
运行结果：

在这里插入图片描述
2.关于set类型的用法：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
int main()
{
    set&lt;int&gt; s;
    set&lt;int&gt;::iterator its;   //设置一个迭代器
    int temp,n;
    cin &gt;&gt; n;
    
     
    for(int i=0; i&lt;n; i++)   //只能以insert的方式插入数字
    {
        cin &gt;&gt; temp;
        s.insert(temp);
    }
    
    
    for(its=s.begin(); its!=s.end(); its++)   //使用迭代的方式读取数字
        cout &lt;&lt; *its;
​
​
    return 0;
}
​
注意事项：
    1.每道题的选项个数就是一个形同虚设的值，直接用temp保存，没有实际用处
    2.特别注意第二个三层for中，scanf(&quot;\n&quot;)的使用
    

3.如果不加循环中scanf(&quot;\n&quot;)运行结果：
在这里插入图片描述

原因是：
在输入完n后，会敲一个回车，这个回车\n进入缓冲区，而scanf遇到（空格，制表符，回车）会自动结束，所以不理下面的scanf(&quot;(%d&quot;,&amp;k)，空白区中一直有\n，所以每次循环scanf一遇到\n就结束，则一直输出3。若加上scanf(&quot;\n&quot;)，则回车时将\n吃掉，所以重新正常输入，然后输出，在进入下一次循环时，scanf(&quot;\n&quot;)还是会吃掉上一次输入完后的\n

在这里插入图片描述

如果这样写，当max为0时，则输出完Too simple 后还要输出00000
所以一定要将for写入else中

1059
解题思路：
    1.设置一个数组ran，以学号为数组下标，以排名为数组元素
    2.先输出学号，用printf，用%04d，占4位输出，不足为数左端补0
    3.如果ran[id]0表示id根不不在排名里，输出Are you kidding?
    4.设置set类型的集合ss，ss保存的是id号，先在ss中寻找id是否存在，是，就输出checked 不是，就把数字插进去
    5.如果ran[id]1,输出Mystery Award
    6.然后排名是素数，输出Minion
    7.其余输出Chocolate

参考代码：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
​
bool sushu(int a)
{
    if(a&lt;=1)
        return false;
    for(int i=2; i&lt;a; i++)
        if(a%i==0)
            return 0;
    return 1;
}
​
int main()
{
    int n;
    cin &gt;&gt; n;
    int ran[10000],id;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; id;
        ran[id]=i+1;
    }
​
    int m;
    cin &gt;&gt; m;
    set&lt;int&gt; ss;
    for(int i=0; i&lt;m; i++)
    {
        cin &gt;&gt; id;
        printf(&quot;%04d: &quot;,id);
        if(ran[id]==0)
        {
            cout &lt;&lt; &quot;Are you kidding?&quot; &lt;&lt; endl;
            continue;
        }
​
        if(ss.find(id)==ss.end())
            ss.insert(id);
        else
        {
            cout &lt;&lt; &quot;Checked&quot; &lt;&lt; endl;
            continue;
        }
​
​
        if(ran[id]==1)
            cout &lt;&lt; &quot;Mystery Award&quot; &lt;&lt; endl;
        else if(sushu(ran[id]))
            cout &lt;&lt; &quot;Minion&quot; &lt;&lt; endl;
        else
            cout &lt;&lt; &quot;Chocolate&quot; &lt;&lt; endl;
​
    }
    return 0;
}
​
知识总结：
    1.set中的find
   if( ss.find(id) == ss.end() )  //表示ss中没有找到id这个值

1060
解题思路：
    1.一般的思路肯定是，从骑行的最大公里开始，看是否有E天超过E公里，从大到小开始寻找
    2.此题的思路是以E天为准，从1开始，将每天的骑行距离按照降序排列，从下标为1开始
    3.a[p]&gt;p：当p=1时，表示肯定有1天超过1公里；当p=2时，表示肯定有2天超过2公里；当p=3时，表示肯定有3天
    超过3公里....一直循环到a[p]&lt;=p此时就表示，当天的距离没有超过p，则E就是上一个值，也就是为啥ans表示E从0
    开始，p从1开始，结果E就是ans

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
​
bool cmp(int a,int b)
{
    return a&gt;b;
}
​
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n+1];
    for(int i=1; i&lt;=n; i++)
        cin &gt;&gt; a[i];
    sort(a+1,a+n+1,cmp);
​
    int ans=0,p=1;
    while(ans&lt;=n &amp;&amp; a[p]&gt;p)
    {
        ans++;
        p++;
    }
    cout &lt;&lt; ans;
    return 0;
}
​
1061
解题思路：
    1.设置3个数组manfen，biaoda，xueda
    2.先输入进去manfen，biaoda
    3.双层for循环，输入学生答案，与biaoda对比，如果一样则sum累加manfen，循环完后输出

参考代码：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    int manfen[m],biaoda[m],xueda[m];
    for(int i=0; i&lt;m; i++)
        cin &gt;&gt; manfen[i];
    for(int i=0; i&lt;m; i++)
        cin &gt;&gt; biaoda[i];
​
    for(int i=0; i&lt;n; i++)
    {
        int sum=0;
        for(int j=0; j&lt;m; j++)
        {
            int temp;
            cin &gt;&gt; temp;
            if(temp==biaoda[j])
                sum+=manfen[j];
        }
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
​
1062
解题思路1：
    1.先找M1，M2的最小公倍数S1，然后在找S1与K的最小公倍数K1
    2.通分，将N1变为L1，将N2变为L2
    3.找L1~L2之间找K1/K的倍数
    4.写一个将分数化为最简分数的函数huajian，对于上面所有找的值进行化简，判断其分母是否为K，是则输出；不是
    则不输出

参考代码：

#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：

*/
int zuiyin(int a,int b)
{

    int max=-1;

    if(a&gt;b &amp;&amp; a%b==0)
        return b;
    else if(a&lt;b &amp;&amp; b%a==0)
        return a;
    int temp=a&gt;b?b:a;
    for(int i=1; i&lt;temp; i++)
    {
        if(a%i==0 &amp;&amp; b%i==0)
            if(i&gt;max)
                max=i;
    }
    return max;
}
int main()
{
    int N1,N2,M1,M2,L1,L2,K;
    scanf(&quot;%d/%d %d/%d %d&quot;,&amp;N1,&amp;M1,&amp;N2,&amp;M2,&amp;K);
    int S1=M1*M2/zuiyin(M1,M2);
    int K1=K*S1/zuiyin(S1,K);
    L1=K1/M1*N1;
    L2=K1/M2*N2;
    int flag=0;
    for(int i=L1+1; i&lt;L2; i++)
        if(i%(K1/K)==0)
            if(zuiyin(i,K1)==K1/K)
            {
                if(flag!=0)
                    cout &lt;&lt; &quot; &quot;;
                printf(&quot;%d/%d&quot;,i/(K1/K),K);
                flag++;
            }
    return 0;
}

解题思路2；
    1.不用找M1，M2，K的最大公约数。
    2.用分母相乘的方法，先找到 num/K 比N1/M1大的最小num
    3.用while循环，也是用分母相乘的方法，找到所有num/k 小于 N2/M2，同时判断num与k之间的最大公约数是否为1
    是就输出
    4.详见如下图
在这里插入图片描述

参考代码：

#include&lt;iostream&gt;
using namespace std;
​
int gcd(int a, int b)
{
    return b==0?a:gcd(b,a%b);
}
​
​
int main()
{
    int n1,m1,n2,m2,k;
    scanf(&quot;%d/%d %d/%d %d&quot;,&amp;n1,&amp;m1,&amp;n2,&amp;m2,&amp;k);
​
    if(n1*m2&gt;m1*n2)
    {
        swap(n1,n2);
        swap(m1,m2);
    }
​
    int num=1;
    while(n1*k&gt;=m1*num)
        num++;
    int flag=0;
    while(num*m2&lt;k*n2)
    {
        if(gcd(num,k)==1)
        {
            if(flag!=0)
                cout &lt;&lt; &quot; &quot;;
            printf(&quot;%d/%d&quot;,num,k);
            flag++;
        }
        num++;
    }
    return 0;
}
​
知识总结：
1.求最大公约数---辗转相除法

int gcd(int a, int b)
{
    return b==0?a:gcd(b,a%b);
}
​
1063
解题思路：
过于简单，没有思路

参考代码：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
​
int main()
{
    double max=-1.0,temp,temp1,temp2;
    int n;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; temp1 &gt;&gt; temp2;
        temp=sqrt(temp1*temp1+temp2*temp2);
        if(temp&gt;max)
            max=temp;
    }
    printf(&quot;%.2f&quot;,max);
    return 0;
}
​
1064
解题思路：
    1.对于每一个输入的数字，求其每个位上的数字和
    2.将其insert入set类型a中

参考代码：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
/*
    解题思路：
​
    
​
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int flag=0;
    set&lt;int&gt;a;
    set&lt;int&gt;::iterator ita;
    for(int i=0; i&lt;n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        int num=0;
        while(temp!=0)
        {
            num+=temp%10;
            temp/=10;
        }
        a.insert(num);
    }
    cout &lt;&lt; a.size() &lt;&lt; endl;
    for(ita=a.begin(); ita!=a.end(); ita++)
    {
        if(flag!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; *ita;
        flag++;
    }
    return 0;
}
​
  知识总结：
    1.用set类型来存储值，一方面数字是按升序排列，另一方面在存储时是没有重复的插入

1065
解题思路：
    1.设置一个couple数组来存放夫妻ID，下标为a中存放b；下标为b中存放a
    2.设置guest来存放参加晚会的ID，如果参见晚会的人有对象，则在isExist数组中存放参见晚会的人的对象值为1
    表示参加晚会的人的对象的对象来参加晚会了，如下图所示
    3.要删除isExist中值为1的元素，保存值为0的元素
    4.最后按要求输出

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
     int n, a, b, m;
     cin &gt;&gt; n;
     vector&lt;int&gt; couple(100000, -1);   //设置一个长度为100000，初值为-1的数组couple , 设置数组长度为100000是因为数组下标是00000~99999

     for (int i = 0; i &lt; n; i++)   //将配对的数字，一个做下标，一个做元素值
     {
         scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
         couple[a] = b;
         couple[b] = a;
     }

     cin &gt;&gt; m;
     vector&lt;int&gt; guest(m), isExist(100000);   //isExist也是数组长度为100000，因为下标也是从00000~99999

     for (int i = 0; i &lt; m; i++)  //将所有输入的客人的配偶做下标，值设为1
     {
         cin &gt;&gt; guest[i];
         if (couple[guest[i]] != -1)
            isExist[couple[guest[i]]] = 1;
     }

     set&lt;int&gt; s;
     for (int i = 0; i &lt; m; i++)    //主要删除此人及配偶
     {
         if (!isExist[guest[i]])
            s.insert(guest[i]);
     }
     printf(&quot;%d\n&quot;, s.size());
     for (auto it = s.begin(); it != s.end(); it++)
     {
         if (it != s.begin())
            printf(&quot; &quot;);
         printf(&quot;%05d&quot;, *it);
     }
     return 0;
}

解题思路2：
    1.设置一个2列，n行的一个二维数组来存储夫妻对数
    2.b来存放参加晚会的人
    3.xunzhao函数表示如果此人有对象则返回其对象的下标，如果此人没对象则返回100000
    4.循环b结合xunzhao函数，如果参加晚会的人有对象，继续在b中查找其对象是否存在，若存在则删除此人及其对象
    5.最后按要求输出
    6.可惜超时

参考代码：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
/*
    解题思路：
​
*/
int a[50001][2];
int n;
int xunzhao(int temp)  //对a而言，如果在二维数组中没有就返回0，如果有就返回其对应的值
{
    for(int i=0; i&lt;n; i++)
    {
        for(int j=0; j&lt;2; j++)
        if(a[i][j]==temp)
            if(j==0)
                return a[i][1];
            else
                return a[i][0];
    }
    return 100000;
}
int main()
{
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
        for(int j=0; j&lt;2; j++)
            cin &gt;&gt; a[i][j];
    set&lt;int&gt; b;
    set&lt;int&gt;::iterator itb;
    int m,flag=0;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        b.insert(temp);
    }
    //消除在此set中有配偶的
    for(itb=b.begin(); itb!=b.end(); itb++)
    {
        if(xunzhao(*itb)!=100000)
            if(b.find(xunzhao(*itb))!=b.end())
            {
                b.erase(xunzhao(*itb));
                b.erase(*itb);
            }
    }
    cout &lt;&lt; b.size() &lt;&lt; endl;
    for(itb=b.begin(); itb!=b.end(); itb++)
    {
        if(flag!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; *itb;
        flag++;
    }
    return 0;
}
​
1066
解题思路：
过于简单没有解题思路

参考代码1：

#include&lt;iostream&gt;
using namespace std;
int main()
{
    int m,n,a,b,k;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k;
    int l[n];
    for(int i=0; i&lt;m; i++)
    {
        for(int j=0; j&lt;n; j++)
            cin &gt;&gt; l[j];
        for(int j=0; j&lt;n; j++)
        {
            if(j!=0)
                cout &lt;&lt; &quot; &quot;;
            if(l[j]&lt;a || l[j]&gt;b)
                printf(&quot;%03d&quot;,l[j]);
            else
                printf(&quot;%03d&quot;,k);
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
​
参考代码2：

#include&lt;iostream&gt;
using namespace std;
int main()
{
    int m,n,a,b,k,temp;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; k;
    for(int i=0; i&lt;m; i++)
    {
        for(int j=0; j&lt;n; j++)
        {
            scanf(&quot;%d&quot;,&amp;temp);              //不用设置数组来存放，因为在循环中如果有一个输入，一个输出，如果一次性全部输入，那么对应的输出也是一次性全部输出，并非输入一个就显示一个。这里如果用cin输入就会超时
            if(temp&gt;=a &amp;&amp; temp&lt;=b)
                temp=k;
            if(j!=0)
                cout &lt;&lt; &quot; &quot;;
            printf(&quot;%03d&quot;,temp);
        }
        cout &lt;&lt; endl;
    }
    return 0;
}

1067
解题思路1：
    1.while设置为死循环
    2.还是输入一个，输出一个，不是等到全部输入完后在输出
    3.如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序；
    如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码；
    当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序
    就按照这个策略去构建代码，不要自己胡推

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     string password, temp;
     int n, cnt = 0;
     cin &gt;&gt; password &gt;&gt; n;
     getchar();
     while(1)
     {
         getline(cin, temp);
         if (temp == &quot;#&quot;)
          break;
         cnt++;
         if (cnt &lt;= n &amp;&amp; temp == password)
         {
             cout &lt;&lt; &quot;Welcome in&quot;;
             break;
         }
         else if (cnt &lt;= n &amp;&amp; temp != password)
         {
             cout &lt;&lt; &quot;Wrong password: &quot; &lt;&lt; temp &lt;&lt; endl;
             if (cnt == n)
             {
                 cout &lt;&lt; &quot;Account locked&quot;;
                 break;
             }
         }
     }
     return 0;
 }
​
注意事项：
1.在上面代码中不要忘记在第一次输入完后再输入getchar()接受缓冲区中的回车，以方便后面在循环中继续输入
2.此题的思路并非等所有输入完后在输出

解题思路2：
    1.如果是正确的密码且尝试次数不超过 N，则在一行中输出 Welcome in，并结束程序
    2.如果是错误的，则在一行中按格式输出 Wrong password: 用户输入的错误密码
    3.当错误尝试达到 N 次时，再输出一行 Account locked，并结束程序。
    4.用while开始输入，统计当前输入的个数，

参考代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
/*
    解题思路：
​
​
*/
int main()
{
    string mima,temp=&quot;ds&quot;;
    int n,count=1;
    cin &gt;&gt; mima &gt;&gt; n;
    scanf(&quot;\n&quot;);
    vector&lt;string&gt; a;
    while(temp.compare(&quot;#&quot;)!=0)
    {
        getline(cin,temp);
        a.push_back(temp);
    }
    for(int i=0; i&lt;a.size(); i++)
    {
        if(a[i].compare(mima)!=0 &amp;&amp; count&lt;=n)
        {
             printf(&quot;Wrong password: &quot;);
             cout &lt;&lt; a[i] &lt;&lt; endl;
        }
​
        if(a[i].compare(mima)!=0 &amp;&amp; count&gt;n)
        {
             cout &lt;&lt; &quot;Account locked&quot;;
             return 0;
        }
​
        if(a[i].compare(mima)==0 &amp;&amp; count&gt;n)
        {
             cout &lt;&lt; &quot;Account locked&quot;;
             return 0;
        }
​
        if(a[i].compare(mima)==0)
        {
            cout &lt;&lt; &quot;Welcome in&quot;;
            return 0;
        }
        count++;
    }
    return 0;
}
​
1068
解题思路1：
    1.第一行和第1列肯定都不要想,最后一行，一列的值也不要想
    2.还是用二维数组去存储
    3.用该值去见上下的，左右的，主队角线上的，副对角线上的差值必须大于tol才行

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    int m,n,tol,cnt=0,s,b;
    cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol;
    int a[n][m];
    for(int i=0; i&lt;n; i++)
    {
        for(int j=0; j&lt;m; j++)
            cin &gt;&gt; a[i][j];
    }
    for(int i=1; i&lt;n-1; i++)
    {
        for(int j=1; j&lt;m-1; j++)
        {
            if(a[i][j]-a[i][j-1]&gt;tol &amp;&amp; a[i][j]-a[i][j+1]&gt;tol &amp;&amp; a[i][j]-a[i-1][j]&gt;tol &amp;&amp; a[i][j]-a[i+1][j]&gt;tol &amp;&amp; a[i][j]-a[i-1][j-1]&gt;tol &amp;&amp; a[i][j]-a[i+1][j+1]&gt;tol &amp;&amp; a[i][j]-a[i-1][j+1]&gt;tol &amp;&amp; a[i][j]-a[i+1][j-1]&gt;tol)
            {
                s=i;
                b=j;
                cnt++;
            }
        }
    }
    if(cnt==1)
        printf(&quot;(%d, %d): %d&quot;,b+1,s+1,a[s][b]);
    else if(cnt&gt;1)
        cout &lt;&lt; &quot;Not Unique&quot;;
    else if(cnt==0)
        cout &lt;&lt; &quot;Not Exist&quot;;

    return 0;
}

解题思路2：
    1.设置一个2维数组v，dir表示该点周围的8个点的位置（按照顺时针的顺序）
    2.判断该点是否符合要求的函数judge
        1.循环是8次
        2.i，j分别表示行和列
        3.tx,ty分别表示i,j周围的点的坐标
        4.tx取值范围是0--n-1，ty取值范围是0--m-1，vi-vtx&lt;=tol或者vi-vtx&gt;=-tol，返回false
    3.将2维数组设为n行m列的数组
    4.按照行-列的顺序依次输入，并且mappi++，表示该数字必须只有1个
    5.用双层for循环统计符合要求的数字的个数cnt
    6.最后根据cnt的值按要求输出

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
/*
    解题思路：

*/
int m, n, tol;
vector&lt;vector&lt;int&gt;&gt; v;
int dir[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1},{0, -1}};

bool judge(int i, int j)
{
     for (int k = 0; k &lt; 8; k++)
     {
         int tx = i + dir[k][0];    //行,下面代码中i是从0~n-1
         int ty = j + dir[k][1];   //列,下面代码中j是从0~m-1
         //tx,ty分别表示周围8个点的坐标，它的意思是直接判断这些坐标所代表的值是否符合要求，自动排除了，所有第1行(列),最后1行(列)的点
         if (tx &gt;= 0 &amp;&amp; tx &lt; n &amp;&amp; ty &gt;= 0 &amp;&amp; ty &lt; m &amp;&amp; v[i][j] - v[tx][ty] &gt;= 0 - tol &amp;&amp; v[i][j] - v[tx][ty] &lt;= tol)
            return false;
     }
     return true;
 }

int main()
{
     int cnt = 0, x = 0, y = 0;
     cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol;              //m是列，n是行
     v.resize(n, vector&lt;int&gt;(m));          //resize()，设置大小（size）; 设置一个n行，每一行放一个长度为m的数组
     map&lt;int, int&gt; mapp;
     
     for (int i = 0; i &lt; n; i++)
     {
         for (int j = 0; j &lt; m; j++)
         {
             cin &gt;&gt; v[i][j];
             mapp[v[i][j]]++;   //这个mapp表示比如在输入样例1中 0有8个，65280有23个。。。
         }
     }
     
     
     for (int i = 0; i &lt; n; i++)
     {
         for (int j = 0; j &lt; m; j++)
         {
             if (mapp[v[i][j]] == 1 &amp;&amp; judge(i, j) == true)
             {
                 cnt++;
                 x = i + 1;
                 y = j + 1;
             }
         }
     }
     

 }

注意事项:
    1.其实并不是所有第1行(列),最后1行(列)的点不考虑，这些点只与剩下的3或者5个点比较
    2.对于输入样例1，其实16711479和16711680都合适，为啥结果只有16711680，因为16711479满足条件的有2个

1069
解题思路：
    1.先判断输入的字符串在之前是否存在，如果是就s=s+1（s表示要输出的位置）
    2.当i==s时，并且这个位置的字符串之前没有
        1.先mapp[str]设为1
        2.输出
        3.改变合适的位置s
        4.设置一个flag初值为0，如果有中奖的则把flag改为1
    3.当循环结束时，根据flag的值看是否输出Keep going........................

参考代码；

#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     int m, n, s;
     cin &gt;&gt; m &gt;&gt; n &gt;&gt; s;
     string str;
     map&lt;string, int&gt; mapp;
     bool flag = false;
     for (int i = 1; i &lt;= m; i++)
     {
         cin &gt;&gt; str;
         if (mapp[str] == 1)
            s+=1;
         if (i == s &amp;&amp; mapp[str] == 0)  //按照规定的间隔输出，还要保证之前没有得过奖
         {
             mapp[str] = 1;
             cout &lt;&lt; str &lt;&lt; endl;
             flag = true;
             s+=n;
         }
     }
     if (flag == false)
        cout &lt;&lt; &quot;Keep going...&quot;;
     return 0;
 }
​
1070
解题思路：
    1.将这个数字排序
    2.从最小的两个开始就一路计算

参考代码：

/*
    解题思路：
​
*/
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    sort(a,&amp;a[n]);             //默认为从小到大
    double sum=(double)(a[0]+a[1])/2;
    for(int i=2; i&lt;n; i++)
    {
        sum=(sum+a[i])/2;
    }
    cout &lt;&lt; (int)sum;
}
​
1072
解题思路：
    1.根据输入的值，优先判断如果total=0则输出Game Over.并且退出循环，如果total&lt;t则输出Not enough tokens.  Total = x.；
    2.根据b的值和实际的n1和n2的大小来计算total的值

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int T,k,n1,b,n2,total,t;
    cin &gt;&gt; T &gt;&gt; k;
    total=T;
    for(int i=0; i&lt;k; i++)
    {
        cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2;
        if(total==0)
        {
            cout &lt;&lt; &quot;Game Over.&quot;;
            break;
        }
        else if(total &lt; t)
            cout &lt;&lt; &quot;Not enough tokens.  &quot; &lt;&lt; &quot;Total = &quot; &lt;&lt; total &lt;&lt; &quot;.&quot; &lt;&lt; endl;
        else if((b==0 &amp;&amp; n1&gt;n2) || (b==1 &amp;&amp; n1&lt;n2))
        {
            total+=t;
            cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;!&quot; &lt;&lt; &quot;  &quot; &lt;&lt; &quot;Total = &quot; &lt;&lt; total &lt;&lt; &quot;.&quot;  &lt;&lt; endl;
        }
        else if((b==0 &amp;&amp; n1&lt;n2) || (b==1 &amp;&amp; n1&gt;n2))
        {
            total-=t;
            cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;.&quot; &lt;&lt; &quot;  &quot; &lt;&lt; &quot;Total = &quot; &lt;&lt; total &lt;&lt; &quot;.&quot;  &lt;&lt; endl;
        }
    }
    return 0;
}
​
1072
解题思路1；
    1.用map来存储，名字作为关键字，后面跟着一个数组
    2.输出一个值，就在set中找，找到就按格式输出，并统计人数和物品数

参考代码：

#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int n,m,count=0,count1=0;
    cin &gt;&gt; n &gt;&gt; m;
    set&lt;int&gt; s;
    map&lt;string,vector&lt;int&gt;&gt; a;
    for(int i=0; i&lt;m; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        s.insert(temp);
    }
    for(int i=0; i&lt;n; i++)
    {
        string t;
        int p;
        cin &gt;&gt; t &gt;&gt; p;
        int flag=1,flag1=1;
        for(int j=0; j&lt;p; j++)
        {
            int o;
            cin &gt;&gt; o;
            if(s.find(o)!=s.end())
            {
                if(flag==1)
                { 
                    cout &lt;&lt; t &lt;&lt; &quot;: &quot;;
                    count1++;
                }
​
                if(flag1==0)
                    cout &lt;&lt; &quot; &quot;;
                printf(&quot;%04d&quot;, o);
                flag1=0;
                flag=0;
                count++;
            }
        }
        if(flag==0)
            cout &lt;&lt; endl;
    }
    cout &lt;&lt; count1 &lt;&lt; &quot; &quot; &lt;&lt; count;
}
​
解题思路2：
    1.设置一个bool类型数组，以违禁品的编号为下标，数组元素为true
    2.根据学生的物品对应于bool类型数组，按格式输出

参考代码：

#include&lt;iostream&gt;
using namespace std;
bool kk[10000];
int main()
{
    int n,m,temp,a=0,b=0;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        cin &gt;&gt; temp;
        kk[temp]=true;
    }
​
    for(int i=0; i&lt;n; i++)
    {
        string name;
        int k,flag=1;
        cin &gt;&gt; name &gt;&gt; k;
        for(int j=0; j&lt;k; j++)
        {
            cin &gt;&gt; temp;
            if(kk[temp])
            {
                if(flag==1)
                    cout &lt;&lt; name &lt;&lt; &quot;:&quot;;
                printf(&quot; %04d&quot;,temp);
                a++;
                flag=0;
            }
        }
        if(flag==0)
        {
           cout &lt;&lt; endl;
           b++;
        }
    }
    cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; a;
}
​
1073
知识总结：

1073
1.解题思路：
    一.第一个双层for循环
        1.对于每道题的满分情况放到数组fullscore中，对于每道题选项个数放到optnum中，对于每道题正确选项个数放到
        truenum中
        2.根据truenum循环将每个学生每道题的按照hash的方式得到的分数放到trueopt数组中
    二.第二个多层for循环：根据学生的答题情况，得出对应的分数，并输出；同时记录错的多的选项
    三.找出cnt数组中的最大值maxcnt，表示错题数最大值
    四.如果maxcnt为0输出too simple，否则双层for循环，找到与错题最大值相符的题目，同时输出错选的选项

2.参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
/*
    解题思路：
​
​
*/
int main()
{
     int n, m, optnum, truenum, temp, maxcnt = 0;
     int hash[] = {1, 2, 4, 8, 16}, opt[1010][110] = {0};   //opt数组表示每行是学生答题的分数情况
     char c;
     cin &gt;&gt; n &gt;&gt; m;
     vector&lt;int&gt; fullscore(m), trueopt(m);    //fullscore表示每道题满分的情况
     vector&lt;vector&lt;int&gt;&gt; cnt(m, vector&lt;int&gt;(5));  //表示一个二维数组，m行，每行表示一个长度为5的数组
                //cnt表示错误次数
​
      //输入前面一部分
     for (int i = 0; i &lt; m; i++)
     {
         cin &gt;&gt; fullscore[i] &gt;&gt; optnum &gt;&gt; truenum;  //fullscore[i]表示满分数组
         for (int j = 0; j &lt; truenum; j++)
         {
             scanf(&quot; %c&quot;, &amp;c);
             trueopt[i] += hash[c-'a'];   //trueopt[]数组统计一道题得满分时的分数
         }
     }
​
     for (int i = 0; i &lt; n; i++)
     {
         double grade = 0;
         for (int j = 0; j &lt; m; j++)
         {
             getchar();   //接受学生每道题答案之间的那个空格
             scanf(&quot;(%d&quot;, &amp;temp);
​
             for (int k = 0; k &lt; temp; k++)
             {
                 scanf(&quot; %c)&quot;, &amp;c);            //先把学生的答案输入进去
                 opt[i][j] += hash[c-'a'];   //计算opt对应的值
             }
​
             /*
                1.通过异或运算找出全对和 选错或者漏选
                2.用过按位或找出漏选
                3.记录错误的个数（通过按位与）
             */
             int el = opt[i][j] ^ trueopt[j];    //^ 不同是非0，相同为0  el就是判断答案是否相同
​
             if (el)        //表示el不为0，就数值不同，一种半对半错，一种是全错
             {
                 if ((opt[i][j] | trueopt[j]) == trueopt[j])  //与0计算结果是原值，与1计算结果是1
                 { //这种情况计算的是半对半错
                    grade += fullscore[j] * 1.0 / 2;
                 }
​
                 if (el)   //这种情况计算的是全错，el是非0，此时要记录错误的选项
                 {
                     for (int k = 0; k &lt; 5; k++)   //一共最多有5个答案，分别是abcde
                        if (el &amp; hash[k])         //与0计算结果为0，与1运算结果为原值，按位与，只有对应的两个二进位都为1时，结果位才为1，参与运算的两个数均以补码出现
                            cnt[j][k]++;
                 }
             }
             else     //表示el为0，就数值相同就grade直接加
             {
                grade += fullscore[j];
             }
         }
         printf(&quot;%.1f\n&quot;, grade);
     }
​
     //找出错的最多的题目的错误个数
     for (int i = 0; i &lt; m; i++)
        for (int j = 0; j &lt; 5; j++)
            maxcnt = maxcnt &gt; cnt[i][j] ? maxcnt : cnt[i][j];
​
    //如果这个maxcnt为0，表示没有题目让学生答错
     if (maxcnt == 0)
     {
        printf(&quot;Too simple\n&quot;);
     }
     else
     {
         for (int i = 0; i &lt; m; i++)
         {
             for (int j = 0; j &lt; 5; j++)
             {
                 if (maxcnt == cnt[i][j])       //
                    printf(&quot;%d %d-%c\n&quot;, maxcnt, i+1, 'a'+j);
             }
         }
     }
     return 0;
 }
​
知识总结：
1.对于本题中判断学生的答案与标答是否一致用：

/*
    用异或语句，如果答案与标答一致则el为0，否则el为非0
*/
int el = opt[i][j] ^ trueopt[j];
2.对于本题中判断学生的答案是否为半对半错用：

/*
    用按位与计算，如果是半对半错则下面执行if下的语句，否则不执行
*/
if ((opt[i][j] | trueopt[j]) == trueopt[j])
3.对于本题中判断学生的答案是否全错用：

if (el)
如果答案为全错，还要记录错误答案是哪个用：

                     for (int k = 0; k &lt; 5; k++)   //一共最多有5个答案，分别是abcde
                        if (el &amp; hash[k])         //与0计算结果为0，与1运算结果为原值，按位与，只有对应的两个二进位都为1时，结果位才为1，参与运算的两个数均以补码出现
                            cnt[j][k]++;
其中cnt结果如下图
在这里插入图片描述
根据循环得到cnt的过程如下：
在这里插入图片描述

对于上图中的解释如下：

第一题：对于CNT的理解。是这么理解的。对于你看，对于第一题正确答案是ac，根据三个学生的答案。第三名学生，他的答案是个BD。正确答案是ac，意思就是说。打错了，是BD，你没答是ac。这是第一题

第二题：对于第二题。正确答案是B。第一个学生答错d e。第二个学生，答案正确，第三个学生。打错e

第三题：对于第三题，正确答案是BC。第一个学生答，错是a，没达世币。第二个学生，第二个学生。他。打错了，是a，没达是C。对于第三个学生。打错是B

第四题：对于第四题，正确答案是abde第一个学生。没打底。第二个答案正确，第三个学生。答错，是c没答是e

4.opt数组结果如下：

在这里插入图片描述

5.对于trueopt数组如下：
在这里插入图片描述

6.对于hash数组如下：
在这里插入图片描述

7.scanf在for中的一些输入

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
int main()
{
​
int temp;
char c;
             scanf(&quot;(%d&quot;, &amp;temp);
             for (int k = 0; k &lt; temp; k++)
             {
                 scanf(&quot; %c)&quot;, &amp;c);
                cout &lt;&lt; c &lt;&lt; &quot; &quot;;
             }
​
     return 0;
 }
​
在这里插入图片描述
在这里插入图片描述

1074
解题思路：
    1.将两个要相加的pat数，左边补充其位置使其和第一个字符串长度一致
    2.for循环，从最后一位开始，先判断如果是10进制，则mod为10；否则就为对应的值
    3.求余数，将其放到ans的最后一位；求其进位的数carry
    4.如果进位的数carry不为0，一律设置为1，在最左边补为1
    5.for循环输出，如果全为0，和第一个位置值为0，则都不输出

参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    知识总结：
    1.设置为指定长度，指定值的字符串(长度为s-s1的长度，初值全设置为0)
        string ss1(s.length()-s1.length(),'0');
*/
int main()
{
    string s,s1,s2,ans;
    int carry=0,flag=0;
    cin &gt;&gt; s &gt;&gt; s1 &gt;&gt; s2;
    string ss1(s.length()-s1.length(),'0');
    s1=ss1+s1;
    string ss2(s.length()-s2.length(),'0');
    s2=ss2+s2;
    ans=s;
​
    for(int i=s.length()-1; i&gt;=0; i--)
    {
        int mod=s[i]=='0'?10:(s[i]-'0');
        ans[i]=(s1[i]-'0'+s2[i]-'0'+carry)%mod+'0';
        carry=(s1[i]-'0'+s2[i]-'0'+carry)/mod;
    }
    if(carry!=0)
        ans='1'+ans;
    for(int i=0; i&lt;ans.length(); i++)
    {
        if(ans[i]!='0' || flag==1)
        {
            flag=1;
            cout &lt;&lt; ans[i];
        }
    }
    if(flag==0)
        cout &lt;&lt; 0;
    return 0;
}
​
知识总结：
    1.设置为指定长度，指定值的字符串(长度为s-s1的长度，初值全设置为0)

        string ss1(s.length()-s1.length(),'0');
1075
解题思路：
    1.设置一个结构数组里面存放data和下标，设置3个vector线性表的数组
    2.用地址作为下标，输入data，在输入next
    3.从start开始，一直循环，根据data将&lt;0和&lt;=k和其他数字，分别将其地址放到v[0],v[1],v[2]
    4.最后按照vector输出，也是双层for循环，按要求输出vi,list[vi]....

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
/*
    解题思路：
​
*/
​
using namespace std;
struct node 
{
    int data, next; 
}list[100000];
​
vector&lt;int&gt; v[3];  //3个vector线性表
​
int main() 
{
        int start, n, k, a;
     cin &gt;&gt; start &gt;&gt; n &gt;&gt; k;
     for (int i = 0; i &lt; n; i++) 
     {
         cin &gt;&gt; a;
         cin &gt;&gt; list[a].data &gt;&gt; list[a].next;
     }
     
     int p = start;
     
     while(p != -1) 
     {
         int data = list[p].data;
         if (data &lt; 0)
            v[0].push_back(p);        //v[0]全部存放&lt;0
         else if 
            (data &gt;= 0 &amp;&amp; data &lt;= k)
         v[1].push_back(p);         //v[1]全部存放&lt;=k
         else
            v[2].push_back(p);
         p = list[p].next;
     }
     
     int flag = 0;
     for (int i = 0; i &lt; 3; i++) 
     {
         for (int j = 0; j &lt; v[i].size(); j++) 
         {
             if (flag == 0) 
             { //设置flag的作用是因为在排列后最后一个位置下标为-1，所以整个输出时先设置flag输出下标，空格，data，空格
                 printf(&quot;%05d %d &quot;, v[i][j], list[v[i][j]].data);
                 flag = 1;
             } 
             else 
             {
                printf(&quot;%05d\n%05d %d &quot;, v[i][j], v[i][j], list[v[i][j]].data);
             }
         }
     }
     printf(&quot;-1&quot;);  //最后再输出-1
     return 0; 
 }
知识总结：
1.设置一个3个线性表的vector数组：

vector&lt;int&gt; v[3];
2.设置结构数组：

struct stu
{
    int data,next;
}list[100001];
1076
参考代码1：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[]={1,2,3,4};
    string temp,num;
    for(int i=0; i&lt;n; i++)
        for(int j=0; j&lt;4; j++)
        {
            cin &gt;&gt; temp;
            if(temp[2]=='T')
                 num+=a[temp[0]-'A']+'0';
        }
    cout &lt;&lt; num;
    return 0;
}
​
参考代码2：

#include&lt;iostream&gt;
using namespace std;
int main()
{
    string s;
    while(cin &gt;&gt; s)
    {
        if(s.size()==3 &amp;&amp; s[2]=='T')
            cout &lt;&lt; s[0]-'A'+1;
    }
    return 0;
}
​
1077
解题思路：
    1.输入n，m
    2.双层for循环，外层输入老师给的成绩g2，内存for循环：1.找出最大，最小值，2.并且统计所有符合条件的值，3.统计
    满足条件的人数
    3.按照格式输出对应的成绩

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*

*/
int main()
{
     int n, m;
     cin &gt;&gt; n &gt;&gt; m;
     for (int i = 0; i &lt; n; i++) 
     {
         int g2, g1 = 0, cnt = -2, temp, maxn = -1, minn = m + 1;
         cin &gt;&gt; g2;
         for (int j = 0; j &lt; n-1; j++) 
         {
             cin &gt;&gt; temp;
             if (temp &gt;= 0 &amp;&amp; temp &lt;= m) 
             {
                 if (temp &gt; maxn) 
                    maxn = temp;
                 if (temp &lt; minn) 
                    minn = temp;
                 g1 += temp;
                 cnt++;
             }
         }
         cout &lt;&lt; int((((g1 - minn - maxn) * 1.0 / cnt) + g2) / 2 + 0.5) &lt;&lt; endl;
     }
     return 0; 
 }
注意事项：

cnt的值一定要设置为cnt-2因为在cnt++中包括了最大，最小值

1078
解题思路：
    1.使用if-else语句，分别构建压缩和解压的代码
    2.对于解压：
        1.for循环嵌套if-else
            1.for循环是根据字符串的长度
            2.if-else是根据判断s[i]是否在'1'~'9'之内
            3.是的话，就num+=s[i]
            4.不是的话，就根据num的长度将其转化为数字，循环输出对应的字符
            5.切记将cnt改为1(保证出现单个字符串时能够输出)，同时将num改为&quot;&quot;
            6.为什么要用string类型的num，因为输入的字符串是string类型的，所以可以方便的接受
            7.为什么要加 if (num.length() &gt; 0)这个判断，因为当num的长度为0，是无法转化成数字，程序界面提示
            会超出范围，这也就是为啥后面设置cnt为1以便能够让单个字符也能输出
    3.对于压缩
        1.对于每一小串相同字符的字符串，每次取出第一个字符，然后统计其个数，再循环输出
        2.切记，当for按照字符串的长度循环结束时，最后还要输出剩余字符串

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
     char t;
     cin &gt;&gt; t;
     getchar();        //接受上面的回车
     string s, num;
     getline(cin, s);
     int cnt = 1;
     if (t == 'D') //解压
     {
         for (int i = 0; i &lt; s.length(); i++)
         {
             if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')
             {
                num += s[i];
             }
             else
             {
                 if (num.length() &gt; 0)
                    cnt = stoi(num);     //将字符串转化为数字
                 while(cnt--)
                    cout &lt;&lt; s[i];
                 cnt = 1;               //cnt设置为1，是因为要保证必须有一个字符输出
                 num = &quot;&quot;;
             }
         }
     }
     else            //压缩
     {
         char pre = s[0];
         for (int i = 1; i &lt; s.length(); i++)
         {
             if (s[i] == pre)
             {
                cnt++;
             }
             else
             {
                 if (cnt &gt;= 2)
                    cout &lt;&lt; cnt;
                 cout &lt;&lt; pre;
                 cnt = 1;
                 pre = s[i];         //s[i]此时表示第1个值
             }
         }
         if (cnt &gt;= 2)           //当整个字符串结束后，输出剩余的值
            cout &lt;&lt; cnt;
         cout &lt;&lt; pre;
     }
     return 0;
 }

知识总结：
1.将字符串转化为数字

string s=&quot;9&quot;;
int a=stoi(s);
cout &lt;&lt; a; //此时a的值即为9
1079
解题思路1:
    1.用while循环，当出现回文数时或者执行步骤&gt;=10，就退出循环
    2.输出字符串和其扭转的字符串，再输出两个字符串相加的值
    3.再将两个数字相加的值转化为字符串
    4.统计每次计算的步骤

参考代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;sstream&gt;
using namespace std;
/*
    解题思路：

*/
bool panduan(string s)
{
    for(int i=0; i&lt;s.length(); i++)
        if(s[i]!=s[s.length()-i-1])
            return 0;
    return 1;
}
string fuhui(int a)
{
    string s;
    stringstream ss;
    ss &lt;&lt; a;
    ss &gt;&gt; s;
    return s;
}
int main()
{
    string s,s1=&quot;12&quot;,s2;
    int num=0;
    cin &gt;&gt; s;
    if(panduan(s))       //如果输入的字符串本身就是回文，就直接输出，不要相加
    {
        cout &lt;&lt; s &lt;&lt; &quot; is a palindromic number.&quot;;
        return 0;
    }

    while(!panduan(s1) &amp;&amp; num&lt;10)
    {
        s2=s;
        reverse(s.begin(),s.end());
        cout &lt;&lt; s2 &lt;&lt; &quot; + &quot; &lt;&lt; s &lt;&lt; &quot; = &quot; &lt;&lt; stoi(s2)+stoi(s) &lt;&lt; endl;
        s1=fuhui(stoi(s2)+stoi(s));
        s=s1;
        num++;
    }
    if(num==10)
        cout &lt;&lt; &quot;Not found in 10 iterations.&quot;;
    else
        cout &lt;&lt; s1 &lt;&lt; &quot; is a palindromic number.&quot;;

}


知识总结：
1.将数字转化为字符串

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
using namespace std;
int main()
{
    int a=3333;
    string s;
    stringstream ss;
    ss &lt;&lt; a;
    ss &gt;&gt; s;
    cout &lt;&lt; s;


}

2.扭转一个字符串

//扭转一个STL字符串
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
    using namespace std;
int main()
{
​
​
    string strSample;
    cin &gt;&gt; strSample;
    cout &lt;&lt; strSample &lt;&lt; endl &lt;&lt; endl;
​
    reverse(strSample.begin(), strSample.end());
    cout &lt;&lt; strSample;
​
    return 0;
}
​
解题思路2：
    1.将字符串扭转的函数rev，模拟手动相加字符串的函数add
    2.首先判断输入的字符串是否为回文是就输出，否则不管
    3.while，循环条件是n--，n=10
        1.对于字符串和其自身的扭转先相加 
        2.按照题意输出
        3.if判断，如果是回文就输出，并且结束程序
        4.当循环结束时，只能输出Not found in 10 iterations.
        

4.add函数
     1.s1表示原始字符串，s2表示其扭转的字符串
     2.设置一个变量carry表示进的那一位
     3.根据原始字符串长度，从最后一个位置开始模拟相加
参考代码：

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
/*
    解题思路：
​
    
*/
string rev(string s)     //rev表示将字符串扭转
{
     reverse(s.begin(), s.end());
     return s;
}
string add(string s1, string s2)  //手动模拟字符串的相加
{
     string s = s1;
     int carry = 0;         //carry表示进的那一位
     for (int i = s1.size() - 1; i &gt;= 0; i--)
     {
         s[i] = (s1[i] - '0' + s2[i] - '0' + carry) % 10 + '0';
         carry = (s1[i] - '0' + s2[i] - '0' + carry) / 10;
     }
     if (carry &gt; 0)   //一定是先给s1前加1，在返回，否则直接return &quot;1&quot;+s就报错
        s = &quot;1&quot; + s;
     return s;
 }
int main()
{
     string s, sum;
     int n = 10;
     cin &gt;&gt; s;
     if (s == rev(s))
     {
                cout &lt;&lt; s &lt;&lt; &quot; is a palindromic number.\n&quot;;
         return 0;
     }
     while (n--)
     {
         sum = add(s, rev(s));    //计算字符串和其扭转的字符串相加
         cout &lt;&lt; s &lt;&lt; &quot; + &quot; &lt;&lt; rev(s) &lt;&lt; &quot; = &quot; &lt;&lt; sum &lt;&lt; endl;
         if (sum == rev(sum))
         {
             cout &lt;&lt; sum &lt;&lt; &quot; is a palindromic number.\n&quot;;
             return 0;
         }
         s = sum;
     }
     cout &lt;&lt; &quot;Not found in 10 iterations.\n&quot;;
     return 0;
 }
​
1080
解题思路：
    1.设置结构node，其中结构成员包括人名，鸡屎成绩，其中成绩，期末成绩，总成绩
    2.用vector设置结构数组，这样可以设置cmp，来按照总成绩降序排列，人名升序排列
    3.设置一个map类型变量idx，他的作用从参加其中，期末考试的人中找到参加鸡屎的人
    4.如果最终成绩&gt;=60，就将其放到结构数组ans中
    5.对ans进行cmp排列，最后输出即可

参考代码：

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
/*
    解题思路：

*/
using namespace std;
struct node           //定义一个结构，
{
 string name;
 int gp, gm, gf, g;
};

bool cmp(node a, node b)  //设置一个按照最终成绩的递减排列，按照名字的递增排列
{
 return a.g != b.g ? a.g &gt; b.g : a.name &lt; b.name;
}

map&lt;string, int&gt; idx;

int main()
{
     int p, m, n, score, cnt = 1;
     cin &gt;&gt; p &gt;&gt; m &gt;&gt; n;
     vector&lt;node&gt; v, ans;   //设置一个结构数组
     string s;
     for (int i = 0; i &lt; p; i++)
     {
         cin &gt;&gt; s &gt;&gt; score;
         if (score &gt;= 200)   //当成绩&gt;200时，直接将node结构放到数组中，并且对成绩大于200的这些人从1开始编号
         {
             v.push_back(node{s, score, -1, -1, 0});
             idx[s] = cnt++;
         }
     }
     for (int i = 0; i &lt; m; i++)
     {
         cin &gt;&gt; s &gt;&gt; score;
         if (idx[s] != 0)     //要找出即参加机示的人且参加其中考试的人
            v[idx[s] - 1].gm = score;   //将期中成绩对应的放到结构中
     }
     for (int i = 0; i &lt; n; i++)
     {
         cin &gt;&gt; s &gt;&gt; score;
         if (idx[s] != 0)               //要找出即参加机示的人且参加期末考试的人
         {
             int temp = idx[s] - 1;
             v[temp].gf = v[temp].g = score;  //先把所有的期末成绩gf和最终成绩g都先设置为期末考试成绩
             if (v[temp].gm &gt; v[temp].gf)   //如果其中考试成绩gm&gt;gf则按要求计算g
                v[temp].g = int(v[temp].gm * 0.4 + v[temp].gf * 0.6 + 0.5);
         }
     }

     for (int i = 0; i &lt; v.size(); i++)
        if (v[i].g &gt;= 60)
            ans.push_back(v[i]);
     sort(ans.begin(), ans.end(), cmp);
     for (int i = 0; i &lt; ans.size(); i++)
        printf(&quot;%s %d %d %d %d\n&quot;, ans[i].name.c_str(), ans[i].gp, ans[i].gm,ans[i].gf, ans[i].g);
     return 0;
 }

注意事项：
1.如果将cnt设为0，后面代码中：
if(idx[s]!=0) 改为 if(idx[s]&gt;=0)
v[idx[s]-1].gm=score; 改为 v[idx[s]].gm=score;
int temp=idx[s]-1; 改为 int temp=idx[s];
但是如果在第一次for循环输入时，鸡屎没有&gt;=200，那最后再输入下次循环的第一个值，就直接退出了，如下图所示
在这里插入图片描述
正常代码的结果如下：就是没任何输入
在这里插入图片描述

1081
解题思路：
    1.for循环先输入字符串，然后if-else判断如果字符串长度&gt;=6，则进入下一步；否则就输出字符串太短了
    2.设置3个int类型且初值为0的三个变量int invalid = 0, hasAlpha = 0, hasNum = 0;
    3.if-else if-else if构建：
        1.如果字符不是小数点也不是字母和数字，设置invalid为1，最后根据invalid的值为1，来输出太乱了
        2.进入第一个else if，如果字符是字母，则设置hasAlpha为1，最后根据hasAlpha的值为0，来输出缺少字母
        3.进入第二个else if，如果字符是数字，则设置hasNum为1，最后根据hasNum的值为0，来输出缺少数字
        4.如果没有以上情况，就输出完美

参考代码：

#include &lt;iostream&gt;
#include &lt;cctype&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     int n;
     cin &gt;&gt; n;
     getchar();   //接受缓冲区的回车，
     for (int i = 0; i &lt; n; i++)
     {
         string s;
         getline(cin, s);
         if (s.length() &gt;= 6)
         {
             int invalid = 0, hasAlpha = 0, hasNum = 0;
             for (int j = 0; j &lt; s.length(); j++)
             {
                 if (s[j] != '.' &amp;&amp; !isalnum(s[j]))
                    invalid = 1;
                 else if
                    (isalpha(s[j]))
                        hasAlpha = 1;
                 else if (isdigit(s[j]))
                    hasNum = 1;
             }
             if (invalid == 1)
                cout &lt;&lt; &quot;Your password is tai luan le.\n&quot;;
             else if (hasNum == 0)
                cout &lt;&lt; &quot;Your password needs shu zi.\n&quot;;
             else if (hasAlpha == 0)
                cout &lt;&lt; &quot;Your password needs zi mu.\n&quot;;
             else
                cout &lt;&lt; &quot;Your password is wan mei.\n&quot;;
         }
        else
            cout &lt;&lt; &quot;Your password is tai duan le.\n&quot;;
     }
     return 0;
 }
​
知识总结：
1.如果用cin输入数字，紧接用getline输入，必须在二者之间加入getchar()，否则就在输入完数字后程序结束

#include &lt;iostream&gt;
#include &lt;cctype&gt;
using namespace std;
​
int main()
{
     int n;
     cin &gt;&gt; n;
     //getchar();    //
     string s;
     getline(cin,s);
​
     return 0;
 }
​
2.isalnum)用来判断字符是数字或者字母？是，返回true；否则，返回false
3.isalpha()用来判断字符是纯字母？是，返回true；否则，返回false
4.isdigit()用来判断字符是数字？是，返回true；否则，返回false

1082
解题思路1：
    1.先计算两个数字的平方和dis
    2.找出最大数字所对应的运动员编号
    3.找出最小数字所对应的运动员编号
    4.每次更新最大，最小值
    5.输出

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     int n, id, x, y, maxid, maxdis = -1, minid, mindis = 99999;
     cin &gt;&gt; n;
     for (int i = 0; i &lt; n; i++)
     {
         cin &gt;&gt; id &gt;&gt; x &gt;&gt; y;
         int dis = x * x + y * y;
         if (dis &gt; maxdis)
            maxid = id;
         if (dis &lt; mindis)
            minid = id;
         maxdis = max(maxdis, dis);   
         mindis = min(mindis, dis);
     }
     printf(&quot;%04d %04d&quot;, minid, maxid);
     return 0;
 }
​
知识总结：
1.max函数，min函数

#include &lt;iostream&gt;
using namespace std;
int main()
{

    int a=5,b=3;
     cout &lt;&lt; min(a,b);  //输出a，b中较小的值
     cout &lt;&lt; max(a,b);   //输出a,b中较大的值

     return 0;
 }

解题思路2：

1.设置一个结构数组，并输入
2.通过循环找出求两个数字平方和的最大值下标和最小值下标
3.最后根据下标输出编号
参考代码：

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
struct su
{
    int a,b,c;
};
int main()
{
    int n,max=0,min=0,max1=-1,min1=100003;
    cin &gt;&gt; n;
    su a[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i].a &gt;&gt; a[i].b &gt;&gt; a[i].c;
    for(int i=1; i&lt;n; i++)
    {
        if(a[i].b*a[i].b+a[i].c*a[i].c &gt; a[max].b*a[max].b+a[max].c*a[max].c)
            max=i;
        if(a[i].b*a[i].b+a[i].c*a[i].c &lt; a[min].b*a[min].b+a[min].c*a[min].c)
            min=i;
    }
   printf(&quot;%04d %04d&quot;,a[min].a,a[max].a);
}

1083
解题思路1：
    1.设置一个长度为10000的数组a
    2.将其计算结果作为数组下标，元素值++
    3.从后向前输出，如果元素值&gt;=2，则输出对应的下标也就是之前算的差值，并且再输出其元素值

参考代码：

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main() 
{
     int n, t, a[10000] = {0};
     cin &gt;&gt; n;
     for (int i = 1; i &lt;= n; i++) 
     {
         cin &gt;&gt; t;
         a[abs(t-i)]++;
     }
     for (int i = 9999; i &gt;= 0; i--)
        if (a[i] &gt;= 2) 
            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; endl;
     return 0; 
 }
解题思路2：
    1.定义一个vector数组，然后计算与下标相减再减1,
    2.对vector数组进行降序排列
    3.循环输出重复出现&gt;=2次的数，及其重复次数。（思想就是：每次取出第一个，然后与后面的值比较统计其重复次数）

参考代码：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
/*
    
​
*/
using namespace std;
bool cmp(int a,int b)
{
    return a&gt;b;
}
int main()
{
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt;a(n);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        a[i]=abs(a[i]-i-1);
    }
    sort(a.begin(),a.end(),cmp);
    int temp=a[0],cnt=1;
    for(int i=1; i&lt;n; i++)
    {
        if(temp==a[i])
            cnt++;
        else
        {
            if(cnt&gt;=2)
                cout &lt;&lt; temp &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;
            temp=a[i];
            cnt=1;
        }
    }
    if(cnt&gt;=2)
        cout &lt;&lt; temp &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl;
    return 0;
}
​
1084
解题思路1：
    1.zhuanhua()函数是将数字转化为字符串
    2.xinzhi()函数是每次返回统计后的字符串（就像前面说的一样，统计重复出现的字符串个数）
    3.main走一个循环即可

参考代码：

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
using namespace std;
/*
    解题思路；
    1.用字符串s来报存，改变s，
*/
string zhuanhua(int a)
{
    string s;
    stringstream ss;
    ss &lt;&lt; a;
    ss &gt;&gt; s;
    return s;
}
string xinzhi(string s)
{
    string num,s1;
    num+=s[0];
    int cnt=1;
    for(int i=1; i&lt;s.length(); i++)
    {
        if(num[0]==s[i])
            cnt++;
        else
        {
            s1=s1+num+zhuanhua(cnt);
            num=&quot;&quot;;
            num+=s[i];
            cnt=1;
        }
    }
    s1=s1+num+zhuanhua(cnt);
    return s1;
}
int main()
{
    string s;
    int a;
    cin &gt;&gt; s &gt;&gt; a;
    for(int i=1; i&lt;a; i++)
    {
        xinzhi(s);
        s=xinzhi(s);
    }
    cout &lt;&lt; s;
}
​
解题思路2：
1.三层for循环，外层for是第n个；第2层for和第3层的作用就是比如：前面一个值是1121 通过此5行代码 就变成 122111
2.第二层for与第三层for：
	1.以字符串的长度循环，但是循环的增量是i=j也就是下一小段相同字符串的第一个字符的位置
	2.第3层for，j=i从这个位置开始，如果后面的字符和前面的相同，则j++统计相同字符的个数
	3.最后将字符和相同字符的个数加到临时字符串变量t中

参考代码：

#include &lt;iostream&gt;
using namespace std;
int main()
{
     string s;
     int n, j;
     cin &gt;&gt; s &gt;&gt; n;
     for (int cnt = 1; cnt &lt; n; cnt++)   //控制它的循环次数
     {
         string t;        //临时变量t
         for (int i = 0; i &lt; s.length(); i = j)   //此行代码开始向下5行的作用就是
         {
             for (j = i; j &lt; s.length() &amp;&amp; s[j] == s[i]; j++)
                     ;  //统计相同字符的个数
                t += s[i] + to_string(j - i);   //+的优先级&gt; +=  t表示前一个字符的结果，s[i]当前每一小段字符，to_string(j-i)实质表示相同字符的个数
         }
         s = t;
     }
     cout &lt;&lt; s;
     return 0;
 }
​
知识总结：
1.将数字转化为字符串

to_string(123); //表示将数字123转化为字符串123
注意事项：
1.切记第3层for的循环语句是 ;   这个循环的目的是统计相同字符的个数
2.由于第2层的循环增量是i=j，所以要提前定义变量j，并且在第3层for的循环中，不能再定义临时变量j

1085
解题思路：
  1.设置一个结构node，cmp排序
    2.设置两个map类型
    3.for循环输入信息
        1.根据学校，将其字符串所有字符改为小写
        2.每次根据题型算出对应的分数
        3.以学校名为关键字，sum中成绩累加，cnt中人数累加
    4.设置一个数组结构，将sum和cnt中的信息导入进数组结构，并且对数组结构进行cmp
    5.按照要求输出

参考代码：

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
/*
    解题思路：
​
*/
using namespace std;
struct node
{
 string school;
 int tws, ns;     //tws就是总分，ns就是人数
};
​
bool cmp(node a, node b)
{
 if (a.tws != b.tws)    //如果总分不同，按照总分的降序排列
 return a.tws &gt; b.tws;
 else if (a.ns != b.ns)  //如果总分相同，按照人数的升序排列
 return a.ns &lt; b.ns;
    else
 return a.school &lt; b.school;  //如果总分，人数相同，按照学校名的升序排列
 }
​
int main()
{
     int n;
     cin &gt;&gt; n;
     map&lt;string, int&gt; cnt;
     map&lt;string, double&gt; sum;
     for (int i = 0; i &lt; n; i++)
     {
         string id, school;
         cin &gt;&gt; id;
         double score;
         cin &gt;&gt; score;
         cin &gt;&gt; school;
​
         for (int j = 0; j &lt; school.length(); j++)
            school[j] = tolower(school[j]);
​
         if (id[0] == 'B')
            score = score / 1.5;
         else if (id[0] == 'T')
            score = score * 1.5;
         sum[school] += score;  //计算不同学校对应的总分
         cnt[school]++;       //统计人数
     }
​
     vector&lt;node&gt; ans;  //将信息放到ans数组结构中
     for (auto it = sum.begin(); it != sum.end(); it++)  //设置迭代器，将对应的信息放到ans中
        ans.push_back(node{it-&gt;first, (int)sum[it-&gt;first], cnt[it-&gt;first]});
​
     sort(ans.begin(), ans.end(), cmp);  //按照要求排序
​
​
     int rank = 0, pres = -1;
     cout &lt;&lt; ans.size() &lt;&lt; endl;
​
     for (int i = 0; i &lt; ans.size(); i++)  //如果成绩不同，则按照i+1输出; 否则不变其排名
     {
         if (pres != ans[i].tws)
            rank = i + 1;
         pres = ans[i].tws;
         printf(&quot;%d &quot;, rank);
​
         cout &lt;&lt; ans[i].school;
         printf(&quot; %d %d\n&quot;, ans[i].tws, ans[i].ns);
     }
     return 0;
 }
​
知识总结：
1.将字符串中的每个字符改为小写

#include&lt;iostream&gt;
using namespace std;
int main()
{
    string s;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.leng(); i++)
        s[i]=tolower(s[i]);
}
2.如果对vector中的三个信息需要比较的话，应该用if-else去设置

bool cmp(node a, node b)
{
 if (a.tws != b.tws)    //如果总分不同，按照总分的降序排列
 return a.tws &gt; b.tws;
 else if (a.ns != b.ns)  //如果总分相同，按照人数的升序排列
 return a.ns &lt; b.ns;
    else
 return a.school &lt; b.school;  //如果总分，人数相同，按照学校名的升序排列
 }
1086
参考代码1

#include&lt;iostream&gt;
#include&lt;sstream&gt;
using namespace std;

int main()
{
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;
    string s;
    stringstream ss;
    ss &lt;&lt; a*b;
    ss &gt;&gt; s;
    for(int i=s.length()-1; i&gt;=0; i--)
        cout &lt;&lt; s[i];
}

参考代码2：

#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;
    string s;
    s=to_string(a*b);
    reverse(s.begin(),s.end());
    cout &lt;&lt; stoi(s);
}

知识总结：
1.将数字转换为字符串

    s=to_string(a*b);
2.扭转字符串

    reverse(s.begin(),s.end());
3.将数字字符串转化为数字

cout &lt;&lt; stoi(s);
注意事项；
1.要注意最后将字符串一定转化为数字，否则有的测试点过不去

1087
参考代码：

#include&lt;iostream&gt;
#include&lt;set&gt;
using namespace std;
int main()
{
    int n;
    cin &gt;&gt; n;
    set&lt;int&gt; s;
    for(int i=1; i&lt;=n; i++)
        s.insert(i/2+i/3+i/5);
    cout &lt;&lt; s.size();
    return 0;
}
1088
解题思路：
    1.将甲的值从99~1开始递减循环
    2.先算出jia，yi，bing三个值，然后进行判断一但有满足条件的就退出
    3.后面按照题意输出

参考代码：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int x,y,my;
    cin &gt;&gt; my &gt;&gt; x &gt;&gt; y;
    int jia=0,yi,bing;
    for(jia=99; jia&gt;=1; jia--)
    {
        yi=jia%10*10+jia/10;
        if(abs(jia-yi)%x==0)
            bing=abs(jia-yi)/x;
        if(bing!=0 &amp;&amp; yi==bing*y)
        {
            break;
        }
    }
    if(jia==0)
    {
        cout &lt;&lt; &quot;No Solution&quot;;
        return 0;
    }
    else
    {
        string s=jia&gt;my?&quot;Cong&quot;:jia==my?&quot;Ping&quot;:&quot;Gai&quot;;
        string s1=yi&gt;my?&quot;Cong&quot;:yi==my?&quot;Ping&quot;:&quot;Gai&quot;;
        string s2=bing&gt;my?&quot;Cong&quot;:bing==my?&quot;Ping&quot;:&quot;Gai&quot;;
        cout &lt;&lt; jia &lt;&lt; &quot; &quot; &lt;&lt; s &lt;&lt; &quot; &quot; &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; s2;
return 0;
    }
​
    return 0;
}
​
解题思路2：
    1.输出m,x,y三个值
    2.还是jia的值从99~10递减循环
    3.计算出yi的值
    4.切记将bing的值设为double类型
    5.判断是否满足条件，满足就输出，然后return 0
    6.最后再输出&quot;No Solution&quot;

参考代码2：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
int jia,yi,my;
double bing;
void print(double m)  //这个m由于还有bing的值，所以设置为double类型
{
    if(m==my)
        cout &lt;&lt; &quot; Ping&quot;;
    else if(m&gt;my)
        cout &lt;&lt; &quot; Cong&quot;;
    else
        cout &lt;&lt; &quot; Gai&quot;;
}
int main()
{
    int x,y;
    cin &gt;&gt; my &gt;&gt; x &gt;&gt; y;
    for(jia=99; jia&gt;=10; jia--)
    {
        yi=jia%10*10+jia/10;
        bing=abs(jia-yi)*1.0/x;
        if(yi==bing*y)
        {
            cout &lt;&lt; jia;
            print(jia);
            print(yi);
            print(bing);
            return 0;
        }
    }
    cout &lt;&lt; &quot;No Solution&quot;;
    return 0;
}
​
1089
解题思路：
    1.使用v数组来存放实时情况
    2.3层for循环嵌套：
        1.前2层循环是假设i,j=i+1是狼人，这样来最后判断出谁是狼人
        2.在第2层for循环中要设置vector类型的数组lie，a分别表示说谎人的编号和人员成分的数组（意思是如下图所示）
        3.第3层for循环用来判断2个说谎人的编号，将其放到lie数组中
        4.如果lie的长度是2表示有2个说谎的人，并且说谎人的编号在数组a中对应的值相加为0，因为一个说谎的是狼人，那另一个说谎的好人，所以相加为0
        5.至于有多个值，按照最小序列输出；本来就是i从1开始，并且j=i+1一直的证到n（也是从小到大）

在这里插入图片描述

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
     int n;
     cin &gt;&gt; n;
     vector&lt;int&gt; v(n+1);

     for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; v[i];     //v数组表示的是实时情况

     for (int i = 1; i &lt;= n; i++)
     {
         for (int j = i + 1; j &lt;= n; j++)
         { //a数组表示的就对应的编号是狼人，还是好人
             vector&lt;int&gt; lie, a(n + 1, 1);   //a是一个长度为n+1，并且初始值全为1的数组
             a[i] = a[j] = -1;  //1表示好人；-1表示狼人
             for (int k = 1; k &lt;= n; k++)   //k从1~n分别判断k所说的是真是假
                if (v[k] * a[abs(v[k])] &lt; 0) //k说的话和真实情况不同(v[k] * a[abs(v[k])] &lt; 0)则表示k在说谎，将k放在lie数组中
                    lie.push_back(k);   // lie数组表示将说谎人的编号
             if (lie.size() == 2 &amp;&amp; a[lie[0]] + a[lie[1]] == 0)  //如果说谎人数等于2并且这两个说谎的人一个是好人一个是狼人
            {//a[lie[0]] + a[lie[1]] == 0表示的意思是两个狼人中一个说谎一个说真话
                 cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j;
                 return 0;
            }
         }
     }
     cout &lt;&lt; &quot;No Solution&quot;;
     return 0;
}

1090
解题思路：
    1.设置一个map类型的vector的数组，每次输入两个值，其中一个为关键字，另一个为元素值，在反过来设置下
    2.根据k循环
        1.cnt表示运输货物的个数，flag就是一个标签，a是以货物编号为下标，元素值初始都为0，但是将要运输的货物的
        元素值设为1
        2.双层for循环：
            1.第一层以要运输的货物个数为准
            2.第2层for是以与每个运输货物不相容的货物个数为下标，然后判断am[v[i]]是否为1，为1表示运输的货物中有不相容的
            最后按要求输出

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
/*
    解题思路：
​
*/
int main() 
{
     int n, k, t1, t2;
     map&lt;int,vector&lt;int&gt;&gt; m;
     scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
     for (int i = 0; i &lt; n; i++)   //设置一个关键字是int类型的值，它下面是一个vector的数组
     {
         scanf(&quot;%d%d&quot;, &amp;t1, &amp;t2);
         m[t1].push_back(t2);
         m[t2].push_back(t1);
     }
     while (k--) 
     {
         int cnt, flag = 0, a[100000] = {0};  //0表示不相容
         scanf(&quot;%d&quot;, &amp;cnt);
         vector&lt;int&gt; v(cnt);
         for (int i = 0; i &lt; cnt; i++) 
         {
             scanf(&quot;%d&quot;, &amp;v[i]);     //v[i]是运输货物的编号
             a[v[i]] = 1;          //此行代码的意思是将所有要运输的货物下标设为1，其余都是0
         }
     
         for(int i=0; i&lt;v.size(); i++)     //第一层for遍历循环每个要运输的货物
            for(int j=0; j&lt;m[v[i]].size(); j++)  //第2层for是看每个要运输的货物，下面有哪些不相容的物体，在对应回去a数组的元素看是否为之前设置的1，如果是表示不相容flag=1
                if (a[m[v[i]][j]] == 1) 
                    flag = 1;
         printf(&quot;%s\n&quot;,flag?&quot;No&quot;:&quot;Yes&quot;);  //如果flag为1表示不相容，如果flag为0表示想容
     }
     return 0;
}
​
知识总结：
1.对于需要有一个值作为关键字，然后其后对应多个值，可以设置为map类型，代码如下：

map&lt;int,vector&lt;int&gt;&gt; m;   //设置一个关键字为int类型，然后下面是一个vector的数组
2.如果用while对于某一个值cnt来循环，可以设置为

while(cnt--)
{}
3.对于给vector数组输入值时，最好提前设置好vector的长度，这样可以保证全部输入进去

         scanf(&quot;%d&quot;, &amp;cnt);
         vector&lt;int&gt; v(cnt);
         for (int i = 0; i &lt; cnt; i++) 
         {
             scanf(&quot;%d&quot;, &amp;v[i]);     //v[i]是运输货物的编号
    
         }
1091
参考代码；

#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.让j的值从小到大开始排列
    2
*/
int fanhui(int a)
{
    int b=1;
    while(a!=0)
    {
       b*=10;
       a/=10;
    }
    return b;
}
int main()
{
    int n,j;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        int temp;
        cin &gt;&gt; temp;
        for(j=1; j&lt;10; j++)
        {
            if((j*temp*temp-temp)%fanhui(temp)==0)
            {
​
                cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; j*temp*temp &lt;&lt; endl;
                break;
            }
        }
        if(j==10)
            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
​
    }
}
​
解题思路2：
    1.to_string是将数字转化为字符串
    2.将两个要比较的数字转化为字符串，然后分别计算其长度，然后截取
    3.最后比较字符，如果相同则输出

参考代码：

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
/*
    解题思路：
​
*/
int main() 
{
     int m;
     cin &gt;&gt; m;
     while (m--) 
     {
         int k,n;
         cin &gt;&gt; k;
         for (n = 1; n &lt; 10; n++) 
         {
             int mul = n * k * k;
             string smul = to_string(mul), sk = to_string(k);
             string smulend = smul.substr(smul.length() - sk.length());
             if (smulend == sk) 
             {
                    printf(&quot;%d %d\n&quot;, n, mul);
                    break;
             }
         }
         if (n==10)
            printf(&quot;No\n&quot;);
     }
     return 0; 
}
​
/*
​
    
*/
   知识总结：
    1.s.substr(n)表示从s这个字符串中的第n个位置开始截取一直到最后

1092
解题思路：
    1.双层for将每次的销售量相加，最后得到一个数组，就下标对应品种，元素值对应总销售量
    2.找出其中最大值，然后遍历循环，如果有对应的，则直接按照要求输出输出即可

参考代码：

#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;int&gt; a(n+1);
    for(int i=0; i&lt;m; i++)
    {
        for(int j=1; j&lt;=n; j++)
        {
            int temp;
            cin &gt;&gt;temp;
            a[j]+=temp;
        }
    }
    int max=-1;
    for(int i=1; i&lt;=n; i++)
    {
        if(a[i]&gt;=max)
            max=a[i];
    }
    cout &lt;&lt; max &lt;&lt; endl;
    int flag=1;
    for(int i=1; i&lt;=n; i++)
    {
        if(a[i]==max)
        {
            if(flag!=1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; i;
            flag++;
        }
    }
}
​
对上面代码的改进：
1.如果将sum设为vector在main函数中就行
2.如果将sum设为普通数组形式，只能将其放到main函数外，否则不正确

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main()
{
     int m, n, maxn=0,s;
     cin &gt;&gt; m &gt;&gt; n;
     vector&lt;int&gt; sum(m+1);
     for (int i = 1; i &lt;= n; i++)
     {
         for (int j = 1; j &lt;= m; j++)
         {
             cin &gt;&gt; s;
             sum[j] += s;
             maxn=max(maxn,sum[j]);
         }
     }
     cout &lt;&lt; maxn &lt;&lt; endl;
     int flag=1;
     for(int i=1; i&lt;=m; i++)
     {
         if(sum[i]==maxn)
         {
              if(flag!=1)
                cout &lt;&lt; &quot; &quot;;
             cout &lt;&lt; i;
             flag++;
         }
​
     }
     return 0;
 }
​
1093
解题思路1：
    1.用getline输入两个字符串
    2.先相加
    3.双层for，从第2开始每次与前面的相比较，如果相同则消除
    4.消除2次

参考代码1：

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
    string a,b;
    getline(cin,a);
    getline(cin,b);
    a+=b;
    for(int i=1; i&lt;a.length(); i++)
    {
        for(int j=0; j&lt;i; j++)
        {
            if(a[i]==a[j])
                a.erase(i,1);
        }
    }
    for(int i=1; i&lt;a.length(); i++)
    {
        for(int j=0; j&lt;i; j++)
        {
            if(a[i]==a[j])
                a.erase(i,1);
        }
    }
    cout &lt;&lt; a;
}
​
解题思路2：
    1.设置一个数组的初始值全为0
    2.以字符串的值作为下标
    3.遍历循环字符串，如果字符作为下标所对应的元素值为0，就输出字符；然后在把元素值改为1

参考代码2：、

#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
​
*/
int main()
{
     string s1, s2, s;
     int a[150] = {0};
     getline(cin, s1);
     getline(cin, s2);
     s = s1 + s2;
     for (int i = 0; i &lt; s.size(); i++)
     {
         if (a[s[i]] == 0)
            cout &lt;&lt; s[i];
         a[s[i]] = 1;
     }
     return 0;
 }
​
1094
解题思路：
    解题思路：
    1.每次按照k个连续的数取截取字符串，如果是素数就直接输出，否则最后输出404

参考代码：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;sstream&gt;
using namespace std;
/*
​
*/
bool fanhui(int a)
{
    for(int i=2; i&lt;sqrt(a); i++)
        if(a%i==0)
            return false;
    return true;
}
int main()
{
​
    string s;
    int l,k,i;
    cin &gt;&gt; l &gt;&gt; k &gt;&gt; s;
    for(i=0; i&lt;=s.length()-k; i++)
    {
        stringstream ss;
        int a;
        string temp;
        temp=s.substr(i,k);
        ss &lt;&lt; temp;
        ss &gt;&gt; a;
        if(fanhui(a))
        {
            cout &lt;&lt; a;
            return 0;
        }
    }
    if(i&gt;s.length()-k)
        cout &lt;&lt; 404 &lt;&lt; endl;
    return 0;
}
​
以上代码改进：

#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
bool fanhui(int a)
{
    if(a==0 || a==1)
        return false;
    for(int i=2; i&lt;sqrt(a); i++)
        if(a%i==0)
            return false;
    return true;
}
int main()
{
    string s;
    int l,k;
    cin &gt;&gt; l &gt;&gt; k &gt;&gt; s;
    for(int i=0; i&lt;=l-k; i++)
    {
        string a=s.substr(i,k);
        int q=stoi(a);  //改进在这里
        if(fanhui(q))
        {
            cout &lt;&lt; a;  //注意这里是输出字符串，对于0002，如果输出数字是2，但是题中要求输出0002
            return 0;
        }
    }
    cout &lt;&lt; 404 &lt;&lt; endl;
    return 0;
}
​
知识总结：
1.stoi将字符串转化为整数

int q=stoi(a);  //改进在这里

1095
解题思路：
1.设置结构数组v，输入相关信息
2.for循环嵌套if-else语句：
	1.输入num
	2.根据num不同的值对应不同的操作：
		1.num==1：
			1.按要求先输出一行
			2.通过for循环，对应于原结构数组；如果满足条件，则将对应结构压入新的结构数组ans中
			3.排序+输出
			4.如果ans的长度为0，则输出NA
		2.num ==2
			1.设置cnt  == o, sum == 0
			2.按要求输出一行
			3.通过循环，如果找到对应的考场，则统计人数和总分
			4.如果人数不为0，则输出人数和总分，否则，输出NA
	3.num == 3
		1.设置string类型date
		2.按要求输出一行
		3.新结构site的数组ans
		4.通过循环找出，日期对应得，并截取考场字符串，接统计人数
		5.map中的关键字和元素值对应到结构数组ans中
		6.排序+输出
		7.ans长度为0，输出NA

参考代码：

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;
struct stu   //准考证和成绩的一个结构
{
     string id;
     int sco;
};
​
struct site   //考场字符串和人数的一个结构
{
     string siteId;
     int cnt;
};
​
bool cmp1(const stu a, const stu b)   //如果成绩相同，则按照id的增序输出；否则按照，成绩的降序输出
{
 return a.sco == b.sco ? a.id &lt; b.id : a.sco &gt; b.sco;
}
​
bool cmp2(const site &amp;a, const site &amp;b)   //如果人数相同，则按照考场字符串的升序输出；否则按照，人数的降序输出
{
 return a.cnt == b.cnt ? a.siteId &lt; b.siteId : a.cnt &gt; b.cnt;
}
​
int main()
{
     int n, k;
     cin &gt;&gt; n &gt;&gt; k;
     vector&lt;stu&gt; v(n);    //结构数组
​
     for (int i = 0; i &lt; n; i++)
        cin &gt;&gt; v[i].id &gt;&gt; v[i].sco;  //将信息输入至结构数组
​
     for (int i = 1; i &lt;= k; i++)
     {
         int num;
         scanf(&quot;%d&quot;, &amp;num);
         if (num == 1)
         {
             string level;
             cin &gt;&gt; level;   
             printf(&quot;Case %d: %d %s\n&quot;, i, num, level.c_str());  //level.c_str()专用于printf的输出
             vector&lt;stu&gt; ans;  //定义一个vector的新结构ans
             for (int i = 0; i &lt; n; i++)    //通过for循环，对应于原结构数组；如果满足条件，则将对应结构压入新的结构数组ans中
             {
                 if (v[i].id[0] == level[0])
                    ans.push_back(v[i]);
             }
             sort(ans.begin(), ans.end(),cmp1);  //排序
             for (int i = 0; i &lt; ans.size(); i++)   //输出
             printf(&quot;%s %d\n&quot;, ans[i].id.c_str(), ans[i].sco);
             if (ans.size() == 0) printf(&quot;NA\n&quot;);  //如果ans长度为0，则输出NA
         }
         else if (num == 2) 
         {
             int cnt = 0, sum = 0;  //设置cnt=0，sum=0
             int siteId;
             cin &gt;&gt; siteId;   
             printf(&quot;Case %d: %d %d\n&quot;, i, num, siteId);
             for (int i = 0; i &lt; n; i++)  //通过循环，如果找到对应的考场，则统计人数和总分
             {
                 if (v[i].id.substr(1, 3) == to_string(siteId)) 
                 {
                     cnt++;
                     sum += v[i].sco;
                 }
             }
             if (cnt != 0)    //如果人数不为0，则输出人数和总分
                printf(&quot;%d %d\n&quot;, cnt, sum);
             else           //否则，输出NA
                printf(&quot;NA\n&quot;);
         } 
         else if (num == 3) 
         {
             string date;
             cin &gt;&gt; date;
             printf(&quot;Case %d: %d %s\n&quot;, i, num, date.c_str());
             vector&lt;site&gt; ans;     //新结构site的数组ans
             unordered_map&lt;string, int&gt; m;
             for (int i = 0; i &lt; n; i++)   //通过循环找出，日期对应得，并截取考场字符串，接统计人数
             {
                 if (v[i].id.substr(4, 6) == date) 
                 {
                     string tt = v[i].id.substr(1, 3);
                     m[tt]++;
                 }
             }
             for (auto it : m)  //将map中的关键字和元素值对应到结构数组ans中
                ans.push_back({it.first, it.second});
             sort(ans.begin(), ans.end(),cmp2);
             for (int i = 0; i &lt; ans.size(); i++)
                printf(&quot;%s %d\n&quot;, ans[i].siteId.c_str(), ans[i].cnt);
             if (ans.size() == 0) 
                    printf(&quot;NA\n&quot;);
         }
     }
     return 0;
 }
​
知识总结：
1.用printf输出string类型字符串

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    string s;
    cin &gt;&gt; s;
    printf(&quot;%s\n&quot;,s);     //string类型的变量如果用printf输出，就不对
    printf(&quot;%s&quot;,s.c_str());  //对于printf，只能用c_str()*/
}
​
2.c++11新特性，直接输出v的字符串

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; v={1,2,3,4};
    for(auto i:v)
        cout &lt;&lt; i;
​
}
​
3.c++11新特性，将map的关键字和元素值对应到结构数组中   

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;unordered_map&gt;
using namespace std;
struct site   //考场字符串和人数的一个结构
{
     string siteId;
     int cnt;
};  
int main()
{ 
    vector&lt;site&gt; ans;
    unordered_map&lt;string, int&gt; m;    
    for (auto it : m)
        ans.push_back({it.first, it.second});
​
}
​
4.map和unordered_map的区别：
 map：

优点：

有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高
缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间

适用处：对于那些有顺序要求的问题，用map会更高效一些

unordered_map：

优点： 因为内部实现了哈希表，因此其查找速度非常的快
缺点： 哈希表的建立比较耗费时间
适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map
总结：

内存占有率的问题就转化成红黑树 VS hash表 , 还是unorder_map占用的内存要高。
但是unordered_map执行效率要比map高很多
对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的

注意事项：

printf(&quot;Case %d: %d %s\n&quot;, i, num, level.c_str());  //level.c_str()专用于printf的%s输出

用printf(&quot;%s %d\n&quot;,ans[i].id.c_str(),ans[i].sco)向比于cout &lt;&lt; ans[i].id &lt;&lt; &quot; &quot; &lt;&lt; ans[i].sco &lt;&lt; endl节省时间
3.

用printf(&quot;%s %d\n&quot;,ans[k].siteId.c_str(),ans[k].cnt)相比于cout &lt;&lt; ans[k].siteId &lt;&lt; &quot; &quot; &lt;&lt; ans[k].cnt &lt;&lt; endl;节省时间
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第九章笔记（排序）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/">
        </link>
        <updated>2020-03-01T04:22:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">9.1开场白</a><br>
<a href="#jump2">9.2排序的基本概念和分类</a><br>
      <a href="#jump3">9.2.1排序的稳定性</a><br>
      <a href="#jump4">9.2.2内排序与外排序</a><br>
      <a href="#jump5">9.2.3排序用到的结构与函数</a><br>
<a href="#jump6">9.3冒泡排序</a><br>
      <a href="#jump7">9.3.1最简单排序实现</a><br>
      <a href="#jump8">9.3.2冒泡排序算法</a><br>
      <a href="#jump9">9.3.3冒泡排序优化</a><br>
      <a href="#jump10">9.3.4冒泡排序复杂度分析</a></p>
<p><a href="#jump11">9.4简单选择排序</a><br>
      <a href="#jump12">9.4.1简单选择排序算法</a><br>
      <a href="#jump13">9.4.2简单选择排序复杂度分析</a></p>
<p><a href="#jump14">9.5直接插入排序</a><br>
      <a href="#jump15">9.5.1直接插入排序算法</a><br>
      <a href="#jump16">9.5.2直接插入排序复杂度分析</a></p>
<p><a href="#jump17">9.6直接插入排序</a><br>
      <a href="#jump18">9.6.1希尔排序原理</a><br>
      <a href="#jump19">9.6.2希尔排序算法</a><br>
      <a href="#jump20">9.6.3希尔排序复杂度分析</a></p>
<p><a href="#jump21">9.8 归并排序</a><br>
      <a href="#jump22">9.8.1归并排序算法</a><br>
      <a href="#jump23">9.8.2归并排序复杂度分析</a><br>
      <a href="#jump24">9.8.3非递归实现归并排序</a></p>
<p><a href="#jump25">9.7堆排序</a><br>
      <a href="#jump26">9.7.1堆排序算法</a><br>
      <a href="#jump27">9.7.2堆排序复杂度分析</a></p>
<p><a href="#jump28">9.9快速排序</a><br>
      <a href="#jump29">9.9.1快速排序算法</a><br>
      <a href="#jump30">9.9.2快速排序复杂度分析</a><br>
      <a href="#jump31">9.9.3快速排序优化</a></p>
<p><span id="jump2">9.2排序的基本概念和分类</span><br>
1.排序就是将无序的数据集合，按照某一定顺序进行排列<br>
2.对于有很多关键字的排序，可以将多个关键字的排序转化成单个关键字的排序，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200216211522213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021621153480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump3">9.2.1排序的稳定性</span><br>
如图：<br>
<img src="https://img-blog.csdnimg.cn/20200216211947313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump4">9.2.2内排序与外排序</span><br>
     1.什么叫内排序，外排序：（如下图）</p>
<p><img src="https://img-blog.csdnimg.cn/20200216212209422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     2.排序算法的性能主要是受3个方面影响：</p>
<p>            1.时间性能：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/20200216212512766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            2.辅助空间：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/2020021621252762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            3.算法的复杂性：（如下图） <img src="https://img-blog.csdnimg.cn/20200216212540588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump5">9.2.3排序用到的结构与函数</span><br>
1.排序用到的顺序表结构：</p>
<pre><code class="language-cpp">#define MAXSIZE 10     //用于要排序数组个数最大值，可根据需要修改
typedef struct         
{
	int r[MAXSIZE+1];     //用于存储要排序的数组，r[0]用作哨兵或临时变量
	int length;           //用于记录顺序表长度
}SqList;    
</code></pre>
<p>2.排序所用到的交换函数</p>
<pre><code class="language-cpp">//交换L中数组r的下标为i和j的值
void swap(SqList *L,int i,int j)
{
	int temp=L-&gt;r[i];
	L-&gt;r[i]=L-&gt;r[j];
	L-&gt;r[j]=temp;
}
</code></pre>
<p><span id="jump6">9.3冒泡排序</span><br>
      <span id="jump7">9.3.1最简单的排序实现</span></p>
<blockquote>
<p>冒泡排序一种交换排序，它的基本思想：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做交换排序（冒泡排序初级版）
void BubbleSort0(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=i+1; j&lt;=L-&gt;length; j++)
		{
			if(L-&gt;r[i]&gt;L-&gt;r[j])
			{
				swap(L,i,j);    //交换L-&gt;r[i]与L-&gt;r[j]的值
			}
		}
	}
}//详见代码如下图
</code></pre>
<blockquote>
<p>上述代码的思路：让每一关键字，都和它后面的每一个关键字比较，如果前面的大于后面的，则交换，这样第一位置的关键字在一次循环后一定是最小的<br>
上述代码缺陷：每次只能一个一个去排列，这样对其余关键字没有任何帮助<br>
<img src="https://img-blog.csdnimg.cn/20200218214434373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>      <span id="jump8">9.3.2冒泡排序算法</span></p>
<blockquote>
<p>此冒泡排序的思想：i从第一个位置开始，然后j从最后向前冒泡，不断地将小的值放到前面，这样不断的循环下去，便于将一部分小的数值移动一些位置</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做冒泡排序
void BubbleSort(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=L-&gt;length-1; j&gt;=i; j--)     //注意j是从后往前循环
		{
			if(L-&gt;r[j]&gt;L-&gt;r[j+1])   //若前者大于后者
			{
				swap(L,j,j+1);   //交换L-&gt;r[j]与L-&gt;r[j+1]的值
			}
		}
	}
}//详见代码如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200218214549665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200218214604810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump9">9.3.3冒泡排序优化</span></p>
<blockquote>
<p>为什么要有冒泡排序的优化？如下图中，如果不优化，还要不断地进行比较，浪费时间</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200218215111503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-cpp">//对顺序表L做改进冒泡算法
void BubbleSort2(SqList *L)
{
	int i,j;
	Status flag=TRUE;     //flag用来作为标记
	for(i=1; i&lt;L-&gt;length &amp;&amp; flag; i++)    //若flag为false则循环结束
	{
		flag=FALSE;    //初始为false
		for(j=L-&gt;length-1; j&gt;=i; j--)
		{
			if(L-&gt;r[j] &gt; L-&gt;[j+1])
			{
				swap(L,j,j+1);    //交换L-&gt;r[j]与L-&gt;r[j+1]的值
				flag=TRUE;       //如果有数据交换，则flag改true
			}
		}
	}
}//详见如下图：
</code></pre>
<blockquote>
<p>此代码的思想是：加入一个flag判断，flag初始值为TRUE，进入循环后如果后面循环中一但有交换则改flag值为TRUE，再次循环；如果循环中已经是升序排列，不会有前面的值大于后面的值，则flag为false，循环结束</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200218215911799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump10">9.3.4冒泡排序复杂度分析</span><br>
最好情况是o(n)<br>
最坏情况是o(n^2)</p>
<p><span id="jump11">9.4简单选择排序</span></p>
<p>      <span id="jump12">9.4.1简单选择排序算法</span></p>
<blockquote>
<p>简单选择排序的思想：从第一个位置开始，循环找到后面的最小值，然后与第一个位置的值进行交换，如此进行下去，则就是简单选择排序</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做简单选择排序
void SelectSort(SqList *L)
{
	int i,j,min;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		min=i;       //将当前下标定义为最小值下标
		for(j=i+1; j&lt;=L-&gt;length; j++)   //循环之后的数据
		{	
			if(L-&gt;r[min]&gt;L-&gt;r[j])   //如果有小于当前最小值的关键字
				min=j;         //将此关键字的下标赋值给min
		}
		if(i!=min)                     //若min不等于i，说明找到最小值了，交换
			swap(L,i,min);    //交换L-&gt;r[i]与L-&gt;r[min]的值
	}
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200218221732154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">9.4.2简单选择排序复杂度分析</span></p>
<blockquote>
<p>1.对上面代码中第二层的for（就是找最小值下标）的那个代码而言，对第一个值其比较次数为n-1，对于第2个值而言，其比较次数为n-2，则一共的比较次数为n(n-1)/2，后面中就是交换次序的代码，最坏情况需要交换n-1次，则一共的时间复杂度为o(n^2)</p>
</blockquote>
<p><span id="jump14">9.5直接插入排序</span><br>
      <span id="jump15">9.5.1 直接插入排序算法</span></p>
<blockquote>
<p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L作直接插入操作
void InsertSort(SqList *L)
{
	int i,j;
	for(i=2; i&lt;=L-&gt;length; i++)
	{
		if(L-&gt;r[i]&lt;L-&gt;r[i-1])          //需将L-&gt;r[i]插入有序子表
		{
			L-&gt;r[0]=L-&gt;r[i];            //设置哨兵
			for(j=i-1; L-&gt;r[j]&gt;L-&gt;r[0]; j--)
				L-&gt;r[j+1]=L-&gt;r[j];              //记录后移
			L-&gt;r[j+1]=L-&gt;r[0];            //插入到正确位置
		}
	}
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200220223032274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022022305317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump16">9.5.2直接插入排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/20200220224148149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200220224207118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump17">9.6希尔排序</span></p>
<p>      <span id="jump18">9.6.1希尔排序原理</span></p>
<blockquote>
<p>1.希尔排序就是为了突破O(n^2)的时间复杂度，思想就是每次循环一次后都将原来的数组排序成基本有序（P.S.基本有序就是大的数字基本在后面，小的数字基本在前面，不大不小的基本在中间）<br>
2.采用的是跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在自序列内分别进行直接插入排序后得到的结果时基本有序而不是局部有序</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200223211404857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump19">9.6.2 希尔排序算法</span></p>
<pre><code class="language-cpp">//对顺序表L做希尔排序
void ShellSort(SqList *L)
{
	int i,j;
	int increment=L-&gt;length;
	do
	{
		increment=increment/3+1;    //增量序列
		for(i=increment+1; i&lt;=L-&gt;length; i++)
		{
			if(L-&gt;r[i]&lt;L-&gt;r[i-increment])
			{//需将L-&gt;r[i]插入有序增量子表中
				L-&gt;r[0]=L-&gt;r[i];          //暂存到L-&gt;r[0]
				for(j=i-increment; j&gt;0 &amp;&amp; L-&gt;r[0]&lt;L-&gt;r[j]; j-=increment)
					L-&gt;r[j+increment]=L-&gt;r[j];        //记录向后移，查找插入位置
				L-&gt;r[j+increment]=L-&gt;r[0];          //插入
			}
		}
	}while(increment&gt;1);
}//详见如下图
</code></pre>
<p>1.待排数组<br>
<img src="https://img-blog.csdnimg.cn/20200223212218854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212236540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212256717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212313899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022321294273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump20">9.6.3希尔排序时间复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度为O(n^3/2)，要直接好于O(n的平方)<br>
2.增量序列的最后一个增量值必须等于1才行</p>
</blockquote>
<p><span id="jump21">9.8归并排序</span></p>
<blockquote>
<p>说白了就是对数组进行两两合并，详见下图</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224212407189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump22">9.8.1归并排序算法</span></p>
<blockquote>
<p>归并排序的原理，见下图：</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/2020022421255582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>总的归并排序代码：</p>
<pre><code class="language-cpp">//对顺序表L做归并排序
void MergeSort(SqList *L)
{
	MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);
}

</code></pre>
<blockquote>
<p>上述代码，为了和前面的排序算法统一，用了同样的参数定义SqList *L，MSort的代码实现如下：</p>
</blockquote>
<p>递归拆分代码：</p>
<pre><code class="language-cpp">void MSort(int SR[], int TR1[], int s, int t)  //SR[]数组相当于原始数组，TR1[]相当于排好序的数组
{
	int m;
	int TR2[MAXSIZE+1];
	if(s==t)
		TR1[s]=SR[s];    
	else
	{
		m=(s+t)/2;     //相当于从中间开始分
		MSort(SR,TR2,s,m);    //将原始数组SR[]的前半部分递归到TR2[]中
		MSort(SR,TR2,m+1,t);     //将原始数组SR的后半部分放到TR2[]中
		Merge(TR2,TR1,s,m,t);   //将TR2[]递归到已排好序的数组TR1[]中
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224213548144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224213607291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022421364571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Merge函数如何实现（归并算法）：</p>
<pre><code class="language-cpp">//将数组直接归并为有序的
void Merge(int SR[], int TR[], int i,int m,int n)
{
	int j,k,l;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j&lt;=n; k++)   //将SR中记录有小到大归并入TR中
	{
		if(SR[i]&lt;SR[j])
			TR[k]=SR[i++];
		else
			TR[k]=SR[j++];
	}
	if(i&lt;=m)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=m-i; l++)
			TR[K+l]=SR[i+1];
	}
	if(j&lt;=n)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=n-j; l++)
			TR[k+l]=SR[j+l];
	}
} //详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224214436361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224214448493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump23">9.8.2 归并排序复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度分析：<br>
对于上面那个merge函数中，将原始数列SR[]放入到TR1[]中，由于要遍历循环所有的记录所以时间复杂度为O(n)，而由完全二叉树的深度可知，整个总的归并排序需要进行log2n次，总的时间复杂度为O(nlogn)<br>
2.空间复杂度分析：<br>
由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，所以空间复杂度为o(n)。同时还有递归时深度为log2n的栈空间，因此空间复杂度为O(n+logn)<br>
3.Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明他需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法</p>
</blockquote>
<p>      <span id="jump24">9.8.3 非递归实现归并排序</span></p>
<p>直接进行归并排序代码如下：</p>
<pre><code class="language-cpp">//对顺序表L作归并非递归排序
void MergeSort2(SqList *L)
{
	int* TR=(int *) malloc (L-&gt;length*sizeof(int));    //申请额外空间
	int k=1;
	while(k&lt;L-&gt;length)
	{
		MergePass(L-&gt;r,TR,k,L-&gt;length);
		k=2*k;                           //子序列长度加倍
		MergePass(TR,L-&gt;r,k,L-&gt;length);
	    k=2*k;                    	//子序列长度加倍
	}
} //详见代码如下图：

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200224215853578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<table><tr><td bgcolor=GreenYellow>非递归算法和递归算法的区别</td></tr></table>
<blockquote>
<p>1.非递归算法：对数组直接归并<br>
2.递归算法： 先递归拆分数组然后再归并退出递归</p>
</blockquote>
<p>上面的MergePass（归并排序）代码如下：</p>
<pre><code class="language-cpp">void MergePass(int SR[],int TR[],int s,int n)
{
	int i=1;
	int j;
	while(i&lt;=n-2*s+1)
	{
		Merge(SR,TR,i,i+s-1,i+2*s-1);       //两两归并
		i=i+2*s;
	}
	if(i&lt;n-s+1)         //归并最后两个序列
		Merge(SR,TR,i,i+s-1,n);
	else
		for(j=i; j&lt;=n; j++)
			TR[j]=SR[j];
}//详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224220712223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224220724375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>非递归归并排序的时间复杂度如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200224220803431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump25">9.7堆排序算法</span></p>
<blockquote>
<p>大顶堆+小顶堆如下图：</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202002242213116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>如果按照层序遍历的方式给结点从1开始编号，有如下关系：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224221455607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224221554850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>将大顶堆和小顶堆用层序遍历存入数组，如下图：</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200224221707148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump26">9.7.1堆排序算法</span></p>
<blockquote>
<p>堆排序的基本思想如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022422185751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022422191275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
堆排序的整体代码：</p>
<pre><code class="language-cpp">//对顺序表L进行堆排序
void HeapSort(SqList *L)
{
	int i;
	for(i=L-&gt;length/2; i&gt;0; i--)         //将原来的数组构建为一个大顶堆
		HeapAdjust(L,i,L-&gt;length);
	
	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224222615378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224222629819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
上述代码中HeapAdjust函数如何实现：</p>
<pre><code class="language-cpp">void HeapAdjust(SqList *L,int s,int m)
{
	int temp,j;
	temp=L-&gt;r[s];
	for(j=2*s; j&lt;=m; j*=2)   //沿关键字较大的孩子结点向下筛选
	{
		if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])
			++j;            //j为关键字中较大的记录的下标
		if(temp&gt;L-&gt;r[j])
			break;
		L-&gt;r[s]=L-&gt;r[j];
		s=j;
	}
	L-&gt;r[s]=temp;   //插入
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224223320292.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223337424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223348267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223402125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
接下来就是HeapSort函数中正式的排序过程</p>
<pre><code class="language-cpp">	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}//详见如下图：

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200224223738871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump27">9.7.2堆排序复杂度分析</span></p>
<blockquote>
<p>1.在第一次构建堆的过程中，时间复杂度如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224224117512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224224130379.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.在正式排序的过程中，时间复杂度如下：</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200224224223924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump28">9.9快速排序</span></p>
<blockquote>
<p>1.希尔排序相当于直接插入排序的升级，他们都属于插入排序类<br>
2.堆排序相当于简单选择排序的升级，他们都属于选择排序类<br>
3.快速排序就是冒泡排序的升级，他们都属于交换排序类</p>
</blockquote>
<p>       <span id="jump29">9.9.1快速排序算法</span></p>
<blockquote>
<p>快速思想的思想，如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200225113932704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
快速排序的代码：</p>
<pre><code class="language-cpp">void QuickSort(SqList *L)
{
	QSort(L,1,L-&gt;length);
}

</code></pre>
<p>QSort函数的代码：</p>
<pre><code class="language-cpp">//对顺序表L中的子序列做快速排序
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if(low&lt;high)
	{
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200225114522383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>上述代码中Partition函数（将原始数组一分为2的数组）如下：</p>
<pre><code class="language-cpp">//交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
//此时在他之前的记录均不大于他，在后面的记录均不小于他
int Partition(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		swap(L,low,high);                 //将比枢轴记录小的记录交换到低端
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		swap(L,low,high);                      //将比枢轴记录大的记录交换到高端
	}
	return low;              //返回枢轴所在位置
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200225115335261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115345893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115359275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump30">9.9.2快速排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/202002251156198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115918926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002251159399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump31">9.9.3快速排序优化</span><br>
               1.优化选取枢轴<br>
                         1.为啥要优化选取枢轴？<br>
<img src="https://img-blog.csdnimg.cn/20200225120248306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225120308181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>                         2.三数取中法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200225120455867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在Partition函数中的第3行与第4行之间加上如下代码：</p>
<pre><code class="language-csharp">3 int Pivotkey;
	int m=low+(high-low)/2;           //计算数组中间的元素的下标
	if(L-&gt;r[low]&gt;L-&gt;r[high])
		swap(L,low,high);        //交换左端与右端，保证左端较小
	if(L-&gt;r[m]&gt;L-&gt;r[high])
		swap(L,high,m);             //交换中间与右端数据，保证中间较小
	if(L-&gt;r[m]&gt;L-&gt;r[low])
		swap(L,m,low);               //交换中间与左端数据，保证左端较小
	//此时L.r[low]已经是整个序列做左中右三个关键字的中间值
4 pivotkey=L-&gt;r[low];          //还是用子表的第一个记录做枢轴记录
//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022512114547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
                         3.优化不必要的交换：<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225121325776.png" alt="在这里插入图片描述" loading="lazy"><br>
2.详细代码：</p>
<pre><code class="language-cpp">//快速排序优化算法
int Partition1(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	//这里省略三数取中的代码
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	L-r[0]=L-&gt;r[high];              //增加1：叫枢轴关键字备份到L-&gt;r[0]
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		L-&gt;r[low]=L-&gt;r[high];              //增加2：采用的是替换而不是交换
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		L-&gt;r[high]=L-&gt;r[low];        //增加3：采用的是替换而不是交换
	}
	L-&gt;r[low]=L-&gt;r[0];              //增加4：将枢轴数值替换回L.r[low]
	return low;              //返回枢轴所在位置

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200225122008154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         4.优化小数组的排序方案<br>
1.原因如下：<br>
<img src="https://img-blog.csdnimg.cn/20200225122148402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.详见代码：</p>
<pre><code class="language-cpp">#define MAX_LENGTH_INSERT_SORT 7            //数组长度阈值
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200225122542336.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         5.优化递归的操作<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225122706361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
于是对QSort进行尾递归操作：</p>
<pre><code class="language-cpp">void QSort1(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		while(low&lt;high)
		{
			pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
			QSort1(L,low,pivot-1);             //对低字表递归排序
			low=pivot+1;              //尾递归			
		}

	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200225123002786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第五章笔记（串）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/">
        </link>
        <updated>2020-03-01T04:20:53.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">5.2 串的相关概念</a><br>
<a href="#jump2">5.3串的比较：</a><br>
<a href="#jump3">5.4串的数据结构</a><br>
<a href="#jump4">5.4.1index的操作（取主串中，与子串相同的字符串的第一个字符的位置）</a><br>
<a href="#jump5">串的顺序存储结构：</a><br>
<a href="#jump6">串的链式存储结构：没有占满的位置，可以用其他非字符替代</a><br>
<a href="#jump7">5.6朴素的模式匹配法：</a><br>
<a href="#jump8">朴素算法的时间复杂度：</a><br>
<a href="#jump9">5.7KMP模式匹配法</a><br>
<a href="#jump10">kmp算法的时间复杂度分析：</a><br>
<a href="#jump11">5.7.4kmp模式匹配算法的改进</a><br>
<a href="#jump12">5.7.4 kmp算法的改进</a></p>
<p><span id="jump1">5.2 串的相关概念</span><br>
1.串是由零个或多个字符组成的有限序列，又名叫字符串。<br>
2.串中的字符数目n称为串的长度。<br>
3.零个字符的串称为空串，它的长度为0，也可以直接用双引号&quot;&quot;直接括起来。<br>
4.空格串，是包含空格的串。空格串是有长度的，而且可以不止一个空格。<br>
5.子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。<br>
6.子串在主串中的位置就是子串的第一个字符在主串中的序号</p>
<p><span id="jump2">5.3串的比较：</span><br>
1.将两个字符串都从左至右对齐，然后开始比较，字符串的数量可以不同，比较字符串时一一对应，按照ascii码的方式，字母在前的小，到第一个不同字母比较完之后就完。</p>
<p><span id="jump3">5.4串的数据结构：</span></p>
<pre><code class="language-cpp">ADT 串（string）
Data 
	串中元素仅有一个字符组成，相邻的元素具有前驱和后继关系
Operation
	StrAssign (T,*chars): 生成一个其值等于字符串的常量chars的串T
	StrCopy (T,S):串S存在，由串S复制得到串
	ClearString(S): 串s存在，将串清空
	StringEmpty(S):若串S为空，返回true，否则返回false
	StrLength(S):返回串中的元素个数，即串的长度
	StrCompare(S,T):若S&gt;T,返回值&gt;0,若S=T，返回0，若S&lt;T,返回值&lt;0
	Concat(T,S1,S2):用T返回又S1和S2链接而成的新串
	SubString (Sub,S,pos,len):  串s存在，1&lt;=pos&lt;=StrLength(S),且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符起长度为len的子串
	Index (S,T,pos): 串S和T存在，T是非空串, 1&lt;=pos&lt;=StrLength(S)
					若主串S中存在和串T值相同的子串，则返回它在主串S中
					 第pos个字符之后第一次出现的位置，否则返回0
	Replace(S,T,V):  串S,T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重复的子串
	StrInsert(S,pos,T):  串S和T存在，1&lt;=pos&lt;=Strlength(S)+1
						在串S的第pos个字符之前插入串T
	Strlength(S,pos,len): 串S存在，1&lt;=pos&lt;=Strlength(S)-len+1
						`  从串S中删除第pos个字符起长度为len的子串
endADT
</code></pre>
<p><span id="jump4">5.4.1index的操作（取主串中，与子串相同的字符串的第一个字符的位置）</span></p>
<pre><code class="language-cpp">/*T为非空串。若主串s中第pos个字符之后存在于T相等的子串*/
/*则返回第一个这样的子串在S中的位置，否则返回0*/
int Index(String S, String T, int pos)
{
	int n,m,i;
	String sub;
	if(pos&gt;0)
	{
		n=StrLength(S);
		m=Strlength(T);
		i=pos;           //刚开始这个pos不是要所要的位置，不知道也不必说
		while(i &lt;= n-m+1)   //见下图有这代码的解释
		{
			SubString(sub,S,i,m);     //取主串第i个位置
										//长度与T相等子串给sub
			if(StrCompare(sub, T) !=0 )   //如果两个串不相等
				++i;
			else                  //如果两串相等
				return i;  			//则返回i值
		}
		
	}
	return 0;    //若无子串与T相等，返回0
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191227210942916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump5">串的顺序存储结构：</span><br>
<img src="https://img-blog.csdnimg.cn/20191227211456716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump6">串的链式存储结构：没有占满的位置，可以用其他非字符替代</span><br>
<img src="https://img-blog.csdnimg.cn/20191227211514657.png" alt="在这里插入图片描述" loading="lazy"><br>
、</p>
<p><span id="jump7">5.6朴素的模式匹配法：</span></p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//T非空，1&lt;=pos&lt;=Strlength(S)
int Index(String S, String T, int pos)
{
	int i=pos;        //i主要用于主串s中当前位置的下标，若pos不为1
						//则从pos位置开始匹配
	int	j=1;					 //j用于子串T中当前位置下标值
	while(i &lt;= S[0] &amp;&amp; j &lt;= T[0])    //若i小于s长度且j小于T的长度时循环
	{
		if(S[i] == T[j])      //两个字母相等则继续
		{
			++i;
			++j;
		}
		else        //指针后退重新开始匹配
		{
			i=i-j+2;    //i退回到上次匹配首位的下一位,详细看下图1处
			j=1;     //j退回到子串T的首位
		}
	}
	if(j&gt;T[0])   //上面的while结束有两种情况，i&gt;S[0] 或者  j&gt;T[0] 当i&gt;S[0]一定没有对应的字符串匹配，当j&gt;T[0]时，表示走完了字串，找到了相对应的
		return i-T[0];      //详细看下图2处
	else
		return 0;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191227220444240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump8">朴素算法的时间复杂度：</span><br>
<img src="https://img-blog.csdnimg.cn/20191229233628356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191229233657400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump9">5.7KMP模式匹配法</span><br>
1.kmp算法的普遍理解：如下图，kmp算法的使用前提是T串中的首字符a与后面的均不相等，由于a到e子串T与主串S都对应相同，所以下一次直接比较a与f即可，这便是kmp的引入<br>
<img src="https://img-blog.csdnimg.cn/20191230202900263.png" alt="在这里插入图片描述" loading="lazy"><br>
2.实际上，j的回溯位置的变化与主串S没有什么关系，主要是看子串T中是否有相同的字符，如下图中不用在比较a,b,<br>
j从6回溯到j=3<br>
<img src="https://img-blog.csdnimg.cn/20191230203551303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关于j的回溯的数组next的原理：如下图<br>
<img src="https://img-blog.csdnimg.cn/20191230203909316.png" alt="在这里插入图片描述" loading="lazy"><br>
这里对于5这个位置下要看前4个字符，第一个a与最后一个a相同，相同字母只有一个，所以5下就写2<br>
这里对于6这个位置下要看前5个字符，前两个字符ab与最后两个字符ab完全相同，所以6下就写3<br>
如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191230204256407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
j回溯位置下标的数组：</p>
<pre><code class="language-cpp">//通过计算返回子串T的next数组
void get_next (String T, int *next)
{
	int i,j;
	i=1;             
	j=0;               
	next[1]=0;
	while(i&lt;T[0])        //此处T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])
		{
			++i;
			++j;
			next[i]=j;       //将j回溯的位置保存到next中
		}
		else
			j=next[j];          //j回溯到对应位置
	}
}
</code></pre>
<p>下面是KMP的整体代码：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
int Index_KMP(String S, String T, int pos)
{
	int i=pos;       //i就是那里的代码值不同就从哪里开始，如图5-7-3 i为6就从6开始
	int j=1;       //j用于当前位置中下标值
	int next[255];    //定义一next数组
	get_next(T,next);   //对串做分析，得到next数组
	while(i &lt;= s[0] &amp;&amp; j &lt;= T[0])   //若i小于s的长度且j小于且小于T的长度时，循环继续
	{
		if(j==0 || s[i]==T[j])    //两个字母相等则继续，相对于朴素算法增加了j=0判断
		{
			++i;
			++j;
		}
		else
		{
			j=next[j];    //如果字母不相同，则j的值回溯
		}
	}
	
//后面两行代码和朴素算法相同
	if(j&gt;T[0])    
		return i-T[0];
	else
		return 0;
	
}
</code></pre>
<p><span id="jump10">kmp算法的时间复杂度分析：</span><br>
在这里，创建next数组时间复杂度为o(m)，后面的时间复杂度为o(n)，则整体的时间复杂度为o(m+n)<br>
kmp的核心思路：如果子串中一前一后有相同的字符，后面的字符不管与主串中是相同还是不同，对于前面的字符在往后走时不用在与之前</p>
<p><span id="jump11">5.7.4kmp模式匹配算法的改进</span></p>
<pre><code class="language-cpp">//求模式串T的next函数修正值并存入数组nextval，整个nextval还是以计算next的方法来构建，区别在于数值不同，目的就是减少j的回溯次数，以减少复杂度
void get_nextval(String T, int *nextval)
{
	int i,j;
	i=1;
	j=0;
	nextval[1]=0;
	while(i&lt;T[0])           //T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])       //T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
		{
			++i;
			++j;
/* 这里的代码是改进后不同于之前的next算法
			if(T[i]!=T[j])   //若当前字符与前缀字符不同
				nextval[i]=j;		//就将next中的值给nextval
			else
				nextval[i]=nextval[j];  //字符相同,nextval与之前相同字符所对应的nextval值相同
*/
		}
		else
			j=nextval[j];      //相当于计算next数组中的值，只是改了个名，就这样理解
	}
}
</code></pre>
<p><span id="jump12">5.7.4 kmp算法的改进</span><br>
1.相对于之前的kmp算法j的回溯位置变化太多，而改进后，j回溯的变化位置不多，这里应该是T中有太多连续字符相同的情况下<br>
next数组中，数字不同的程度与j回溯到不同位置的次数成正比，数字越复杂，回溯的次数越多，时间复杂度越大。<br>
2.nextval[]数组变化是：第一数组值为0，往后每一个数组值，如果串中的字符与next数组中对应位置的字符相同，则nextval中的值也与对应位置的nextval相同，如果不同则nextval值就是next值<br>
<img src="https://img-blog.csdnimg.cn/20191230223215549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
</feed>