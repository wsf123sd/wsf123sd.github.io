<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wsf123sd.github.io/</id>
    <title>Gridea</title>
    <updated>2020-03-01T04:24:36.808Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wsf123sd.github.io/"/>
    <link rel="self" href="https://wsf123sd.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wsf123sd.github.io/images/avatar.png</logo>
    <icon>https://wsf123sd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[大话数据结构第九章笔记（排序）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/">
        </link>
        <updated>2020-03-01T04:22:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">9.1开场白</a><br>
<a href="#jump2">9.2排序的基本概念和分类</a><br>
      <a href="#jump3">9.2.1排序的稳定性</a><br>
      <a href="#jump4">9.2.2内排序与外排序</a><br>
      <a href="#jump5">9.2.3排序用到的结构与函数</a><br>
<a href="#jump6">9.3冒泡排序</a><br>
      <a href="#jump7">9.3.1最简单排序实现</a><br>
      <a href="#jump8">9.3.2冒泡排序算法</a><br>
      <a href="#jump9">9.3.3冒泡排序优化</a><br>
      <a href="#jump10">9.3.4冒泡排序复杂度分析</a></p>
<p><a href="#jump11">9.4简单选择排序</a><br>
      <a href="#jump12">9.4.1简单选择排序算法</a><br>
      <a href="#jump13">9.4.2简单选择排序复杂度分析</a></p>
<p><a href="#jump14">9.5直接插入排序</a><br>
      <a href="#jump15">9.5.1直接插入排序算法</a><br>
      <a href="#jump16">9.5.2直接插入排序复杂度分析</a></p>
<p><a href="#jump17">9.6直接插入排序</a><br>
      <a href="#jump18">9.6.1希尔排序原理</a><br>
      <a href="#jump19">9.6.2希尔排序算法</a><br>
      <a href="#jump20">9.6.3希尔排序复杂度分析</a></p>
<p><a href="#jump21">9.8 归并排序</a><br>
      <a href="#jump22">9.8.1归并排序算法</a><br>
      <a href="#jump23">9.8.2归并排序复杂度分析</a><br>
      <a href="#jump24">9.8.3非递归实现归并排序</a></p>
<p><a href="#jump25">9.7堆排序</a><br>
      <a href="#jump26">9.7.1堆排序算法</a><br>
      <a href="#jump27">9.7.2堆排序复杂度分析</a></p>
<p><a href="#jump28">9.9快速排序</a><br>
      <a href="#jump29">9.9.1快速排序算法</a><br>
      <a href="#jump30">9.9.2快速排序复杂度分析</a><br>
      <a href="#jump31">9.9.3快速排序优化</a></p>
<p><span id="jump2">9.2排序的基本概念和分类</span><br>
1.排序就是将无序的数据集合，按照某一定顺序进行排列<br>
2.对于有很多关键字的排序，可以将多个关键字的排序转化成单个关键字的排序，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200216211522213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021621153480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump3">9.2.1排序的稳定性</span><br>
如图：<br>
<img src="https://img-blog.csdnimg.cn/20200216211947313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump4">9.2.2内排序与外排序</span><br>
     1.什么叫内排序，外排序：（如下图）</p>
<p><img src="https://img-blog.csdnimg.cn/20200216212209422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     2.排序算法的性能主要是受3个方面影响：</p>
<p>            1.时间性能：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/20200216212512766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            2.辅助空间：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/2020021621252762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            3.算法的复杂性：（如下图） <img src="https://img-blog.csdnimg.cn/20200216212540588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump5">9.2.3排序用到的结构与函数</span><br>
1.排序用到的顺序表结构：</p>
<pre><code class="language-cpp">#define MAXSIZE 10     //用于要排序数组个数最大值，可根据需要修改
typedef struct         
{
	int r[MAXSIZE+1];     //用于存储要排序的数组，r[0]用作哨兵或临时变量
	int length;           //用于记录顺序表长度
}SqList;    
</code></pre>
<p>2.排序所用到的交换函数</p>
<pre><code class="language-cpp">//交换L中数组r的下标为i和j的值
void swap(SqList *L,int i,int j)
{
	int temp=L-&gt;r[i];
	L-&gt;r[i]=L-&gt;r[j];
	L-&gt;r[j]=temp;
}
</code></pre>
<p><span id="jump6">9.3冒泡排序</span><br>
      <span id="jump7">9.3.1最简单的排序实现</span></p>
<blockquote>
<p>冒泡排序一种交换排序，它的基本思想：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做交换排序（冒泡排序初级版）
void BubbleSort0(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=i+1; j&lt;=L-&gt;length; j++)
		{
			if(L-&gt;r[i]&gt;L-&gt;r[j])
			{
				swap(L,i,j);    //交换L-&gt;r[i]与L-&gt;r[j]的值
			}
		}
	}
}//详见代码如下图
</code></pre>
<blockquote>
<p>上述代码的思路：让每一关键字，都和它后面的每一个关键字比较，如果前面的大于后面的，则交换，这样第一位置的关键字在一次循环后一定是最小的<br>
上述代码缺陷：每次只能一个一个去排列，这样对其余关键字没有任何帮助<br>
<img src="https://img-blog.csdnimg.cn/20200218214434373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>      <span id="jump8">9.3.2冒泡排序算法</span></p>
<blockquote>
<p>此冒泡排序的思想：i从第一个位置开始，然后j从最后向前冒泡，不断地将小的值放到前面，这样不断的循环下去，便于将一部分小的数值移动一些位置</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做冒泡排序
void BubbleSort(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=L-&gt;length-1; j&gt;=i; j--)     //注意j是从后往前循环
		{
			if(L-&gt;r[j]&gt;L-&gt;r[j+1])   //若前者大于后者
			{
				swap(L,j,j+1);   //交换L-&gt;r[j]与L-&gt;r[j+1]的值
			}
		}
	}
}//详见代码如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200218214549665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200218214604810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump9">9.3.3冒泡排序优化</span></p>
<blockquote>
<p>为什么要有冒泡排序的优化？如下图中，如果不优化，还要不断地进行比较，浪费时间</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200218215111503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-cpp">//对顺序表L做改进冒泡算法
void BubbleSort2(SqList *L)
{
	int i,j;
	Status flag=TRUE;     //flag用来作为标记
	for(i=1; i&lt;L-&gt;length &amp;&amp; flag; i++)    //若flag为false则循环结束
	{
		flag=FALSE;    //初始为false
		for(j=L-&gt;length-1; j&gt;=i; j--)
		{
			if(L-&gt;r[j] &gt; L-&gt;[j+1])
			{
				swap(L,j,j+1);    //交换L-&gt;r[j]与L-&gt;r[j+1]的值
				flag=TRUE;       //如果有数据交换，则flag改true
			}
		}
	}
}//详见如下图：
</code></pre>
<blockquote>
<p>此代码的思想是：加入一个flag判断，flag初始值为TRUE，进入循环后如果后面循环中一但有交换则改flag值为TRUE，再次循环；如果循环中已经是升序排列，不会有前面的值大于后面的值，则flag为false，循环结束</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200218215911799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump10">9.3.4冒泡排序复杂度分析</span><br>
最好情况是o(n)<br>
最坏情况是o(n^2)</p>
<p><span id="jump11">9.4简单选择排序</span></p>
<p>      <span id="jump12">9.4.1简单选择排序算法</span></p>
<blockquote>
<p>简单选择排序的思想：从第一个位置开始，循环找到后面的最小值，然后与第一个位置的值进行交换，如此进行下去，则就是简单选择排序</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做简单选择排序
void SelectSort(SqList *L)
{
	int i,j,min;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		min=i;       //将当前下标定义为最小值下标
		for(j=i+1; j&lt;=L-&gt;length; j++)   //循环之后的数据
		{	
			if(L-&gt;r[min]&gt;L-&gt;r[j])   //如果有小于当前最小值的关键字
				min=j;         //将此关键字的下标赋值给min
		}
		if(i!=min)                     //若min不等于i，说明找到最小值了，交换
			swap(L,i,min);    //交换L-&gt;r[i]与L-&gt;r[min]的值
	}
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200218221732154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">9.4.2简单选择排序复杂度分析</span></p>
<blockquote>
<p>1.对上面代码中第二层的for（就是找最小值下标）的那个代码而言，对第一个值其比较次数为n-1，对于第2个值而言，其比较次数为n-2，则一共的比较次数为n(n-1)/2，后面中就是交换次序的代码，最坏情况需要交换n-1次，则一共的时间复杂度为o(n^2)</p>
</blockquote>
<p><span id="jump14">9.5直接插入排序</span><br>
      <span id="jump15">9.5.1 直接插入排序算法</span></p>
<blockquote>
<p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L作直接插入操作
void InsertSort(SqList *L)
{
	int i,j;
	for(i=2; i&lt;=L-&gt;length; i++)
	{
		if(L-&gt;r[i]&lt;L-&gt;r[i-1])          //需将L-&gt;r[i]插入有序子表
		{
			L-&gt;r[0]=L-&gt;r[i];            //设置哨兵
			for(j=i-1; L-&gt;r[j]&gt;L-&gt;r[0]; j--)
				L-&gt;r[j+1]=L-&gt;r[j];              //记录后移
			L-&gt;r[j+1]=L-&gt;r[0];            //插入到正确位置
		}
	}
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200220223032274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022022305317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump16">9.5.2直接插入排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/20200220224148149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200220224207118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump17">9.6希尔排序</span></p>
<p>      <span id="jump18">9.6.1希尔排序原理</span></p>
<blockquote>
<p>1.希尔排序就是为了突破O(n^2)的时间复杂度，思想就是每次循环一次后都将原来的数组排序成基本有序（P.S.基本有序就是大的数字基本在后面，小的数字基本在前面，不大不小的基本在中间）<br>
2.采用的是跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在自序列内分别进行直接插入排序后得到的结果时基本有序而不是局部有序</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200223211404857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump19">9.6.2 希尔排序算法</span></p>
<pre><code class="language-cpp">//对顺序表L做希尔排序
void ShellSort(SqList *L)
{
	int i,j;
	int increment=L-&gt;length;
	do
	{
		increment=increment/3+1;    //增量序列
		for(i=increment+1; i&lt;=L-&gt;length; i++)
		{
			if(L-&gt;r[i]&lt;L-&gt;r[i-increment])
			{//需将L-&gt;r[i]插入有序增量子表中
				L-&gt;r[0]=L-&gt;r[i];          //暂存到L-&gt;r[0]
				for(j=i-increment; j&gt;0 &amp;&amp; L-&gt;r[0]&lt;L-&gt;r[j]; j-=increment)
					L-&gt;r[j+increment]=L-&gt;r[j];        //记录向后移，查找插入位置
				L-&gt;r[j+increment]=L-&gt;r[0];          //插入
			}
		}
	}while(increment&gt;1);
}//详见如下图
</code></pre>
<p>1.待排数组<br>
<img src="https://img-blog.csdnimg.cn/20200223212218854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212236540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212256717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212313899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022321294273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump20">9.6.3希尔排序时间复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度为O(n^3/2)，要直接好于O(n的平方)<br>
2.增量序列的最后一个增量值必须等于1才行</p>
</blockquote>
<p><span id="jump21">9.8归并排序</span></p>
<blockquote>
<p>说白了就是对数组进行两两合并，详见下图</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224212407189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump22">9.8.1归并排序算法</span></p>
<blockquote>
<p>归并排序的原理，见下图：</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/2020022421255582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>总的归并排序代码：</p>
<pre><code class="language-cpp">//对顺序表L做归并排序
void MergeSort(SqList *L)
{
	MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);
}

</code></pre>
<blockquote>
<p>上述代码，为了和前面的排序算法统一，用了同样的参数定义SqList *L，MSort的代码实现如下：</p>
</blockquote>
<p>递归拆分代码：</p>
<pre><code class="language-cpp">void MSort(int SR[], int TR1[], int s, int t)  //SR[]数组相当于原始数组，TR1[]相当于排好序的数组
{
	int m;
	int TR2[MAXSIZE+1];
	if(s==t)
		TR1[s]=SR[s];    
	else
	{
		m=(s+t)/2;     //相当于从中间开始分
		MSort(SR,TR2,s,m);    //将原始数组SR[]的前半部分递归到TR2[]中
		MSort(SR,TR2,m+1,t);     //将原始数组SR的后半部分放到TR2[]中
		Merge(TR2,TR1,s,m,t);   //将TR2[]递归到已排好序的数组TR1[]中
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224213548144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224213607291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022421364571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Merge函数如何实现（归并算法）：</p>
<pre><code class="language-cpp">//将数组直接归并为有序的
void Merge(int SR[], int TR[], int i,int m,int n)
{
	int j,k,l;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j&lt;=n; k++)   //将SR中记录有小到大归并入TR中
	{
		if(SR[i]&lt;SR[j])
			TR[k]=SR[i++];
		else
			TR[k]=SR[j++];
	}
	if(i&lt;=m)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=m-i; l++)
			TR[K+l]=SR[i+1];
	}
	if(j&lt;=n)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=n-j; l++)
			TR[k+l]=SR[j+l];
	}
} //详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224214436361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224214448493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump23">9.8.2 归并排序复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度分析：<br>
对于上面那个merge函数中，将原始数列SR[]放入到TR1[]中，由于要遍历循环所有的记录所以时间复杂度为O(n)，而由完全二叉树的深度可知，整个总的归并排序需要进行log2n次，总的时间复杂度为O(nlogn)<br>
2.空间复杂度分析：<br>
由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，所以空间复杂度为o(n)。同时还有递归时深度为log2n的栈空间，因此空间复杂度为O(n+logn)<br>
3.Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明他需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法</p>
</blockquote>
<p>      <span id="jump24">9.8.3 非递归实现归并排序</span></p>
<p>直接进行归并排序代码如下：</p>
<pre><code class="language-cpp">//对顺序表L作归并非递归排序
void MergeSort2(SqList *L)
{
	int* TR=(int *) malloc (L-&gt;length*sizeof(int));    //申请额外空间
	int k=1;
	while(k&lt;L-&gt;length)
	{
		MergePass(L-&gt;r,TR,k,L-&gt;length);
		k=2*k;                           //子序列长度加倍
		MergePass(TR,L-&gt;r,k,L-&gt;length);
	    k=2*k;                    	//子序列长度加倍
	}
} //详见代码如下图：

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200224215853578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<table><tr><td bgcolor=GreenYellow>非递归算法和递归算法的区别</td></tr></table>
<blockquote>
<p>1.非递归算法：对数组直接归并<br>
2.递归算法： 先递归拆分数组然后再归并退出递归</p>
</blockquote>
<p>上面的MergePass（归并排序）代码如下：</p>
<pre><code class="language-cpp">void MergePass(int SR[],int TR[],int s,int n)
{
	int i=1;
	int j;
	while(i&lt;=n-2*s+1)
	{
		Merge(SR,TR,i,i+s-1,i+2*s-1);       //两两归并
		i=i+2*s;
	}
	if(i&lt;n-s+1)         //归并最后两个序列
		Merge(SR,TR,i,i+s-1,n);
	else
		for(j=i; j&lt;=n; j++)
			TR[j]=SR[j];
}//详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224220712223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224220724375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>非递归归并排序的时间复杂度如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200224220803431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump25">9.7堆排序算法</span></p>
<blockquote>
<p>大顶堆+小顶堆如下图：</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202002242213116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>如果按照层序遍历的方式给结点从1开始编号，有如下关系：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224221455607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224221554850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>将大顶堆和小顶堆用层序遍历存入数组，如下图：</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200224221707148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump26">9.7.1堆排序算法</span></p>
<blockquote>
<p>堆排序的基本思想如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022422185751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022422191275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
堆排序的整体代码：</p>
<pre><code class="language-cpp">//对顺序表L进行堆排序
void HeapSort(SqList *L)
{
	int i;
	for(i=L-&gt;length/2; i&gt;0; i--)         //将原来的数组构建为一个大顶堆
		HeapAdjust(L,i,L-&gt;length);
	
	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224222615378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224222629819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
上述代码中HeapAdjust函数如何实现：</p>
<pre><code class="language-cpp">void HeapAdjust(SqList *L,int s,int m)
{
	int temp,j;
	temp=L-&gt;r[s];
	for(j=2*s; j&lt;=m; j*=2)   //沿关键字较大的孩子结点向下筛选
	{
		if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])
			++j;            //j为关键字中较大的记录的下标
		if(temp&gt;L-&gt;r[j])
			break;
		L-&gt;r[s]=L-&gt;r[j];
		s=j;
	}
	L-&gt;r[s]=temp;   //插入
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224223320292.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223337424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223348267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223402125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
接下来就是HeapSort函数中正式的排序过程</p>
<pre><code class="language-cpp">	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}//详见如下图：

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200224223738871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump27">9.7.2堆排序复杂度分析</span></p>
<blockquote>
<p>1.在第一次构建堆的过程中，时间复杂度如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224224117512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224224130379.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.在正式排序的过程中，时间复杂度如下：</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200224224223924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump28">9.9快速排序</span></p>
<blockquote>
<p>1.希尔排序相当于直接插入排序的升级，他们都属于插入排序类<br>
2.堆排序相当于简单选择排序的升级，他们都属于选择排序类<br>
3.快速排序就是冒泡排序的升级，他们都属于交换排序类</p>
</blockquote>
<p>       <span id="jump29">9.9.1快速排序算法</span></p>
<blockquote>
<p>快速思想的思想，如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200225113932704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
快速排序的代码：</p>
<pre><code class="language-cpp">void QuickSort(SqList *L)
{
	QSort(L,1,L-&gt;length);
}

</code></pre>
<p>QSort函数的代码：</p>
<pre><code class="language-cpp">//对顺序表L中的子序列做快速排序
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if(low&lt;high)
	{
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200225114522383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>上述代码中Partition函数（将原始数组一分为2的数组）如下：</p>
<pre><code class="language-cpp">//交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
//此时在他之前的记录均不大于他，在后面的记录均不小于他
int Partition(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		swap(L,low,high);                 //将比枢轴记录小的记录交换到低端
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		swap(L,low,high);                      //将比枢轴记录大的记录交换到高端
	}
	return low;              //返回枢轴所在位置
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200225115335261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115345893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115359275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump30">9.9.2快速排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/202002251156198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115918926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002251159399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump31">9.9.3快速排序优化</span><br>
               1.优化选取枢轴<br>
                         1.为啥要优化选取枢轴？<br>
<img src="https://img-blog.csdnimg.cn/20200225120248306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225120308181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>                         2.三数取中法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200225120455867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在Partition函数中的第3行与第4行之间加上如下代码：</p>
<pre><code class="language-csharp">3 int Pivotkey;
	int m=low+(high-low)/2;           //计算数组中间的元素的下标
	if(L-&gt;r[low]&gt;L-&gt;r[high])
		swap(L,low,high);        //交换左端与右端，保证左端较小
	if(L-&gt;r[m]&gt;L-&gt;r[high])
		swap(L,high,m);             //交换中间与右端数据，保证中间较小
	if(L-&gt;r[m]&gt;L-&gt;r[low])
		swap(L,m,low);               //交换中间与左端数据，保证左端较小
	//此时L.r[low]已经是整个序列做左中右三个关键字的中间值
4 pivotkey=L-&gt;r[low];          //还是用子表的第一个记录做枢轴记录
//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022512114547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
                         3.优化不必要的交换：<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225121325776.png" alt="在这里插入图片描述" loading="lazy"><br>
2.详细代码：</p>
<pre><code class="language-cpp">//快速排序优化算法
int Partition1(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	//这里省略三数取中的代码
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	L-r[0]=L-&gt;r[high];              //增加1：叫枢轴关键字备份到L-&gt;r[0]
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		L-&gt;r[low]=L-&gt;r[high];              //增加2：采用的是替换而不是交换
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		L-&gt;r[high]=L-&gt;r[low];        //增加3：采用的是替换而不是交换
	}
	L-&gt;r[low]=L-&gt;r[0];              //增加4：将枢轴数值替换回L.r[low]
	return low;              //返回枢轴所在位置

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200225122008154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         4.优化小数组的排序方案<br>
1.原因如下：<br>
<img src="https://img-blog.csdnimg.cn/20200225122148402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.详见代码：</p>
<pre><code class="language-cpp">#define MAX_LENGTH_INSERT_SORT 7            //数组长度阈值
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200225122542336.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         5.优化递归的操作<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225122706361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
于是对QSort进行尾递归操作：</p>
<pre><code class="language-cpp">void QSort1(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		while(low&lt;high)
		{
			pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
			QSort1(L,low,pivot-1);             //对低字表递归排序
			low=pivot+1;              //尾递归			
		}

	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200225123002786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第五章笔记（串）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/">
        </link>
        <updated>2020-03-01T04:20:53.000Z</updated>
        <content type="html"><![CDATA[<p>5.2<br>
1.串是由零个或多个字符组成的有限序列，又名叫字符串。<br>
2.串中的字符数目n称为串的长度。<br>
3.零个字符的串称为空串，它的长度为0，也可以直接用双引号&quot;&quot;直接括起来。<br>
4.空格串，是包含空格的串。空格串是有长度的，而且可以不止一个空格。<br>
5.子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。<br>
6.子串在主串中的位置就是子串的第一个字符在主串中的序号</p>
<p>5.3串的比较：<br>
1.将两个字符串都从左至右对齐，然后开始比较，字符串的数量可以不同，比较字符串时一一对应，按照ascii码的方式，字母在前的小，到第一个不同字母比较完之后就完。</p>
<p>5.4串的数据结构：</p>
<pre><code class="language-cpp">ADT 串（string）
Data 
	串中元素仅有一个字符组成，相邻的元素具有前驱和后继关系
Operation
	StrAssign (T,*chars): 生成一个其值等于字符串的常量chars的串T
	StrCopy (T,S):串S存在，由串S复制得到串
	ClearString(S): 串s存在，将串清空
	StringEmpty(S):若串S为空，返回true，否则返回false
	StrLength(S):返回串中的元素个数，即串的长度
	StrCompare(S,T):若S&gt;T,返回值&gt;0,若S=T，返回0，若S&lt;T,返回值&lt;0
	Concat(T,S1,S2):用T返回又S1和S2链接而成的新串
	SubString (Sub,S,pos,len):  串s存在，1&lt;=pos&lt;=StrLength(S),且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符起长度为len的子串
	Index (S,T,pos): 串S和T存在，T是非空串, 1&lt;=pos&lt;=StrLength(S)
					若主串S中存在和串T值相同的子串，则返回它在主串S中
					 第pos个字符之后第一次出现的位置，否则返回0
	Replace(S,T,V):  串S,T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重复的子串
	StrInsert(S,pos,T):  串S和T存在，1&lt;=pos&lt;=Strlength(S)+1
						在串S的第pos个字符之前插入串T
	Strlength(S,pos,len): 串S存在，1&lt;=pos&lt;=Strlength(S)-len+1
						`  从串S中删除第pos个字符起长度为len的子串
endADT
</code></pre>
<p>5.4.1index的操作（取主串中，与子串相同的字符串的第一个字符的位置）</p>
<pre><code class="language-cpp">/*T为非空串。若主串s中第pos个字符之后存在于T相等的子串*/
/*则返回第一个这样的子串在S中的位置，否则返回0*/
int Index(String S, String T, int pos)
{
	int n,m,i;
	String sub;
	if(pos&gt;0)
	{
		n=StrLength(S);
		m=Strlength(T);
		i=pos;           //刚开始这个pos不是要所要的位置，不知道也不必说
		while(i &lt;= n-m+1)   //见下图有这代码的解释
		{
			SubString(sub,S,i,m);     //取主串第i个位置
										//长度与T相等子串给sub
			if(StrCompare(sub, T) !=0 )   //如果两个串不相等
				++i;
			else                  //如果两串相等
				return i;  			//则返回i值
		}
		
	}
	return 0;    //若无子串与T相等，返回0
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227210942916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的顺序存储结构：<br>
<img src="https://img-blog.csdnimg.cn/20191227211456716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的链式存储结构：没有占满的位置，可以用其他非字符替代<br>
<img src="https://img-blog.csdnimg.cn/20191227211514657.png" alt="在这里插入图片描述" loading="lazy"><br>
、<br>
5.6朴素的模式匹配法：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//T非空，1&lt;=pos&lt;=Strlength(S)
int Index(String S, String T, int pos)
{
	int i=pos;        //i主要用于主串s中当前位置的下标，若pos不为1
						//则从pos位置开始匹配
	int	j=1;					 //j用于子串T中当前位置下标值
	while(i &lt;= S[0] &amp;&amp; j &lt;= T[0])    //若i小于s长度且j小于T的长度时循环
	{
		if(S[i] == T[j])      //两个字母相等则继续
		{
			++i;
			++j;
		}
		else        //指针后退重新开始匹配
		{
			i=i-j+2;    //i退回到上次匹配首位的下一位,详细看下图1处
			j=1;     //j退回到子串T的首位
		}
	}
	if(j&gt;T[0])   //上面的while结束有两种情况，i&gt;S[0] 或者  j&gt;T[0] 当i&gt;S[0]一定没有对应的字符串匹配，当j&gt;T[0]时，表示走完了字串，找到了相对应的
		return i-T[0];      //详细看下图2处
	else
		return 0;
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227220444240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
朴素算法的时间复杂度：<br>
<img src="https://img-blog.csdnimg.cn/20191229233628356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191229233657400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>5.7KMP模式匹配法<br>
1.kmp算法的普遍理解：如下图，kmp算法的使用前提是T串中的首字符a与后面的均不相等，由于a到e子串T与主串S都对应相同，所以下一次直接比较a与f即可，这便是kmp的引入<br>
<img src="https://img-blog.csdnimg.cn/20191230202900263.png" alt="在这里插入图片描述" loading="lazy"><br>
2.实际上，j的回溯位置的变化与主串S没有什么关系，主要是看子串T中是否有相同的字符，如下图中不用在比较a,b,<br>
j从6回溯到j=3<br>
<img src="https://img-blog.csdnimg.cn/20191230203551303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关于j的回溯的数组next的原理：如下图<br>
<img src="https://img-blog.csdnimg.cn/20191230203909316.png" alt="在这里插入图片描述" loading="lazy"><br>
这里对于5这个位置下要看前4个字符，第一个a与最后一个a相同，相同字母只有一个，所以5下就写2<br>
这里对于6这个位置下要看前5个字符，前两个字符ab与最后两个字符ab完全相同，所以6下就写3<br>
如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191230204256407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
j回溯位置下标的数组：</p>
<pre><code class="language-cpp">//通过计算返回子串T的next数组
void get_next (String T, int *next)
{
	int i,j;
	i=1;             
	j=0;               
	next[1]=0;
	while(i&lt;T[0])        //此处T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])
		{
			++i;
			++j;
			next[i]=j;       //将j回溯的位置保存到next中
		}
		else
			j=next[j];          //j回溯到对应位置
	}
}
</code></pre>
<p>下面是KMP的整体代码：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
int Index_KMP(String S, String T, int pos)
{
	int i=pos;       //i就是那里的代码值不同就从哪里开始，如图5-7-3 i为6就从6开始
	int j=1;       //j用于当前位置中下标值
	int next[255];    //定义一next数组
	get_next(T,next);   //对串做分析，得到next数组
	while(i &lt;= s[0] &amp;&amp; j &lt;= T[0])   //若i小于s的长度且j小于且小于T的长度时，循环继续
	{
		if(j==0 || s[i]==T[j])    //两个字母相等则继续，相对于朴素算法增加了j=0判断
		{
			++i;
			++j;
		}
		else
		{
			j=next[j];    //如果字母不相同，则j的值回溯
		}
	}
	
//后面两行代码和朴素算法相同
	if(j&gt;T[0])    
		return i-T[0];
	else
		return 0;
	
}
</code></pre>
<p>kmp算法的时间复杂度分析：<br>
在这里，创建next数组时间复杂度为o(m)，后面的时间复杂度为o(n)，则整体的时间复杂度为o(m+n)<br>
kmp的核心思路：如果子串中一前一后有相同的字符，后面的字符不管与主串中是相同还是不同，对于前面的字符在往后走时不用在与之前</p>
<p>5.7.4kmp模式匹配算法的改进</p>
<pre><code class="language-cpp">//求模式串T的next函数修正值并存入数组nextval，整个nextval还是以计算next的方法来构建，区别在于数值不同，目的就是减少j的回溯次数，以减少复杂度
void get_nextval(String T, int *nextval)
{
	int i,j;
	i=1;
	j=0;
	nextval[1]=0;
	while(i&lt;T[0])           //T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])       //T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
		{
			++i;
			++j;
/* 这里的代码是改进后不同于之前的next算法
			if(T[i]!=T[j])   //若当前字符与前缀字符不同
				nextval[i]=j;		//就将next中的值给nextval
			else
				nextval[i]=nextval[j];  //字符相同,nextval与之前相同字符所对应的nextval值相同
*/
		}
		else
			j=nextval[j];      //相当于计算next数组中的值，只是改了个名，就这样理解
	}
}
</code></pre>
<p>5.7.4 kmp算法的改进<br>
1.相对于之前的kmp算法j的回溯位置变化太多，而改进后，j回溯的变化位置不多，这里应该是T中有太多连续字符相同的情况下<br>
next数组中，数字不同的程度与j回溯到不同位置的次数成正比，数字越复杂，回溯的次数越多，时间复杂度越大。<br>
2.nextval[]数组变化是：第一数组值为0，往后每一个数组值，如果串中的字符与next数组中对应位置的字符相同，则nextval中的值也与对应位置的nextval相同，如果不同则nextval值就是next值<br>
<img src="https://img-blog.csdnimg.cn/20191230223215549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第六章笔记（树）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/">
        </link>
        <updated>2020-03-01T04:20:04.000Z</updated>
        <content type="html"><![CDATA[<p>6.2树的定义：<br>
1.树是n个结点的有限集，n=0时称为空树<br>
2.有且仅有一个特定的根<br>
3.子树的个数没有限制，但他们一定是不相交，如下图，就不是子树<br>
<img src="https://img-blog.csdnimg.cn/20191231202354754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.结点拥有的子树数称为结点的度。度为0的结点称为叶节点；度不为0的结点称为分支结点。除根节点之外，分支节点也称内部结点；树的度是树内各结点的度的最大值，如下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203344509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.3结点间的关系：<br>
1.结点的祖先是从根到该结点所经分支上的所有结点 对于H而言ABD都为他的祖先。其他各种关系见下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203245223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.树的相关概念，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203808831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.树与线性表之间的差别，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203824606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.3树的抽象数据类型，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231204652847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4树的存储结构=== 双亲表示法<br>
1.除了根节点啊外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲<br>
2.以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置，结构如下：</p>
<pre><code class="language-bash">data parent  //data是数据域，存储结点的数据信息。parent是指针域，存储该结点的双亲在数组中的下标
</code></pre>
<p>双亲表示法的结点结构定义代码：</p>
<pre><code class="language-cpp">//树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定位整型
typedef struct PTNode   //结点结构
{
	TElemType data;   //结点数据
	int parent;        //双亲位置
}PTNode;
typedef struct       //树的结构
{
	PTNode nodes[MAX_TREE_SIZE];   //结点数组
	int r,n;         //根的位置和结点数
}
</code></pre>
<p>上面的代码对应下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231210350239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进1：在结点中加入左孩子：<br>
<img src="https://img-blog.csdnimg.cn/20191231210401533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进2：在结点中加入有兄弟：<br>
<img src="https://img-blog.csdnimg.cn/20191231210410793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.2孩子表示法：由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表法：如下图，有两种方案：<br>
方案一：<br>
指针域的个数就是树的度，树的度是树中各个结点度的最大值，结构如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213303600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
方案2：<br>
每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213251681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
重点是如下：<br>
孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个维数组中，如图</p>
<pre><code class="language-cpp">//树的孩子表示法结构定义：
#define MAX_TREE_SIZE 100
typedef struct CTNode   //孩子结点
{
	int chile;  //数据域：用来存储某个结点在表头数组中的下标
	struct CTNode *next;  //指针域：存储指向某结点另一个孩子结点的指针
}*ChildPtr;
typedef struct 
{
	TElemType data;  //存储某结点的数据信息
	ChildPtr firstchild; //存储该结点的孩子链表的头指针
}CTBox;
typedef struct     //树结构
{
	CTBox nodes[MAX_TREE_SIZE];  //结点数组
	int r,n;        //根的位置和结点数
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2019123121443736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
双亲表示法和孩子表示法综合，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231214837104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.3孩子兄弟表示法：<br>
结点结构如下图：<br>
firstchild 为指针域，存储该结点的第一个孩子存储地址<br>
<img src="https://img-blog.csdnimg.cn/2019123121564494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
结构定义代码如下：</p>
<pre><code class="language-cpp">//树的孩子兄弟表示法结构定义：
typedef struct CSNode
{
	TElemType data;
	struct CSNode *fitstchild, *rightsib;
}CSNode, *CSTree;
</code></pre>
<p>上面代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231215849928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.5二叉树<br>
1.如图便是二叉树，不能有3个结点：<br>
<img src="https://img-blog.csdnimg.cn/20191231220217170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">6.5.1二叉树特点：<br>
1.每个结点最多有两颗子树<br>
2.左子树与右子树是有顺序的，次序不能任意颠倒<br>
3.即使树中某结点只有一颗树，也要区分它是左子书还是右子树</p>
<p>二叉树的五种基本形态：<br>
1.空二叉树<br>
2.只有一个根节点<br>
3.根结点只有左子树<br>
4.根结点只有右子树<br>
5.根结点既有左子树又有右子树</p>
<p>6.5.2特殊二叉树<br>
1.斜树，满二叉树，完全二叉树 以及 满二叉树的特点和完全二叉树的特点，：如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101205140586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101205158141.png" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205220907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树与满二叉树的关系：<br>
<img src="https://img-blog.csdnimg.cn/20200101205227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200101205248318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
满二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205312212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.6二叉树的性质：<br>
1.某一层上最多有多少个结点<br>
<img src="https://img-blog.csdnimg.cn/20200101210138616.png" alt="在这里插入图片描述" loading="lazy"><br>
2.深度为k的二叉树最多有几个结点：<br>
<img src="https://img-blog.csdnimg.cn/20200101210128770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.n0表示度为0的结点个数，n1表示度为1的结点的个数，n2表示度为2的结点的个数<br>
<img src="https://img-blog.csdnimg.cn/20200101210056806.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210115437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.完全二叉树的深度<br>
<img src="https://img-blog.csdnimg.cn/20200101210030592.png" alt="在这里插入图片描述" loading="lazy"><br>
5.对于根结点，左孩子，右孩子的判定方法：<br>
<img src="https://img-blog.csdnimg.cn/20200101210019979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.7.1二叉树的顺序存储结构：<br>
用数组存放，没有就像倒V表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101210629187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210615923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.7.2二叉链表：<br>
用链式存储结构来存放二叉树，设计一个数据域，两个指针分别指向左孩子和右孩子，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101211952142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>二叉链表的结点结构定义：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode        //结点结构
{
	TElemType data;       //结点数据
	struct BiTNode *lchild, *rchild;    //左右孩子指针
}BiTNode, *BiTree;
</code></pre>
<p>结构示意图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200101211934670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.2二叉树4中遍历方法：<br>
1.前序遍历法<br>
2.中序遍历法<br>
3.后序遍历法<br>
4.层序遍历法</p>
<p><img src="https://img-blog.csdnimg.cn/20200101212151521.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101212228822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.3前序遍历法：</p>
<pre><code class="language-cpp">//二叉树的前序遍历递归算法
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	printf(&quot;%c&quot;,T-&gt;data);      //显示结点数据，可以更改为为其它节点的操作
	PreOrderTraverse(T-&gt;lchild);     //先遍历左子树
	PreOrderTraverse(T-&gt;rchild);        //最后遍历右子树
}
</code></pre>
<p>按照如下的顺序访问：<br>
<img src="https://img-blog.csdnimg.cn/20200101212935308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010121295030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213004977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213046165.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.4中序遍历算法代码：</p>
<pre><code class="language-cpp">//二叉树的中序遍历递归算法
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	InOrderTraverse(T-&gt;lchild);    //中序遍历左子树
	printf(&quot;%c&quot;,T-&gt;data)         //显示节点数据，可以更改为其他对结点操作
	InOrderTraverse(T-&gt;rchild);     //最后中序遍历右子树
}
</code></pre>
<p>中序遍历结点示意图：<br>
<img src="https://img-blog.csdnimg.cn/20200101213810373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.5后续遍历法代码：</p>
<pre><code class="language-cpp">//二叉树后序遍历递归算法：
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	PostOrderTraverse(T-&gt;lchild);   //先后序遍历左子树
	PostOrderTraverse(T-&gt;rchild);    //后序遍历右子树
	printf(&quot;%c&quot;,T-&gt;data);       //显示结点数据，可以更改为对其他结点操作
}
</code></pre>
<p>6.9二叉树的建立：<br>
1.扩展二叉树：将二叉树中每个结点的空指针引出一个虚节点，其值为以特定值，比如&quot;#&quot;，称这种处理后的二叉树为原二叉树的扩展二叉树。如下图：</p>
<p>2.把前序遍历序列：AB#D##C##用键盘诶个输入，代码如下：<br>
也可以用中序或后序遍历的方法实现<br>
中序：输入顺序为#B#D#A#C#      对应代码顺序为：构造左子树—》生成结点-》构造右子树<br>
后序：输入顺序为###DB##CA     对应代码顺序为： 构造左子树-》构造右子树-》生成结点</p>
<pre><code class="language-cpp">//按前序输入二叉树中结点的值（一个字符）
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BiTree *T)
{
	TElemType ch;
	scanf(&quot;%c&quot;, &amp;ch);
	if(ch==&quot;#&quot;)
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)-&gt;data=ch;     //生成根结点
		CreateBiTree(&amp;(*T)-&gt;lchild);             //构造左子树
		CreateBitree(&amp;(*T)-&gt;rchild);            //构造右子树
	}
}

</code></pre>
<p>6.10线索二叉树<br>
以中序遍历为例：下面二叉树中中序遍历的结果为：HDIBJEAFCG<br>
线索二叉树的实质：将二叉链表中的空指针改为指向前驱或后继的线索。<br>
<img src="https://img-blog.csdnimg.cn/202001022049073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将rchild改为后继，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204323143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将lchild改为它的前驱，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204350104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
整个二叉树的中序遍历结果中的前驱后继关系如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204638116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>将lchild,ltag,data,rtag,rchild组合成一个结构，如下图：<br>
具体如下：<br>
ltag为0表示指向该节点的左孩子，为1表示指向该节点的前驱<br>
rtag为0表示指向该结点的右孩子，为1指向该结点的后继<br>
<img src="https://img-blog.csdnimg.cn/20200102204422155.png" alt="在这里插入图片描述" loading="lazy"><br>
二叉树的搜索存储结构定义</p>
<pre><code class="language-cpp">//二叉树的二叉搜索存储结构定义
typedef enum{Link,Thread} PointerTag;         //Link==0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索
typedef struct BiThrNode           //二叉搜索存储结点结构
{
	TElemType data;
	struct BiThrNode *lchild, *rchild;        //左右孩子指针
	PointerTag LTag;                 //左右标志            
	PointerTag RTag;      
}BiThrNode, *BiThrTree;

												

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200102204454222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>中序遍历线索化递归函数代码：(构建线索二叉树)<br>
可以根据上图二叉树来理解</p>
<pre><code class="language-cpp">//中序遍历进行中序线索化
void InThreading(BiThrTree p)
{
	InThreading(p-&gt;lchild);             //递归左子树线索化
	if(!p-&gt;lchild)                //没有左孩子
	{
		p-&gt;LTag=Thread;                   //将LTag改为1
		p-&gt;lchild=pre;               //左孩子指针指向前驱
	}
	if(!pre-&gt;rchild)
	{
		pre-&gt;RTag=Thread;                    //将RTag改为1，为了理解见下图
		pre-&gt;rchild=p;                //前驱右孩子指针指向后继(当前结点p)
	}
	pre=p;                       //保持pre指向p的前驱
	InThreading(p-&gt;rchild);           //递归右子树线索化
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200102214224564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
二叉线索树的遍历，见下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102220110750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
遍历代码如下：</p>
<pre><code class="language-cpp">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T
Status InOrderTraverse_Thr(BiThTree T)
{
	BiThrTree p;
	p=T-&gt;lchild;             //p指向根结点
	while(p!=T)               //空树或遍历结束时，p==T
	{
		while(p=&gt;LTag==Link)            //当LTag==0时循环到中序序列的第一个结点
			p=p-&gt;lchild;
		printf(&quot;%c&quot;,p-&gt;data);           //显示结点数据，可以更改为其他对结点的操作
		while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)
		{
			p=p-&gt;rchild;                  //p中RTag是1表示存放的是他的后继结点
			printf(&quot;%c&quot;,p-&gt;data); 
		}
		p=p-&gt;rchild;            //p中RTag是0表示，p进入他的右子树  区分上面的
	}
	return OK;
}

</code></pre>
<p>如果所用二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，采用线索二叉树的存储结构</p>
<p>6.11.1树转换为二叉树<br>
1.加线。在所有兄弟节点之间加一条线<br>
2.去线。 就是按照你的思路去就对<br>
3.层次调整。 以树的根结点为轴心，顺时针旋转，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来为结点的右孩子<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103194908705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.2将森林转换为二叉树：<br>
1.将每个树按照上面的方法转化成二叉树<br>
2、第一棵树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103195444927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.3二叉树转化为树<br>
1.将结点的左孩子n个右孩子，用线连接起来<br>
2.删除原二叉树中所有结点与其右孩子结点的连线<br>
3.层次调整。  如果只有一个孩子，就直接转化为竖线即可<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103200346330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.4二叉树转化为森林：<br>
1.从根结点开始，若右孩子存在则删除连线，若右孩子存在则删除连线，只要有右孩子就把连线删了<br>
2.再将每棵二叉树转化成树<br>
<img src="https://img-blog.csdnimg.cn/20200103201021824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.5.森林的遍历：<br>
1.前序遍历：一颗树接着一棵树来，每棵树都用先序遍历法，对于上图的二叉树的遍历结果为：ABCDEFGHJI<br>
2.后序遍历：还是一棵树接着一棵树来，每棵树都用后序遍历法，对于上图的二叉树的遍历结果为：BCDAFEJHIG<br>
对于上图而言，森林的前序遍历法和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历法相同。</p>
<p>6.12赫夫曼树及其应用：<br>
树的路径长度表示从根结点到每一个结点的长度总和，如下图中二叉a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+2+3+3+1+2+2=16<br>
<img src="https://img-blog.csdnimg.cn/20200103204819966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
带权路径长度wpl最小的二叉树称作赫夫曼树，上图中二叉树a的wpL=5<em>1+15</em>2+40<em>3+30</em>4+10<em>4=315 ，二叉树b的wpl=40</em>2+15<em>3+5</em>3+30<em>2+10</em>2=220</p>
<p>6.12.2最优赫夫曼树构造方法：<br>
1.将把有权值的叶子结点按照从小到大的顺序排成一个有序列<br>
2.取头两个最小权值的结点之和作为一个新的结点，注意较小的为新的结点的左孩子，每次如此重复，直至结束。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103210711134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210742955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210759426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
赫夫曼编码：<br>
根据赫夫曼树左0右1，对应每个字符编码。这样可以将字符串的长度变少，同样解码也是根据表6-12-3表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103213334549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第七章笔记（图）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/">
        </link>
        <updated>2020-03-01T04:18:59.000Z</updated>
        <content type="html"><![CDATA[<p>1.图的定义G（V,E）其中G表示一个图，V表示图G中顶点集，E表示图G中边的集合<br>
2.线性表中数据元素叫元素，树中数据元素叫结点，在图中数据元素称为顶点<br>
3.线性表中没有数据元素称为空表，树中没有数据元素称为空树，在图的结构中，不允许没有顶点<br>
4.在线性表中相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，在图中，任意两个顶点可能有关系，顶点之间的逻辑关系用边来表示。</p>
<p>7.2.1各种图的定义：<br>
1.如下图 7-2-2是无向图G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}   边集合={(A,B),(B,C),(C,D),(D,A),(A,C)}其中边之间用()来表示<br>
2.如下图7-2-3，是有向图G2=(V2,{E2})， 顶点集合V2={A,B,C,D}  弧集合E2={&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;} A是弧头，D是弧尾 。无向边用()表示，有向边用&lt;&gt;表示<br>
<img src="https://img-blog.csdnimg.cn/2020010619471683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.无向完全图：任意两顶点之间都存在边。含有n个顶点的无向完全图有n*(n-1)/2条边<br>
4.有向完全图：任意两定点之间存在方向相反互为相反的两条弧，含有n个顶点的有向完全图有n*(n-1)条边<br>
5.无向图：边数就是各顶点度数之和的一半<br>
6.有向图：某顶点的度数=出度数+入度数；所有顶点的入度数之和=所有顶点的出度数之和=边数；<br>
7.路径长度：路径上的边或弧的数目，图7-2-9中上方两条路径长度为2，下放两条路径长度为3；图7-2-10中左侧路径长为2，右侧路径长度为3<br>
<img src="https://img-blog.csdnimg.cn/20200106200638165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
8.回路，简单路径，简单回路：<br>
能从出发点绕了一圈又回到出发点，称为回路或环；<br>
序列中顶点不重复出现的路径称为简单路径。<br>
除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路。<br>
如图7-2-11中，左侧的回路是简单回路，右侧的环是不是简单回路，因为c重复了。<br>
<img src="https://img-blog.csdnimg.cn/20200106200657617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
9.若无重复的边或顶点到自身的边则叫简单图，如下图，就不是简单图：<br>
<img src="https://img-blog.csdnimg.cn/20200106204054344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>7.2.3连通图：任意两点之间都是连通的<br>
无向图中的极大连通子图称为连通分量：</p>
<ul>
<li>要是子图</li>
<li>子图是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边<br>
如图7-2-12,图1不是连通图，图2，图3都是子图且都连通，但图4不是连通分量，因为他只有3个顶点<br>
<img src="https://img-blog.csdnimg.cn/20200106201713177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200106201724638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<p>7.2.3.2强连通图：有向+连通图<br>
图中有子图，若子图极大连通就是连通分量，有向的就是强连通分量，如下图中图1不是强连通图，图2是强连通图，同样图2是图1的强连通分量<br>
<img src="https://img-blog.csdnimg.cn/20200106202052518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.3连通图的生成树：包含图中全部的n个顶点，但只有足以构成一棵树的n-1条边，如图2.图3；如果有n个顶点，但是小于n-1条边则是非连通图；如果边多于n-1，则构成环，如图2,3任意给两个顶点之间一条边，就构成环；不过有n-1条边并不一定是生成树，如图4。<br>
<img src="https://img-blog.csdnimg.cn/20200106202847268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.4<br>
如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗有向树。<br>
一个有向图的生成森林由若干课有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧，如下图中，图1是有向图，	去掉弧之后，分解为两个有向树，如图2 图3，这两颗就是图1的有向图的生成森林。<br>
<img src="https://img-blog.csdnimg.cn/20200106203812838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.3图的抽象数据类型：<br>
<img src="https://img-blog.csdnimg.cn/20200106204941634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.4图的五种存储结构：<br>
一.邻接矩阵：<br>
1.图的邻接矩阵存储方式用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。<br>
2.无向图的邻接矩阵的特点：<br>
a.矩阵是关于主对角线对称的<br>
b.Vi顶点的度=第i行或者第i列上的元素之和<br>
c.Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，数组元素为1就是邻接点<br>
d.主队角线上元素为0<br>
<img src="https://img-blog.csdnimg.cn/20200106211104874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.有向图的邻接矩阵的特点：<br>
a.不是对称矩阵<br>
b.主队角线上元素为0<br>
c.顶点Vi的入度为第Vi列各数之和；出度数为第Vi行各数之和<br>
d.判断Vi到Vj是否存在弧，只需要查找矩阵中元素是否为1<br>
e.要求Vi的所有邻接点就是将第i行元素扫描一遍，查找矩阵中元素为1的点<br>
<img src="https://img-blog.csdnimg.cn/20200106211123418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.对于边上的权值而言，如果不存在则为无穷；自身到自身的度为矩阵元素为0,<br>
<img src="https://img-blog.csdnimg.cn/20200106211145807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.图的邻接矩阵存储的结构：</p>
<pre><code class="language-cpp">typedef char VertexType;              //顶点类型应由用户定义
typedef int EdgeType;                //边上的权值类型应由用户定义
#define MAXVEX 100               //最大顶点数
#define INFINITY 65535          //用65535来表示无穷
typedef struct 
{
	VertexType vexs[MAXVEX];            //顶点表
	EdgeType arc[MAXVEX][MAXVEX];           //邻接矩阵，
	int numVertexes, numEdges;         //图中当前顶点数和边数
}MGraph;
</code></pre>
<p>6.构造一个无向图</p>
<pre><code class="language-cpp">//建立无向图的邻接矩阵
void CreateMGraph(MGraph *G)
{
	int i,j,k,w;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);     //输入顶点数，边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)            //读入顶点信息，建立顶点表
		scanf(&amp;G-&gt;vexs[i]);
	for(i=0; i&lt;G-&gt;numVertexes; i++)
		for(j=0; j&lt;G-&gt;numVertexes; j++)
			G-&gt;arc[i][j]=INFINITY;            //邻接矩阵初始化
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的下标i，下标j和权w:\n&quot;);
		scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;w);    //输入边(Vi,Vj)上的权W
		G-&gt;arc[i][j]=w;
		G-&gt;arc[i][j]=G-&gt;arc[i][j];      //因为是无向图，矩阵对称
	}
//时间复杂度为o(n+n^2+e):n个顶点，e条边 最终为o(n^2)
}
</code></pre>
<p>二.邻接表：<br>
1.顶点用一维数组来存放，另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针；每个顶点的所有邻接点构成一个线性表，用单链表存储<br>
2.第Vi个顶点的度，就去查这个顶点的边表中结点的个数<br>
3.要判断Vi与Vj之间是否存在边，只需要测试顶点Vi的边表中是否存在结点Vj的下标j就行<br>
4.若要求顶点的所有邻接点，就对此顶点的边表进行遍历，得到的就是邻接点。见下图7-4-6<br>
5.有向图的逆邻接表，就是看谁往这个点里干，如下图7-4-7(2)<br>
6.有向图的邻接表，如下图7-4-7（1）<br>
7.带权值的邻接表，如下图7-4-8<br>
<img src="https://img-blog.csdnimg.cn/20200106215146181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621520519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621522774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
邻接表结点定义的代码：</p>
<pre><code class="language-cpp">typedef char VertexType;             //顶点类型由用户定义
typedef int EdgeType;                 //边上的权值类型由用户定义

typedef struct EdgeType          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}GraphAdjList；
</code></pre>
<p>无向图的邻接表创建代码：</p>
<pre><code class="language-cpp">//建立图的邻接表结点
void CreateALGraph (GraphAdjList *G)
{
	int i,j,k;
	EdgeNode *e;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);        //输入顶点数和边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)          //读入顶点信息，建立顶点表
	{
		scanf(&amp;G-&gt;adjList[i].data);       //输入顶点信息
		G-&gt;adjList[i].firstedge=NULL;        //将指向边表的头结点置为空
	}
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的顶点序号:\n&quot;);
		scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);          //输入边（vi,vj）上的顶点序号
		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=j;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[i].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[i].firstedge=e;          //把e这个结点在放回头结点 

		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=i;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[j].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[j].firstedge=e;          //把e这个结点在放回头结点 
	}
}
时间复杂度为o(n+e)=o(n)  //n个顶点，e条边
</code></pre>
<p>第三种：十字链表：就是将邻接表和逆邻接表相结合方便了解结点的出度和入度<br>
1.重新定义顶点表结点结构，如下图，<br>
firstin 表示入边表头指针，指向该顶点的入边表中第一个结点<br>
firstout 表示出边表指针，指向该顶点的出边表中的第一个结点<br>
<img src="https://img-blog.csdnimg.cn/20200107202857870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义边表结点结构，如下图：<br>
tailvex是指弧起点在顶点表的下标<br>
headvex是指弧终点在顶点表中的下标<br>
headlink是指边表指针域，指向终点相同的下一条边<br>
taillink 是指边表指针域，指向起点相同的下一条边<br>
<img src="https://img-blog.csdnimg.cn/20200107202912422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200107204325664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
v0中firstout指向它自己的边表结点，后面那个边表结点中03表示从0开始走到3；v0中fistrtin表示V1走向它，他犯贱再走向v1，v0再也没有可走的下一个结点，所以taillink为NULL；v0走向v3，没有人与他一样再走向v3所以headlink为NULL<br>
v1中firstou指向自己的边表结点，后面10 。12分别表示从v1走向V0，从v1走向V2；所以v1第一个边表结点中taillink指向下一个，由于1走向0,2也走向0，所以v1中第一个边表结点走到v2中第一个边表结点；同样V2走向V1，v1犯贱它的fisttin指向V2中第2个边表结点<br>
v2也是如此，重点强调由于v2走向v0，没有人再走向v0所以v2中第一个边表结点的healink为空</p>
<p>第四种：邻接多重表<br>
1.如果要删除边，则对于下图的邻接表而言太复杂对于结点而言改动太多<br>
<img src="https://img-blog.csdnimg.cn/20200107210841424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义如下结构：<br>
ivex和jvex表示与某条边依附的两个顶点在顶点表中的下标。<br>
ilink指向依附顶点ivex的下一条边。<br>
jlink指向依附顶点jvex的下一条边</p>
<p><img src="https://img-blog.csdnimg.cn/20200107211110577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010721132679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
1-4表示连接它自己的边表结点<br>
5表示依附于v0的下一条边：v0--v3   6表示依附于v0的下一条边：v0--v2  7表示依附于v1的下一条边：v1--v0<br>
8表示依附于v2的下一条边：v2--v3  9表示依附于v2的下一条边：v2--v0  10表示依附于v2的下一条边：v3--v2</p>
<p>第五种：边集数组：<br>
如下图，就能看懂</p>
<p><img src="https://img-blog.csdnimg.cn/20200107212244138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.5.1深度优先遍历：<br>
1.简称DFS，说白了就是遍历图中每个顶点然后，所有路径都走一遍。遍历过的顶点做好标记就不在遍历<br>
邻接矩阵的DFS代码如下：</p>
<pre><code class="language-cpp">typedef int Boolean;        //Boolean是布尔类型，其值是TRUE或FALSE
Boolean visited[MAX];       //访问标志的数组
//邻接矩阵的深度优先递归算法
void DFS(MGraph G, int i)
{
	int j;
	visited[i]=TRUE;
	printf(&quot;%c&quot;,G.vexs[i]);              //vexs【】表示顶点数组
	for(j=0; j&lt;G.numVertexes; j++)
			if(G.arc[i][j]==1 &amp;&amp; !visited[j])   //arc表示边表数组，1表示两个点之间有值
				DFS(G,j);          //对访问的邻接顶点递归调用
}
//邻接矩阵的深度遍历操作
void DFSTraverse(MGraph G)
{
	int i;
	for(i=0; i&lt;G.numVeretexes; i++)
		visited[i]=False;          //初始所有顶点都是未访问过的状态
	for(i=0; i&lt;G.numVertexes; i++)
		if(!visited[i])            //对未访问过的顶点调用DFS
			DFS(G,i); 
}
时间复杂度是o(n^2)
</code></pre>
<p>邻接表的深度优先递归算法：</p>
<pre><code class="language-cpp">void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
	visited[i]=TRUE;
	printf(&quot;%c &quot;, GL-&gt;adjList[i].data);           //打印顶点，adjLIst表示顶点结构数组，结构成员有data和fistredge指针
	while(p)
	{
		if(!visited[p-&gt;adjvex])
			DFS(GL,p-&gt;adjvex);          //对访问的邻接顶点递归调用
		p=p-&gt;next;
	}
}

//邻接表的深度遍历操作
void DFSTraverse(GraphAdjList GL)
{
	int i;
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		visited[i]=FALSE:     //初始化所有顶点都是未访问过的
	for(i=0; i&lt; GL-&gt;numVertexes; i++)
		if(!visited[i])     //对访问过的顶点调用DFS
		DFS(GL,i);
}

时间复杂度是o(n+e);
</code></pre>
<p>邻接矩阵的广度遍历算法：简称BFS</p>
<pre><code class="language-cpp">/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G)
{
    int i,j;
    Queue Q;
    for(i=0; i&lt;G.numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //初始化一辅助队列
    for(i=0; i&lt;G.numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, G.vex[i]);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                for(j=0; j&lt;G.numVertexes; j++)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
                        {
                            visited[j]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, G.vexs[j]);   //打印顶点
                            EnQueue(&amp;Q,j);        //将找到的此顶点入队列
                        }
                    }
            }
        }
    }
}
</code></pre>
<p>邻接表的广度遍历算法</p>
<pre><code class="language-cpp">/*邻接表的广度遍历算法*/
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;     //边表结点
    Queue Q;
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //舒适化一辅助队列
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, GL-&gt;adjList[i].data);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                p=GL-&gt;adjList[i].firstedge; //找到当前顶点边表链表表头指针
                while(p)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(!visited[p-&gt;adjvex])  //若顶点未被访问过
                        {
                            visited[p-&gt;adjvex]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, GL-&gt;adjList[p-&gt;adjvex].data);   //打印顶点
                            EnQueue(&amp;Q,p-&gt;adjvex);        //将找到的此顶点入队列
                        }
                        p=p-&gt;next;     //指针指向下一个邻接点
                    }
            }
        }
    }
}
</code></pre>
<p>深度优先遍历：更适合目标比较明确，已找到目标为主要目的，类似于前序遍历<br>
广度优先遍历：更适合在不断扩大遍历范围时找到相对最优解情况 ，类似于层序遍历</p>
<p>7.6.1Prim算法：<br>
<img src="https://img-blog.csdnimg.cn/20200108213856363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
Prim算法生成最小生成树</p>
<pre><code class="language-cpp">/*Prim算法生成最小生成树*/
void MiniSpanTree_Prim(MGraph G)
{
    int min,i,j,k;
    int adjvex[MAXVEX];     //保存相关顶点下标
    int lowcost[MAXVEX];      //保存相关顶点间边的权值
    
    lowcost[0]=0;      //初始化第一个权值为0，即v0加入生成树
                       //lowcost的值为0，在这里就是此下标的顶点已经加入生成树
    adjvex[0]=0;        //初始化第一个顶点下标为0
    
    for(i=1; i&lt;G.numVertexes; i++)      //循环除下标为0外的全部顶点
    {
        lowcost[i]=G.arc[ 0][i];    //将V0顶点与之有边的权值存入数组
        adjvex[i]=0;     //初始化都为v0的下标
    }
    
    for(i=1; i&lt;G.numVertexes; i++)
    {
        min=INFINITY;         //初始化最小权值为无穷
        j=1;k=0;      //j用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标、
        
        //20--29表示找出最小值min和对应的数组下标k
        while(j&lt;G.numVertexes)    //循环全部顶点
        {
            if(lowcost[j]!=0 &amp;&amp; lowcost[j]&lt;min)
                {
                    //如果权值不为0且权值小于min
                    min=lowcost[j];      //则让当前权值称为最小值
                    k=j;                    //将当前最小值的下标存入k
                }
            j++;
        }
        
        printf(&quot;(%d,%d)&quot;,adjvex[k],k);      //打印当前顶点边中权值最小边,比如打印结果为(0,1),表示V0至v1遍为最小生成树的第一条边
        
        lowcost[k]=0;     //将当前顶点的权值设置为0，表示此顶点已经完成任务
        
        for(j=1; j&lt;G.numVertexes; j++)   //循环所有顶点
        {
            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])
            {
                //若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值
                lowcost[j] = G.arc[k][j];   //将较小权值存入lowcost
                adjvex[j]=k;  //将下表为k的顶点存入adjvex
            }
        }
        
    }
}

</code></pre>
<p>以下便是Prim算法的过程，最终构成n-1条边，遍历完所有顶点，以某顶点为起点，逐步找各顶点上权值最小的边构建最小生成树<br>
<img src="https://img-blog.csdnimg.cn/20200108214446923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214454992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Krskal算法：求最小生成树<br>
1.将邻接矩阵转化为边集数组：<br>
如下图<br>
<img src="https://img-blog.csdnimg.cn/20200109205012741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">/*Kruskal算法*/
void MiniSpanTree_Kruskal(MGraph G) //生成最小生成树
{
    int i,n,m;
    Edge edges[MAXEDGE];    //定义边集数组
    int parent[MAXEDGE];   //定义一数组用来判断边与边是否形成环路
    
    //此处省略将邻接矩阵G转化为边集数组edges并按权值由小到大排列的代码
    for(i=0; i&lt;G.numVertexes; i++)
            parent[i]=0;      //初始化数组为0
    for(i=0; i&lt;G.numEdges; i++)  //循环每一条边
    {
        n=Find(parent,edges[i].begin);
        m=Find(parent,edges[i].end);
        if(n!=m)
            {
                parent[n]=m;   //将此边的结尾顶点放入下表为起点的parent中
                                //表示此顶点已经在生成树集合中
                print(&quot;(%d,%d)&quot;,edges[i].begin,edges[i].end,edges[i].weight);
            }
    }
}

int Find(int *parent, int f)  //查找连线顶点的尾部下标
{
    while(parent[f]&gt;0)
        f=parent[f];
    return f;
}
算法中find函数有e决定，时间复杂度为o(loge)，而外面有一个for循序e次，所以时间复杂度为o(eloge)

</code></pre>
<p>具体执行过程如下：<br>
<img src="https://img-blog.csdnimg.cn/20200109205414490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205430984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205507351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205531372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205550570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205617883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在E中选择最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此加入到T中，否则舍去此边而选择下一条代价最小的边<br>
k式算法主要针对边来展开，边数少效率非常高，适合稀疏图。p式算法对于稠密图，边数非常多情况会更好<br>
锋说：就是每次找最小的边，不要形成回路，然后最终能将图中所有顶点连接起来<br>
总结：p式算法就是以某个顶点开始找与这个点相关的最小 的边，每次这样寻找；而k式算法就是直接上来找最小的边不形成回路，最终将整个点连起来，他俩都是去找连通图的最小生成树</p>
<p>7.7迪杰斯特拉算法：求最短路径</p>
<pre><code class="language-cpp">#define MAXVEX 9
#define INFINITY 65535
typedef int Patharc[MAXVEX];      //用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX];    //用于存储到各个顶点路径权值和
//Dijkstra算法，求有向网G的v0顶点到其余顶点V最短路径p[V]即带权长度D[V]
//P[V]的值为前驱顶点下标，D[V]表示v0到v的最短路径长度和
void ShortestPath_Dijkstra (MGraph G, int v0, Patharc *p, ShortPathTable *D)
{
	int v,w,k,min;
	int final[MAXVEX];   //final[w]=1 表示求得顶点v0至vw的最短路径
	for(v=0; v&lt;G.numVertexes; v++)     //初始化数据
	{
		final[v]=0;
		(*D)[V]=G.arc[v0][v];         //将与v0点有连线的顶点加上权值
		（*p）[v]=0;            //初始化路径数组p为0
	}
	(*D)[v0]=0;     //v0至v0的路径为0
	final[v0]=1;           //v0至v0不需要求路径
	
	//开始主循环，每次求得V0到某个顶点v的最短路径
	for(v=1; v&lt;G.numVertexes; v++)
	{
		min=INFNITY;      //当前所知离v0顶点的最近距离
		
		for(w=0; w&lt;G.numVertexes; w++)    //寻找离v0最近的顶点
		{
			if(!final[W] &amp;&amp; (*D)[W]&lt;min)
			{
				k=w;
				min=(*D)[W];         //w顶点离v0顶点更近
			}
		}
		
		final[k]=1;      //将目前找到的最近的顶点置位1
		
		for(w=0; w&lt;G.numVertexes; w++)    //修改当前最短路径及距离
		{
			//如果经过v顶点的路径比现在这条的路径长度短的话
			if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[W]))
			{
				//说明找到了更短的路径，修改D[W]和p[W]
				（*D)[w]=min+G.arc[k][w];    //修改当前路径长度
				(*p)[w]=k;
			}
		}
	}
}
时间复杂度：o(n^2)

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200110010608603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110010632915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
数组D，数组P含义：上图中比如到v3的最短路径长度是7，比如到v5的最短路径长度是8。。<br>
数组p表示V0-----&gt;V8的最短路径中，P[8]=7表示V8的前驱节点为V7；P[4]=2表示V4的前驱节点是2.。。<br>
如果想要知道任意顶点开始到某结点的最短路径，那就没到一个结点就用一次迪杰斯特拉算法，这 样的复杂度为o(n^3)<br>
<img src="https://img-blog.csdnimg.cn/20200110010656741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：其实迪杰斯特拉算法目的是计算从某个点到某个点的最短路径，思想就是每次找到最短的路径，把他放入到已经找到的路径中，很漂亮的思想</p>
<p>7.7.2.FLoyd算法：求最短路径</p>
<pre><code class="language-cpp">typedef int Pathmatirx[MAXVEX][MAXVEX];
typedef int ShortPathTable [MAXVEX][MAXVEX];
//FLoyd算法，求网图中G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]
void ShorttestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)
{
	int v,w,k;
	for(v=0; v&lt;G.numVertexes; ++w)
	{
		for(w=0; w&lt;G.numVertexes; w++)
		{
			(*D)[v][w]=G.matirx[v][w];     //D[v][w]值即为对应点间的权值
			(*p)[v][w]=w;                 //初始化p
		}
	}
	for(k=0; k&lt;G.numVertexes; ++k)     //k相当于每次拐出来的点
	{
		for(v=0; v&lt;G.numVertexes; ++v)
		{
			for(w=0; w&lt;G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k]+(*D)[k][w])
				{
					//如果经过下标为k顶点路径比原两点间路径更短
					//将当前两点间权值设为更小的一个
					(*D)[v][w]=(*D)[v][k]+(*D)[k][w];
					(*p)[v][w]=(*p)[v][k];           //路径设置为下标为k的顶点
				}
			}
		}
	}
}   时间复杂度o(n^3)

</code></pre>
<p>最短路径的显示代码</p>
<pre><code class="language-cpp">for(v=0; v&lt;G.numVertexes; ++v)
{
	for(w=v+1; w&lt;G.numvertexes; w++)
	{
		printf(&quot;v%d-v%d weight: %d&quot;,v,w,D[v][w]);  //输出从某个点到某个点的路径权值
		k=p[v][w];       //获得第一个路径顶点的下标
		printf(&quot; path: %d&quot;,v);         //打印原点
		while(k!=w)            //如果路径顶点下标不是终点
		{
			printf(&quot; -&gt; %d&quot;,k);          //打印路径顶点
			k=p[k][w];           //获得下一个路径顶点下标，p数组已经设置好了
		}
		printf(&quot; -&gt; %d\n&quot;,w);     //打印终点
	}
	printf(&quot;\n&quot;);         
}

</code></pre>
<p>上面代码图示：<br>
<img src="https://img-blog.csdnimg.cn/20200110220429452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110215942248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
矩阵D表示从某个点到某个点的最短路径长度<br>
p矩阵的含义不用知道，只要知道怎么通过此矩阵找到最短路径<br>
以v0--v8<br>
首先p[0][8]=1,表示经过v1<br>
再看v[1][8]=2，表示经过v2<br>
再看v[2][8]=4, 表示经过v4.。。。。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200110220005694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：迪杰斯特拉算法和弗洛伊德算法的相同与不同：<br>
相同点：<br>
1.都是求某个点到某个点的最短路径<br>
2.核心思路都是不断的找最短的路径归并到已经找到的路径集合中<br>
不同点：<br>
1.D通过min+下一次的路径和直接到达路径长度比较；而F通过拐点k来表示i--&gt;k---&gt;j要比i---&gt;j路径要短<br>
2.最终得到的数组D都是表示vi到vj的最短路径，而p不同，其中D中p只能表示以v0为起点，到其余各点的最短路径；比如要想知道v2，v3...到其余各点的最短路径，只能再次将v2，v3当做源头再次使用D式算法。但是F式算法中p可以知道所有顶点到所有顶点的最短路径</p>
<p>7.8.2拓扑排序：判断工程能否顺利进行<br>
在一个有向图中，就像拍电影有先后顺序，这样的网图称为AOV图，如下所示：<br>
下图中的一个拓扑序列是：v0v1v2v3v4v5v6v7v8v9v10v11v12v13v14v15v16<br>
<img src="https://img-blog.csdnimg.cn/2020011221284919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
而且AOV图不存在回路，所以在输出时如果顶点数少了一个，则说明不是回路，如果顶点被全部输出，则说明它不存在回路。</p>
<p>对AOV网进行拓扑排序的基本思路：<br>
从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>
在拓扑排序算法中，涉及的结构代码如下，使用邻接表来构造：</p>
<pre><code class="language-cpp">​```cpp
typedef struct EdgeNode          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	int in;
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}graphAdjList,*GraphAdjList；

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200120200549858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
in表示入度域，下面的邻接表就是表示上图<br>
<img src="https://img-blog.csdnimg.cn/20200120200610526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
拓扑排序的代码：</p>
<pre><code class="language-cpp">//拓扑排序
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);        //打印此顶点
		count++;              //统计输出顶点数
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}
时间复杂度：
第一个for循环，一共n个顶点，时间复杂度为o(n)
下面while，从下图6可以看出，最后删除边都没有了，所以时间复杂度为o(e)
最终时间复杂度为o(n+e)

</code></pre>
<p>具体过程如下：<br>
先从v3开始<br>
<img src="https://img-blog.csdnimg.cn/20200120205711970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
打印输出v3<br>
<img src="https://img-blog.csdnimg.cn/20200120205731362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
依次类推，如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120205817307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200120205824667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
最终拓扑排序的结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;8-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11，当然这个拓扑排序结果不唯一</p>
<p>7.9关键路径：求完成工程最短的时间问题，利用求出关键路径算法，求出完成工程的最短时间和关键活动有哪些？<br>
1.关键路径用AOE表示，AOV表示活动之间以相互制约关系，而AOE是在AOV的基础上来分析完成整个活动所需的最短时间，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120210958150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
其中每个AOE网图都有一个源点和汇点<br>
路径长度：路径上各个活动所持续的时间之和称为路径长度<br>
从源点到汇点的具有最大长度的路径叫关键路径，关键路径上的活动叫关键活动<br>
<img src="https://img-blog.csdnimg.cn/20200120211017839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.9.1关键路径的算法原理：<br>
放学回家到睡觉，一共4个小时。写作业两个小时，最早开始时间是一回来，可以理解为0。最晚开始时间为2个小时之后，可以理解为2。当最早开始时间和最晚开始时间不相同时，表示有空闲时间。当买了很多的习题时，时间全部被占满，则最早和最晚开始时间为都是0，因此他就是关键活动。<br>
1.事件的最早发生时间etv：即顶点vk的最早发生时间<br>
2.事件的最晚发生时间ltv：即顶点vk的最晚发生时间，如果超过此时间，就会延误整个工期<br>
3.活动最早开工时间ete：即弧ak的最早发生时间<br>
4.活动最晚开工时间lte：即弧ak的最晚发生时间<br>
通过1,2求得3,4，然后根据ete[k]与lte[k]是否相等来判断ak是否为关键活动</p>
<p><img src="https://img-blog.csdnimg.cn/20200201213730233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
下列代码求etv的过程，与拓扑排序类似</p>
<pre><code class="language-cpp">int *etv, *ltv;           //时间最早发生时间和最迟发生时间数组
int *stack2;            //用于存储拓扑排序的栈
int top2;            //用于stack2的的指针

//拓扑排序，用于关键路径计算
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	top2=0;           //初始化为0
	etv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));        //事件最早发生的时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		etv[i]=0;             //初始化为0
	stack2=(int *)malloc(GL-&gt;numVertexes*sizeof(int));      //初始化
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		count++;              //统计输出顶点数
		stack2[++top2]=gettop;       //将弹出的顶点序号压入拓扑序列的栈
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
			if((etv[gettop]+e-&gt;weight)&gt;etv[k])     //求各顶点事件最早发生时间
				etv[k]=etv[gettop]+e-&gt;weight;
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}

</code></pre>
<p>上面代码的例子如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200201214810950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
对于v3来说，4+8&gt;3+5，所以v3=12。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200201214925217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关键路径的算法代码：</p>
<pre><code class="language-cpp">//求关键路径，GL为有向图，输出GL的各项关键活动
void CriticalPath(GraphAdjList GL)
{
	EdgNode *e;
	int i,gettop,k,j;
	int ete,lte;             //声明活动最早发生时间和最迟发生时间
	TopologicalSort(GL);           //求拓扑序列，计算数组etv和stack2
	ltv=(int *)malloc(GL-&gt;numverteces*sizeof(int));    //事件最晚发生时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		ltv[i]=etv[GL-&gt;numVertexes-1];    //初始化ltv
	while(top2!=0)      //计算ltv
	{
		gettop=stack2[top2--];   //将拓扑序列出栈，后进先出
		for(e=GL-&gt;adjList[gettop].firstedge; e; e=e-&gt;next)
		{
			//求各顶点最迟发生时间ltv
			k=e-&gt;adjvex;
			if(ltv[k]-e-&gt;weight&lt;ltv[gettop])   //求各顶点事件最晚发生时间
				ltv[gettop]=ltv[k]-e-&gt;weight;
		}
	}
	for(j=0; j&lt;GL-&gt;numVertexes; j++)    //求ete,lte和关键活动
	{
		for(e=GL-adjList[j].firstedge; e; e=e&gt;next)
		{
			k=e-&gt;adjvex;        
			ete=etv[j];       //活动最早发生时间
			lte=ltv[k]-e-&gt;weight;   //活动最迟发生时间
			if(ete=lte)                //两者相等即在关键路径上
				printf(&quot;&lt;v%d,v%d&gt; length: %d , &quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);
		}
	}
}


</code></pre>
<p>上述代码所求etv和ltv如下所示+关键路径如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200201220607841.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200201220623475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
总结：<br>
etv通过拓扑排序算出最早发生的时间，每次找权值较大的<br>
ltv相当于从后向前算出最晚发生时间，每次找权值较小的<br>
ete=etv[j]表示当事件发生时，最早开工时间（当然必须事件发生，才开工）<br>
lte=ltv[k]-e-&gt;weight表示事件最晚发生的时间-要完成工作的时间（比如23点睡觉，写作业2h，可以23点才开始写但要睡觉所以最晚开工时间是21点，最晚21点开始写，就是这意思，有点牵强，理解即可）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第8章笔记（查找）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-8-zhang-bi-ji-cha-zhao/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-8-zhang-bi-ji-cha-zhao/">
        </link>
        <updated>2020-03-01T04:12:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump">8.1开场白+8.2查找概论</a><br>
<a href="#jump1">8.3顺序表查找</a><br>
      <a href="#jump2">8.3.1顺序查找算法</a><br>
      <a href="#jump3">8.3.2顺序表查找优化</a><br>
<a href="#jump4">8.4有序表查找</a><br>
      <a href="#jump5">8.4.1折半查找</a><br>
      <a href="#jump6">8.4.2插值查找</a><br>
      <a href="#jump7">8.4.7裴波那契查找</a><br>
<a href="#jump8">8.5线性索引查找</a><br>
      <a href="#jump9">8.5.1稠密索引</a><br>
      <a href="#jump10">8.5.2分块索引</a><br>
      <a href="#jump11">8.5.3倒排索引</a></p>
<p><a href="#jump12">8.6二叉排序树</a><br>
      <a href="#jump13">8.6.1二叉排序树查找操作</a><br>
      <a href="#jump14">8.6.2二叉排序数插入操作</a><br>
      <a href="#jump15">8.6.3二叉排序树删除操作</a><br>
      <a href="#jump16">8.6.4二叉排序树总结</a><br>
<a href="#jump17">8.7（平衡二叉树）AVL树</a><br>
      <a href="#jump18">8.7.1平衡二叉树实现原理</a><br>
      <a href="#jump19">8.7.2平衡二叉树实现算法</a><br>
<a href="#jump20">8.8多路查找树</a><br>
<a href="#jump21">8.9散列表查找（哈希表）概述</a><br>
<a href="#jump22">8.10散列函数的构造方法</a><br>
<a href="#jump23">8.11处理散列冲突的方法</a><br>
<a href="#jump24">8.12散列表查找实现</a><br>
      <a href="#jump25">8.12.1散列表查找算法实现</a><br>
      <a href="#jump26">8.12.2散列表查找性能分析</a></p>
<p><span id="jump">8.1开场白+8.2查找概论</span><br>
<strong>1.查找表</strong>：静态查找表+动态查找表<br>
a.静态查找表：查询某个特定的数据元素是否在查找表中+检索某个特定的数据元素和各种属性<br>
b.动态查找表：查找时插入元素，查找时删除元素<br>
<strong>2.静态查找</strong>----线性结构组织数据+顺序查找法+对于主关键字排序可以使用折半查找<br>
<strong>3.动态查找</strong>----二叉排序树的查找技术</p>
<p><span id="jump1">8.3顺序表查找</span></p>
<ul>
<li>顺序查找过程：从表中第一个开始，逐个进行记录的关键字和给定值比较，若某个记录关键字和给定值相同则查找成功，如果找到最后一个，其关键字和给定值都不同，则查找失败</li>
<li><span id="jump2">8.3.1顺序查找算法代码</span></li>
</ul>
<pre><code class="language-cpp">/*顺序查找，a为数组，n为要查找的数组长度，key为要查找的关键字*/
int Sequential_Search(int *a,int n, int key)
{
	int i;
	for(i=1;i&lt;=n;i++)
	{
		if(a[i]==key)
		{
			return i;
		}
	}
	return 0;
}
</code></pre>
<blockquote>
<p>由于上面的查找中每次都要i&lt;=n的判断，实际上设置一个哨兵即可，如下代码</p>
</blockquote>
<ul>
<li><span id="jump3">8.3.2顺序表查找优化</span></li>
</ul>
<pre><code class="language-cpp">/*有哨兵顺序查找*/
int Sequential_Search2(int *a,int n,int key)
{
	int i;
	a[0]=key;        //设置a[0]为关键字值，称为“哨兵”
	i=n;             //循环从数组尾部开始
	while(a[i]!=key)
	{
		i--;
	}
	return i;    //返回0则查找失败
}
</code></pre>
<blockquote>
<p>此代码从尾部开始查找，a[0]=key，如果在a[i]中有key则返回i值，查找成功。否则一定在最终的a[0]处等于key，此时返回0，说明查找失败</p>
</blockquote>
<p><span id="jump4">8.4有序表查找</span></p>
<ul>
<li><span id="jump5">8.4.1折半查找</span></li>
</ul>
<blockquote>
<p>思想：折半查找的前提是线性表中的记录必须是关键码有序（通常从小到大）。在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右边区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败</p>
</blockquote>
<p>参考代码：<strong>折半查找时间复杂度o(logn)</strong></p>
<pre><code class="language-cpp">/*折半查找*/
int Binary_Search(int *a,int n, int key)
{
	int low,high,mid;
	low=1;                  //定义最低下标为记录首位
	high=n;                  //定义最高下标为记录末位
	while(low&lt;=high)
	{
		mid=(low+high)/2;         //折半
		if(key&lt;a[mid])        //若查找值比中指小
			high=mid-1;
		else if(key&gt;a[mid])     //若查找值比中指大
			low=mid+1;         //最底下标调整到中位下标大一位
		else 
			return mid;         //若相等则说明mid即为查找到的位置
	}
	return 0;
}
</code></pre>
<p>查找过程如下：<br>
<img src="https://img-blog.csdnimg.cn/2020020322192170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200203221858846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
用二叉树示意如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200203221500884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><span id="jump6">8.4.2插值查找</span></li>
</ul>
<blockquote>
<p>插值查找时根据要找的关键字key与查找表中最大最小的关键字比较后的查找方法，其核心在于插值公式如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200204210604921.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<pre><code class="language-cpp">将折半查找的第8行代码改为：mid=low+(high-low)*(key-a[low])/(a[high]-a[low]); 
</code></pre>
<ul>
<li><span id="jump7">8.4.3裴波那契查找</span></li>
</ul>
<p>参考代码：</p>
<pre><code class="language-cpp">//裴波那契查找
int Fibonacci_Search(int *a,int n,int key)
{
	int low,high,mid,i,k;
	low=1;           //定义最低下标为记录首位
	high=n;            //定义最高下标为记录末位
	k=0;           
	while(n&gt;F[k]-1)     //计算n位于裴波那契数列的位置，F[k]就是裴波那契数列，a[n]就是要查找的数列
		k++;
	for(i=n; i&lt;F[k]-1; i++)    //将不满的数值补全
		a[i]=a[n];
	while(low&lt;=high)
	{
		mid=low+F[k-1]-1;       //计算当前分隔的下标
		if(key&lt;a[mid])         //若查找记录小于当前分隔记录
		{
			high=mid-1;          //最高下标调整到分隔下标mid-1处
			k=k-1;          //裴波那且数列下标减一位
		}
		else if(key&gt;a[mid])     //若查找记录大于当前分隔记录
		{
			low=mid+1;          //最低下标调整到分隔下标mid+1处
			k=k-2;         //裴波那契数列下标减2位
		}
		else 
		{
			if(mid&lt;=n)
				return mid;        //若相等则说明mid即为查找到的位置
			else 
				return n;       //若mid&gt;n说明是补全数值，返回n
		}
	}
	return 0;
}

</code></pre>
<p>代码过程如下图：<br>
<img src="https://img-blog.csdnimg.cn/2020020421202886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200204212039617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>时间复杂度为o(logn)，但就平均性能而言要优于折半查找</p>
</blockquote>
<p><span id="jump8">8.5线性表的索引查找</span></p>
<ul>
<li><span id="jump9">8.5.1稠密索引</span></li>
</ul>
<blockquote>
<p>1.稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，索引项一定是按照关键码的有序排列<br>
2.查找关键字可以用折半查找，插值，裴波那契...查找方法<br>
3.如果对于右边的表进行查找，只能进行顺序查找<br>
如下图所示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200204214358391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><span id="jump10">8.5.2分块索引</span></li>
</ul>
<blockquote>
<p>分块索引的条件：<br>
1.块内无序：<br>
2.块间有序：要求后一块中所记录的关键字都大于第一块中所有记录的关键字，并且无序排列（如下图）</p>
</blockquote>
<blockquote>
<p>分块索引的数据项：<br>
1.最大关键码：记录块间中的最大关键字<br>
2.存储块中记录的个数，便于循环使用<br>
3.用于指向块首数据元素的指针，便于进行遍历</p>
</blockquote>
<blockquote>
<p>分块索引的步骤：<br>
1.在块内进行折半查找，插值查找...比如找62， 57&lt;62&lt;96在第三个块中<br>
2.根据块首指针找到相应的块，然后只能进行顺序查获</p>
</blockquote>
<p>分块索引的平均查找长度是根号N+1，时间复杂度为o(n)<br>
<img src="https://img-blog.csdnimg.cn/20200204215835239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><span id="jump11">8.5.3倒排序索引</span><br>
1.根据句子中单词，做一张单词表，然后在搜索框中，输入book，就能对应编号为1,2的文章地址，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200204220611135.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200204220624233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<blockquote>
<p>索引项的通用结构是：<br>
1.次关键码：英文单词，相当于属性<br>
2.记录号表：文章编号，相当于记录的地址<br>
根据属性来找地址，称为倒排</p>
</blockquote>
<ul>
<li><span id="jump12">8.6二叉排序树</span></li>
</ul>
<blockquote>
<p>1.查找时插入或删除的查找表称为动态查找表，用二叉排序树这样的数据结构进行存储</p>
</blockquote>
<p>比如下图中将58插入进去，对于线性表而言还要进行移位，但对于二叉树结构而言直接将58插入到62的左子树。这就是二叉排序树的方便之处。<br>
<img src="https://img-blog.csdnimg.cn/20200206215810741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.二叉树性质：<br>
    若他的左子树不空，则左子树上所有的结点的值小于它的根结构的值<br>
    若他的右子树不空，则右子树上所有的结点的值大于它的根结构的值<br>
3.对于数列{35,37,47,51,58,62,73,88,93,99}而言，具体的二叉排序树如下图所示</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200206220326298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">8.6.1二叉排序树查找操作</span></p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode              //结点结构
{
	int data;                         //结点数据
	struct BiTNode *lchild,*rchild;     //左右孩子指针
}
</code></pre>
<pre><code class="language-cpp">//递归查找二叉排序树T中是否存在key
//指针f指向T的双亲，其初始调用值为NULL
//若查找成功，则指针p指向该数据元素结点，并返回TRUE
//否则指针p指向查找路径上访问的最后一个结点并返回false
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{	
	if(!T)    //查找不成功
	{
		*p=f;
		return FALSE;
	}
	else if(key==T-&gt;data)   //查找成功
	{
		*p=T;
		rerturn TRUE;
	}
	else if(key&lt;T-&gt;data)
		return SearchBST(T-lchild,key,T,p);   //在左子树继续查找
	else
		return SearchBST(T-&gt;rchild,key,T,p);    //在右子树继续查找
}

</code></pre>
<p>详细过程见下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200210205514299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210205524491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump14">8.6.2二叉排序数插入操作</span></p>
<pre><code class="language-cpp">//当前二叉排序树T中不存在关键字等于key的数据元素
//插入key并返回TRUE，否则返回FALSE
Status InsertBST(BiTree *T,int key)
{
	BiTree p,s;
	if(!SearchBST(*T,key,NULL,&amp;p))     //查找不成功
	{
		s=(BiTree)malloc(sizeof(BiTNode));
		s-&gt;data=key;
		s-&gt;lchild=s-&gt;rchild=NULL;
		if(!p)
			*T=s;          //插入s为新的根结点
		else if(key&lt;p-&gt;data)    //插入s为左孩子
			p-&gt;lchild=s;    
		else
			p-&gt;rchild=s;    //插入s为右孩子
		return TRUE;
	}
	else
		return FALSE;    //树中已有关键字相同的结点，不再插入
}
</code></pre>
<p>下面代码展示如何将数组a[10]={62,88,58,47,35,73,51,99,37,93}，插入到一颗二叉树中</p>
<pre><code class="language-cpp">int i;
int a[10]={62,88,58,47,35,73,51,99,37,93};
BiTree T=NULL;
for(i=0; i&lt;10; i++)
	InsertBST(&amp;T,a[i);

</code></pre>
<p>上述代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200210220504209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     <span id="jump15">8.6.3二叉排序树删除操作</span><br>
分为3 种情况：</p>
<ul>
<li>叶子结点：直接删除就行</li>
<li>仅有左或右子树的结点：<br>
删除结点后，将他的左子树或右子树整个移动到删除结点的位置即可，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200210215813523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210215741243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
<li>左右子树均有结点：<br>
找到需要删除结点p的直接前驱或者直接后继s，将s来替换结点p，然后在删除结点s，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200210215902234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/2020021021584512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<table><tr><td bgcolor=GreenYellow>下面代码这个算法是递归方式对二叉排序树T查找key，查找时删除</td></tr></table>
<pre><code class="language-cpp">//若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素的结点
//并返回TRUE，否则返回FALSE
Status DeleteBST(BiTree *T,int key)
{
	if(!*T)    //不存在关键字等于key的数据元素
		return FALSE;
	else
	{
		if(key==(*T)-&gt;data)    //找到关键字等于key的数据元素
			return FALSE;
		else if(key&lt;(*T)-&gt;data)   
			return DeleteBST(&amp;(*T)-&gt;lchild,key);
		else
			return DeleteBST(&amp;(*T)-&gt;rchild,key);
	}
}

</code></pre>
<table><tr><td bgcolor=GreenYellow>Delete代码</td></tr></table>
<pre><code class="language-cpp">//从二叉排序树中删除结点p，并重接他的左或者右子树
Status Delete(BiTree *p)
{
	BiTree q,s;
	//下if和else if只适合只有左或者右子树的结点
	if((*p)-&gt;rchild==NULL)        //右子树空则只需重接它的左子树
	{
		q=*p;
		*p=(*p)-&gt;lchild;
		free(q);
	}
	else if((*p)-&gt;lchild==NULL)  //只需连接他的右子树
	{
		q=*p;
		*p=(*p)-&gt;rchild;
		free(q);
	}
	else  //左右子树均不为空
	{
		q=*p;
		s=(*p)-&gt;lchild;   
		while(s-&gt;rchild)        //转左，然后向右到尽头（找到待删除结点的前驱）
		{
			q=s;
			s=s-&gt;rchild;
		}
		(*p)-&gt;data=s-&gt;data;       //s指向被删除结点的直接前驱
		if(q!=*p)
			q-&gt;rchild=s-&gt;lchild;   //重接q的右子树
		else
			q-&gt;lchild=s-&gt;lchild;     //重接q的左子树
	}
	return TRUE;
}

</code></pre>
<p>上述代码的详细过程，如下：<br>
<img src="https://img-blog.csdnimg.cn/20200210220324278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210220344448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021022035938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210220420698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     <span id="jump16">8.6.4二叉排序树总结</span><br>
1.优点：插入时小的数字插入到结点左子树，大的数字插入到结点的右子树，操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。<br>
2.对于二叉树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。<br>
3.极端情况就是，最少为1次，即根结点就是要找到的结点，最多不会超过树的深度<br>
4.如下图中，左边的图查找99要2次，右边的图查找99要10次。左图的时间复杂度就是o(logn)，右图的时间复杂度为o(n)<br>
<img src="https://img-blog.csdnimg.cn/20200210215629904.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>     <span id="jump17">8.7平衡二叉树（AVL树）</span></p>
<blockquote>
<p>AVL树相关概念：<br>
·1.定义：平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，也就是高度差的绝对值&lt;=1<br>
2.平衡因子（BF）：将二叉树的左子树深度---右子树深度的值称为平衡因子<br>
3.平衡二叉树上所有结点的平衡因子只可能是-1,0，1。只要二叉树上有一个结点的平衡因子的绝对值&gt;1，则该树就是不平衡的，<br>
4.平衡二叉树首先是一个二叉排序树（即小的值在左子树，大的值在右子树上）。详见下图中的几个例子：</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020021122325486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200211223952222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>     <span id="jump18">8.7.1 平衡二叉树实现原理</span></p>
<blockquote>
<p>平衡二叉树构建的基本思想：每当插入一个结点时，先检查是够因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。（详细见下图）<br>
<img src="https://img-blog.csdnimg.cn/20200211225134137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200211225154389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021122520626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200211225217518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>     <span id="jump19">8.7.2 平衡二叉树实现算法</span><br>
1.首先是需要改进二叉排序树的结点结构，增加一个bf值，用来存储平衡因子，参考代码如下：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义
typedef struct BiTNode        //结点结构
{
	int data;            //结点数据
	int bf;					//结点的平衡因子
	struct BiTNode *lchild, *rchild;   //左右孩子指针
}BiTNode,*BiTree;

</code></pre>
<p>对于右旋转，代码如下：</p>
<pre><code class="language-cpp">/*
	对以p为根的二叉排序树做右旋处理，处理之后p指向新的树根结点，即旋转处理之前的右子树的根结点
*/
void R_Rotate(BiTree *p)
{
	BiTree L;
	L=(*p)-&gt;lchild;       //L指向p的左子树的根结点
	(*p)-&gt;lchild=L-&gt;rchild;   //L的右子树挂接为p的左子树
	L-&gt;rchild=(*p);
	*p=L;          //p指向新的根结点
}
//详见如下图:

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200211230510573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
左旋代码操作如下：</p>
<pre><code class="language-cpp">//对以p为根的二叉排序树做左旋处理，处理之后p指向新的树根结点，即旋转处理之前的右子树根结点
void L_Rotate(BiTree *P)
{
	BiTree R;
	R=(*P)-&gt;rchild;     //R指向p的右子树根结点
	(*P)-&gt;rchild=R-&gt;lchild;       //R的左子树挂接为p的右子树
	R-&gt;lchild=(*P); 
	*P=R;                       //P指向新的根结点
}
//详见下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200212204441135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
左平衡旋转处理的函数代码：</p>
<pre><code class="language-cpp">#define LH +1     //左高
#define EH 0         //等高
#define RH -1     //右高
//对以指针T所指结点为根的二叉树做左平衡旋转处理，本算法结束时，指针T指向新的根结点
void LeftBalance(BiTree *T)
{
	BiTree L,Lr;
	L=(*T)-&gt;lchild;    //L指向T的左子树根结点
	switch(L-&gt;bf)
	{
		//检查T的左子树的平衡度，并做相应的平衡处理
		case LH:          //新结点插入在T的左孩子的左子树上，要做单右旋转处理
			(*T)-&gt;bf=L-&gt;bf=EH;
			R_Rotate(T);
			break;
		case RH:          //新结点插入在T的左孩子的左子树上，要做单右旋处理
			Lr=L-&gt;rchild;    //Lr指向T的左孩子的右子树根
			switch(Lr-&gt;bf)        //修改T及其左孩子的平衡因子
			{
				case LH:   
					(*T)-&gt;bf=RH;
					L-&gt;bf=EH;
					break;
				case EH:
					(*T)-&gt;bf=L-&gt;bf=EH;
					break;
				case RH:
					(*T)-&gt;bf=EH;
					break;
			}
			Lr-&gt;bf=EH;
			L_Rotate(&amp;(*T)-&gt;lchild);       //对T的左子树做左旋平衡处理
			R_Rotate(T);          //对T做右旋平衡处理
	}
}   //详见代码如下图所示：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020021220570528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
对于先右旋后左旋的代码类似上面，过程如下图：<br>
<img src="https://img-blog.csdnimg.cn/2020021220590779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
主函数：</p>
<pre><code class="language-cpp">//若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个
//数据元素为e的新结点并返回1，否则返回0。若因插入而使二叉排序树失去平衡，则做平衡旋转处理，布尔变量taller反映T长高与否
Status InsertAVL(BiTree *T, int e, Status *taller)
{
	if(!*T)           //不存在与e有相同关键字的结点
	{
		*T=(BiTree)malloc(sizeof(BiTNode));   
		(*T)-&gt;data=e;
		(*T)-&gt;lchild=(*T)-&gt;rchild=NULL;
		(*T)-&gt;bf=EH;
		*taller=TRUE;
	}
	else
	{
		if(e==(*T)-&gt;data)
		{
			//树中已存在和e有相同关键字的结点则不再插入
			*taller=FALSE;
			return FALSE;
		}
		if(e&lt;(*T)-&gt;data)
		{
			//应继续在T的左子树中进行搜索
			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))    //未插入
				return FALSE;
			if(*taller)          //已插入到T的左子树中且左子树长高
			{
				switch((*T)-&gt;bf)   //检查T的平衡度
				{
					case LH:    //原本左子树比右子树高，需要做左平衡处理
						LeftBalance(T);
						*taller=FALSE;
						break;
					case EH:     //原本左右子树等高，现因左子树增高而树增高
						(*T)-&gt;bf=LH;
						*taller=TRUE;
						break;
					case RH:      //原本右子树比左子树高，现左右子树等高
						(*T)-&gt;bf=EH;
						*taller=FALSE;
						break;
				}
			}
		}
		else
		{     //应继续在T的右子树中进行搜索
			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller))   //未插入
				return FALSE;
			if(*taller)    //已插入到T的右子树且右子树“长高”
			{
				switch(((*T)-&gt;bf)   //检查T的平衡度
				{
					case LH:    //原本左子树比右子树高，现左右子树的等高
						(*T)-&gt;bf=EH;
						*taller=FALSE;
						break;
					case EH:        //原本左右子树等高，现因右子树增高而树增高
						(*T)-&gt;bf=RH;
						*taller=TRUE;
						break;
					case RH:     //原本右子树比左子树高，需要做右平衡处理
						RightBalance(T);
						*taller=FALSE;
						break;
				}

			}
			 
		}
	}
	return TRUE;
}//具体过程如下图：

</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2020021221205438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>构建一个数组为a[10]={3,2,1,4,5,6,7,10,9,8}  代码如下：</p>
</blockquote>
<pre><code class="language-cpp">int i;
int a[10]={3,2,1,4,5,6,7,10,9,8};
BiTree T=NULL;
Status taller;
for(i=0; i&lt;10; i++)
	InsertAVL(&amp;T,a[i],&amp;taller);

</code></pre>
<table><tr><td bgcolor=GreenYellow>如果二叉排序树是平衡二叉排序树，查找+插入+删除 时间复杂度为o(logn)</td></tr></table>
<p><span id="jump20">8.8多路查找树</span></p>
<blockquote>
<p>1.多路查找树出现的原因：我们之前谈的树，都是一个结点可以有很多孩子，但是它自身只存储一个元素。二叉树限制更多，结点最多只能有两个孩子。一个结点只能存储一个元素，在元素非常多的时候，就使得要么树的度（结点拥有子树的个数最大值）非常大，要么树的度非常高，甚至两者都必须足够大才行。这就使得内存存取次数非常多，这显然成立时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制</p>
</blockquote>
<p>2.多路查找树的定义：<br>
<img src="https://img-blog.csdnimg.cn/20200214212049283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.2-3树定义，插入，查找：<br>
<img src="https://img-blog.csdnimg.cn/20200214212354645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212427427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002142124465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212507804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212521593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212543599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212601599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4 2-3-4树<br>
<img src="https://img-blog.csdnimg.cn/20200214212808329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212740345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.B树的定义+属性+最坏的查找次数：<br>
<img src="https://img-blog.csdnimg.cn/20200214213101512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214213126322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.B+树的引用+定义+m阶B+树和B树的差异+B+树的优点：<br>
<img src="https://img-blog.csdnimg.cn/20200214213652902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
、<img src="https://img-blog.csdnimg.cn/20200214213701920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump21">8.9散列表查找（哈希表）概述</span><br>
1.散列表查找定义+查找步骤+散列技术适用于什么+散列表缺点+冲突：<br>
<img src="https://img-blog.csdnimg.cn/20200214215354439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214215411824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214215437361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump">8.10散列函数的构造方法</span><br>
1.构造散列函数的原则：<br>
<img src="https://img-blog.csdnimg.cn/20200214221453690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214221513780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.直接定址法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221543178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.数字分析法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221601823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.平方取中法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221622361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.折叠法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221639252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.除留余数法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221656696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214221716657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.随机数法：<br>
<img src="https://img-blog.csdnimg.cn/2020021422173735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
8.采用不同散列函数考虑的因素：<br>
<img src="https://img-blog.csdnimg.cn/20200214221754125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump23">8.11处理散列冲突的方法</span><br>
1.开放地址法+二次探测法+随机探测法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225545630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225603825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200214225631821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>2.再散列函数法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225831308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.链地址法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225846786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225902904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.公共溢出区法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225920224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225934127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
除留<br>
<span id="jump24">8.12 散列表查找实现</span><br>
     <span id="jump25">8.12.1 散列表查找算法实现</span><br>
                1.散列表结构和一些相关常数。其中HashTable是散列表结构，结构中的elem为一个动态数组</p>
<pre><code class="language-cpp">#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12       //定义散列表长为数组长度
#define NULLKEY -32768
typedef struct 
{
	int *elem;           //数据元素存储基址，动态分配数组，就是数组的初始地址
	int count;			//当前数据元素的个数
}HashTable;
int m=0;              //散列表表长，全局变量

</code></pre>
<p>对散列表进行初始化</p>
<pre><code class="language-cpp">Status InitHashTable(HashTable *H)
{
	int i;
	m=HASHSIZE;
	H-&gt;count=m;
	H-&gt;elem=(int *)malloc(m*sizeof(int));
	for(i=0; i&lt;m; i++)
		H-&gt;elem[i]=NULLKEY;
	return OK;
}

</code></pre>
<p>散列函数：</p>
<pre><code class="language-cpp">int Hash(int key)
{
	return key%m;       //除留余数法
}

</code></pre>
<p>对散列表的插入操作</p>
<pre><code class="language-cpp">//插入关键字进散列表
void InsertHash(HashTable *H, int key)
{
	int addr=Hash(key);   //求散列地址
	while(H-&gt;elem[addr]!=NULLKEY)   //如果不为空，则冲突
		addr=(addr+1)%m;       //开放地址法的线性探测
	H-&gt;elem[addr]=key;             //直到有空位后插入关键字
}

</code></pre>
<p>对散列表的查找记录的操作</p>
<pre><code class="language-cpp">//散列表查找关键字
Status SearchHash(HashTable H, int key, int *addr)
{
	*addr=Hash(key);    //求关键字的散列地址
	while(H.elem[*addr]!=key)    //如果不为key，则继续循环查找
	{
		*addr=(*addr+1)%m;            //开放地址法线性探测
		if(H.elem[*addr]==NULLKEY || *addr=Hash(key))     //前面表示压根数组中就没有要查找的key，或者循环找了一圈，又回到起点
			return UNSUCCESS;                 
	}
	return SUCCESS;
}

</code></pre>
<p>     <span id="jump26">8.12.2 散列表查找性能分析</span><br>
            1.时间复杂度是O(1)<br>
            2.散列查找的平均查找长度取决于哪些因素？<br>
                  1.散列函数是否均匀：散列函数的好坏直接影响出现冲突的频繁程度<br>
                  2.处理冲突的方法：相同的关键字，相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能<br>
                  3.散列表的装填因子：装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满程度，当然α越大表示装满程度越高，也就是产生冲突的可能性越大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。不管记录个数n有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围，此时散列表的复杂度为O(1)，通常将散列表的空间设置得比查找集合大，虽然浪费空间，但效率提升。</p>
<p>​</p>
]]></content>
    </entry>
</feed>