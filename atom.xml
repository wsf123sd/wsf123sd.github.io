<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wsf123sd.github.io/</id>
    <title>Gridea</title>
    <updated>2020-03-01T15:27:43.495Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wsf123sd.github.io/"/>
    <link rel="self" href="https://wsf123sd.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wsf123sd.github.io/images/avatar.png</logo>
    <icon>https://wsf123sd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[c语言网第一，二章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:27:07.000Z</updated>
        <content type="html"><![CDATA[<p>#include<iostream>       头文件<br>
using namespace std;        std名称空间</p>
<p>int main(int argc, char** argv)<br>
{<br>
int a=5;<br>
char b='N';<br>
float c=3.14;<br>
double d=56.789;</p>
<pre><code>bool e;  //布尔值 

e=true;
cout &lt;&lt; e &lt;&lt; endl;
e=false;
cout &lt;&lt; e &lt;&lt; endl;

/*
cout &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; '\n' &lt;&lt; endl;
cout &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; c &lt;&lt; endl;
cout &lt;&lt; d &lt;&lt; endl; 
*/

return 0;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第三章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>#include<iostream><br>
#include<iomanip><br>
using namespace std;<br>
int fun(int a, int b, int c);<br>
/*<br>
函数定义：返回值类型 函数名 形参表<br>
函数定义顺序：函数声明-&gt;主函数-&gt;函数定义<br>
函数的思想：低耦合，高为聚（函数之间耦合度要低，高维聚表示函数的功能尽可能集中）<br>
*/<br>
int main()<br>
{<br>
int a,b,c;<br>
cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>
cout &lt;&lt; fun(a,b,c);<br>
return 0;<br>
}<br>
int fun(int a, int b, int c)<br>
{<br>
return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;<br>
}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第四章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:25:40.000Z</updated>
        <content type="html"><![CDATA[<p>1.二维数组</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;


int main()
{
    int b[3][4]={1,2,3,4,5};  //二维数组用双层for循环
    
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;4; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p>2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;  //一定是cstring不是string
#include&lt;iomanip&gt;
using namespace std;

int main ()
{
    //strcmp
    //strlen
    //strcpy
    //strcat
    char a[100]=&quot;hello&quot;;
    char b[100]=&quot;helleajsdkl&quot;;
    /*
        字符串比较，如果相同返回0‘如果第一个大，返回1,；如果第2个大，返回负值。
        从左到右比较时第一个不同比较完就完
    */
    cout &lt;&lt; strcmp(a,b) &lt;&lt; endl;
    cout &lt;&lt; strlen(a) &lt;&lt; endl;  //字符串实际长度

    /*
        要想重新给字符数组赋值，只能一个一个赋，别无他法，如下代码
    */
    a[0]='w';
    a[1]='o';
    a[2]='r';
    a[3]='l';
    a[4]='d';

    /*
        或者也可以这样,如下代码
    */
    strcpy(a,&quot;fuck you&quot;);
    cout &lt;&lt; a &lt;&lt; endl;

    //字符串连接
    strcat(a,b);
    cout &lt;&lt; a;
   
    return 0;
}

</code></pre>
<p>3.string类的字符串翻转</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
    string str = &quot;song&quot;;
    reverse(str.begin(), str.end());
    cout &lt;&lt; str;
    return 0;
}

</code></pre>
<p>字符串使用：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a=&quot;fuck you&quot;,b;  //string是一个类，不用考虑开辟多少存储空间
    a=&quot;asdfkasdkl&quot;;   //string的赋值使用
    b=&quot;world&quot;;
    /*
        字符串的比较
    
    if(a==b)
        cout &lt;&lt; &quot;==&quot;;
    else
        cout &lt;&lt; &quot;!=&quot;;*/
        
    /*拼接字符a与b
    a=a+b;   
    cout &lt;&lt; a;
    */
    return 0;
}

//****************string的小用法********************
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string user;
    string passwd;

    cin &gt;&gt; user;  //string使用空格和回车结束
    cin &gt;&gt; passwd;

    if(user==&quot;admin&quot; &amp;&amp; passwd==&quot;dotcpp&quot;)
    {
        cout &lt;&lt; &quot;yes&quot;;
    }
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}


</code></pre>
<p>指针的使用：<br>
1.指针基本使用<br>
2.数组的指针的使用<br>
3.指针作为函数参数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int swap(int *a, int *b)
{
    /*当函数结束，不会交换值
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;*/
    
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    return 0;

}
int main()
{
    /*指针基本使用
    int a;
    int *p;
    p=&amp;a;   //&amp;取地址运算符,p存放a的地址或p指向a
    *p=99;   //相当于对a进行赋值
    cout &lt;&lt; *p &lt;&lt; endl;*/

    /*数组的指针的使用
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    int *p;
    p=&amp;a[0];
    for(int i=0; i&lt;10; i++)
        cout &lt;&lt; *(p+i) &lt;&lt; endl;  //*(p+i) == a[i] */

    int a=10,b=20;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;

    return 0;
}

</code></pre>
<p>输出字符数组的三种写法+二维数组的指针使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()
{
    /*输出字符数组的三种写法
    char str[100]=&quot;www.dotcpp.com&quot;;
    char *p;
    p=str; //相当于p=&amp;str[0];
    for(int i=0; i&lt;strlen(str); i++)
    {
        //cout &lt;&lt; *(p+i) &lt;&lt; endl; 第一种写法

        第二种写法
        cout &lt;&lt; *p &lt;&lt; endl;
        p++;

        cout &lt;&lt; p[i] &lt;&lt; endl;    //基址+偏移  第三种写法
    }*/

    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同
    p=str;         //相当于将str[0]行赋给p

    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(str[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);  //p+i就是向下走行，后面+j表示走列
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p>二维数组指针作为函数参数的使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int fun(char (*p)[100])
{
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(p[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);
        cout &lt;&lt; endl;
    }
    return 0;
}
int main()
{
    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同

    fun(str);
    return 0;
}

</code></pre>
<p>引用+引用作为参数进行数字交换</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int fun(int &amp;a, int &amp;b)     //使用引用来传递参数
{
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;
}
int main()
{
    /*
    int a;
    int &amp;b=a;  //引用用法，a与b共用一个存储单元，必须初始化
    a=10;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    a=99;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;*/
    int a=20;
    int b=30;
    fun(a,b);         //直接调用时输出a,b
    cout &lt;&lt; a &lt;&lt; b;
    return 0;
}




</code></pre>
<p>new和delete分配和释放空间</p>
<pre><code class="language-cpp">1.普通变量的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    //栈空间
    //int a;
    //char b[100];

    //堆空间
    int *p;
    //p=new int;  //申请一个四个字节空间来存整数，并返回四个字节空间首地址
    p=new int(50);  //申请空间时，直接赋值
    //*p=90;
    cout &lt;&lt; *p &lt;&lt; endl;

    delete p;     //一定要释放空间，释放掉指针，new和delete成双成对出现

    return 0;
}

2.数组的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int *p2;
    //p2=new int[100](); //给数组初始化为0
    
    p2=new int[100]{8,7,3,4,5};  //给数组赋不同的值
    
    cout &lt;&lt; p2[0] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];
    
    delete []p2;  //释放定义数组的空间，注意【】不能少
    
    return 0;
}


3.结构的使用
#include&lt;iostream&gt;
using namespace std;
struct stu
{
    string name;
    int num;
    char sex;
};
int main()
{
    stu *p3;
    p3=new stu;
    //p3=new stu{&quot;zhangsan&quot;,1001,'W'}; 不推荐这样赋值，需要c11标准

    p3-&gt;name=&quot;zhangsan&quot;;
    p3-&gt;num=1001;
    p3-&gt;sex='w';

    cout &lt;&lt; p3-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;sex;

    delete p3;
    return 0;
}

</code></pre>
<p>结构使用：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{
    //struct student A;   //struct student是一个类型，相当于int
    
    student A={1001,&quot;zhangxiaosan&quot;,'W'};     //C++允许这样定义,赋值的时候要和定义时的相同

    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex &lt;&lt; endl;

    /*赋值的一种方式*/
    A.name=&quot;wangxiaoer&quot;;
    A.num=1001;
    A.sex='M';
    
    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex;
    return 0;
}

2.结构指针的使用
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A={1001,&quot;zhangxiaosan&quot;,'W'};
    student *p;
    p=&amp;A;
    
    //以下是指针的两种使用方式
    cout &lt;&lt; (*p).num &lt;&lt; &quot; &quot; &lt;&lt; (*p).name &lt;&lt; &quot; &quot; &lt;&lt; (*p).sex &lt;&lt; endl;
    cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex;
    return 0;
}

3.结构数组的使用
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;    //占位宽setw函数
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A[100]={{1000,&quot;zhangxiaosan&quot;,'W'},{1001,&quot;zhangsan&quot;,'M'},{1002,&quot;lisi&quot;,'W'},{1003,&quot;wangwu&quot;,'W'},{1004,&quot;xiapliu&quot;,'W'}};
    student *p;
    p=A;
    for(int i=0; i&lt;5; i++)
    {
        //cout &lt;&lt; A[i].num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; A[i].name &lt;&lt; &quot; &quot; &lt;&lt; A[i].sex &lt;&lt; endl;
        
        /*使用指针来输出
         cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex &lt;&lt; endl;
         p++;   //p每次走一个结构体  */
    }
    return 0;
}


</code></pre>
<p>4.共用体</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//共用体:num和s共用一个4个字节内存
union stu
{
    int num;
    char s;
};
int main()
{
    stu A;
    A.num=10;
    cout &lt;&lt; A.num &lt;&lt; endl;   //00000000 00000000 00000000 00001010
    A.s='B';             //66 00000000 00000000 00000000 01000010
    cout &lt;&lt; A.s &lt;&lt; endl;
    cout &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.s;  //最后输出的时候01000010会替换00001010，则前面的sum该为66，后面输出字符
    return 0;
}


</code></pre>
<p>5.枚举类型</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

//枚举类型:默认从0开始，但也可以赋值
enum week
{
    Sun=30,Mon,Tue,Wed,Thu,Fri,Sat
} ;

int main()
{
    week W;
    W=Tue;
    W=Sat;
    cout &lt;&lt; W;
    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第五章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:24:37.000Z</updated>
        <content type="html"><![CDATA[<p>#include<iostream><br>
#include<string><br>
#include<algorithm></p>
<p>using namespace std;<br>
//STL(标准模板库):容器（链表，堆，栈....），迭代器（类似于指针），算法<br>
//sort<br>
//reverse<br>
//accumulate</p>
<p>int main()<br>
{<br>
int a[5]={1,3,5,4,2};</p>
<pre><code>//sort排序中要放两个指针，第一个是起始地址，第二个是结束地址，但是要给数组最后一个元素的下一个地址,sort默认为升序排列
sort(&amp;a[0],&amp;a[5]);     
for(int i=0; i&lt;=4; i++)
    cout &lt;&lt; a[i] &lt;&lt; endl;

//reverse用法：sort+reverse可以降序排列
reverse(&amp;a[0],&amp;a[5]);
for(int i=0; i&lt;=4; i++)
    cout &lt;&lt; a[i] &lt;&lt; endl;
return 0;
</code></pre>
<p>}</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat乙级]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji/">
        </link>
        <updated>2020-03-01T15:20:42.000Z</updated>
        <content type="html"><![CDATA[<p>1001解题思路：<br>
1.用while+if-else来控制循环次数（砍得的次数）和判断奇数偶数</p>
<p>我的代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std;

int main()
{
	int n,step=0;
	cin &gt;&gt; n;
	while(n!=1)
	{ 
		if(n%2==0)
			n/=2;
		else
			n=(3*n+1)/2;
		step++;
	} 
	cout &lt;&lt; step;
	return 0;
}
</code></pre>
<p>别人的代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, count = 0;
 cin &gt;&gt; n;
 while (n != 1)
  {
	 if (n % 2 != 0)      //这个循环就是判断奇数的，n为奇数*3+1完了，在下一句除2 这样就省掉了加括号的麻烦 抓住了不管奇数还是偶数                         
//都有除2的特点 如果n为偶数不执行此语句，直接再下面除2
		 n = 3 * n + 1;   
	 n = n / 2;
	 count++;
 }
 cout &lt;&lt; count;
 return 0; }
</code></pre>
<p>1002解题思路：<br>
1.用string类来存储数据，不然的话double，long long类型的长度不够</p>
<ol start="2">
<li>用for循环来计算各位数字之和</li>
<li>用string类定义一个数组，其中成员是数字的拼音</li>
<li>将数字和变量改为字符串类型，方便调用每个位数字，不用对数字除或求余</li>
<li>通过循环从数字和的字符串中对应找到string类的数字拼音</li>
</ol>
<p>my code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
	string s;
	cin &gt;&gt; s;
	int i,sum=0;
	for(i=0; i&lt;s.length(); i++)     //s.length()计算字符串长度 
	{
		sum+=s[i]-'0';
	}
	string name[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};  //字符串用双引号括起来，字符用单引号括起来 
	
	string a = to_string(sum);
	
	for(i=0; i&lt;a.length(); i++)
	{
		cout &lt;&lt; name[a[i]-'0'];   //将数字转变为字符去存储方便调用每个位置上的数字，不用再除或求余啥的 
		if (i != a.length()-1)
			cout &lt;&lt; ' ';
	}
	

	return 0;
}
</code></pre>
<p>other's</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() 
{
	 string s;
	 cin &gt;&gt; s;
	 int sum = 0;
	 string str[10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;};   //
	 for (int i = 0; i &lt; s.length(); i++)
	 	sum += (s[i] - '0');
	 	
	 string num = to_string(sum);
	 
	 for (int i = 0; i &lt; num.length(); i++)
	 {
		 if (i != 0)        //题目要求最后一个拼音不能有空格，所以是先输出拼音，后输出空格，提前加一个if判断，当输入完最后一个拼音，循环都已经结束了
		 	cout &lt;&lt; &quot; &quot;;
		 cout &lt;&lt; str[num[i] - '0'];
	 }
	 
	 return 0; 
 }
</code></pre>
<p>1003解题思路：<br>
1.本题难点在于找规律，首先明确一点不是AAA...AAPAA...AATAA...AA这么简单的规律。<br>
2.突破点在于aPbTc正确和aPbATca正确，显然第二个在P与A之间多加了一个A，后面多了一个a，而a又是第一个的P之前的部分，其实这里a,b,c均是狗（宇哥替换）。观察例子：AAPATAA与AAPAATAAAA，这里a相当于AA，b相当于A，c相当于AA。在第二个中P,T之间多加了A，则后面多加AA。所以规律是在P,T之间多加一个A，则原来字符串T后面多 补充 原来字符串P之前的部分。比如对于AAPAATAAAA而言，AAPAAATAAAAAA也是对的，AAPAAATAAAAAAAA也是对的。<br>
3.如果P之前没有A，则无论在P,T之间加多少的A，T之后也不会有A,所以形如PAAA...AAAT都对<br>
4.xPATx这种形式告诉我们，AAA...AAAPATAAA...AAA是可以的，只要PAT前和后的AAA对称。二一个当x为空格是PAT也是正确。<br>
5.通过例子可知有且仅有P,A,T三种字符，其中P,T的个数只能为1，而A的个数不能0，P,T之间至少一个A，对于APAAATAA我们可知可以由APAATA得来，但是例子表示APAAATAA是错误，所以APAATA也是错误<br>
6.总之，就是P之前A的个数*P与T之间A的个数等于T之后A的个数 （这规律我估计也不是他想出来的，或者就是偶然想到的）</p>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

int main()
{
	int n,i,j,p,t;
	cin &gt;&gt; n;
	string s;
	for(i=0; i&lt;n; i++)
	{
		cin &gt;&gt; s;
		map&lt;char, int &gt; m;
		for(j=0; j&lt;s.length(); j++)
		{
			m[s[j]]++;
			if(s[j]=='P')
				p=j;
			if(s[j]=='T')
				t=j;
		}
		if(m['P']==1 &amp;&amp; m['A']!=0 &amp;&amp; m['T']==1 &amp;&amp; m.size()==3 &amp;&amp; t-p!=1 &amp;&amp; p*(t-p-1)==s.length()-t-1)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<p>1004解题思路：<br>
1.首先根本不用存储每次输入的学生的信息，重点是要知道成绩最值的学生的姓名和学号，所以用变量来存储这些信息。“铁打的营盘流水的兵”恰如其分描述铁打的营盘类似成绩最值的姓名和学号，而流水类似不断敲入的学生成绩，姓名和学号</p>
<p>1005解题思路：<br>
1.设置一个数组arr[]其中表示对输入数字进行c式处理后对应下标为1<br>
比如：输入5 ，第一次c式处理后为8，则将arr[8]的值为1<br>
先判断arr值是否为1，是则退出循环，输入下一个值判断，不是另其值为1<br>
2.注意arr数组的空间大小为10000否则只是部分正确<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int arr[10000];
bool cmp(int a, int b)
{
    return a&gt;b;
}

int main()
{
    int k,n,flag=0;
    cin &gt;&gt; k;
    vector&lt;int&gt; v(k);//定义一个数组
    //for中嵌套while，外面一共循环k次，里面就是对数字处理并且标记对应arr数组中的值为1
    //如果在while中判断数字有1则直接输入下一个数
    for(int i=0; i&lt;k; i++)
    {
        cin &gt;&gt; n;
        v[i]=n;   //数组存放对应的数字
        while(n!=1)
        {
            if(n%2!=0)
                n=3*n+1;
            n/=2;
            /*?*/
            if(arr[n]==1)
                break;
            arr[n]=1;
        }
    }
    sort(v.begin(), v.end(), cmp); //将数组按照从大到小的顺序排列
    for(int i=0; i&lt; v.size(); i++)
    {
        if(arr[v[i]]==0) //表示
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; v[i];
            flag=1;

        }
    }
    return 0;
}

</code></pre>
<p>1006<br>
解题思路：就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    思路就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i=1; i&lt;=n/100; i++)
        cout &lt;&lt; 'B';
    for(int j=1; j&lt;=n%100/10; j++)
            cout &lt;&lt; 'S';
    for(int k=1; k&lt;=n%10; k++)
            cout &lt;&lt; k;
    return 0;
}

</code></pre>
<p>1007<br>
解题思路：ans表示有多少对数字<br>
遍历从0--n相邻且相差2的数字，然后判断是否为素数</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
  解题思路：ans表示有多少对数字
        遍历从0--n相邻且相差2的数字，然后判断是否为素数
*/
int f(int n)
{
    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
            return 0;
    return 1;
}
int main()
{
    int n,ans=0;
    cin &gt;&gt; n;
    for(int i=2; i&lt;=n-2; i++)
    {
        if(f(i) &amp;&amp; f(i+2))
            ans++;
    }
    cout &lt;&lt; ans;
    return 0;
}

</code></pre>
<ol start="1008">
<li></li>
</ol>
<p>解题思路：<br>
先把数组倒叙，再把前m为倒叙，再把后面的倒叙即可。（客观规律，记住即可）<br>
之前的思路是向后移数组，在把超出部分放到前面，但这样部分正确。我分析是：使用太多的数组，因为题目要求程序移动的次数竟可能少</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;  //reverse()使用此头件
#include&lt;vector&gt;  //vector使用此头文件
using namespace std;
int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;int &gt; a(n);
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    m%=n;
    if(m!=0)
    {
        reverse(a.begin(),a.end());  //a.begin()是指针，指向数组第一个元素；a.end()也是指针，指向a[6]
        reverse(a.begin(),begin(a)+m);  //reverse中不会将第2部分的值也倒转，而是把他之前的值倒转
        reverse(begin(a)+m,a.end());  //从上一位置开始
    }
    for(int i=0; i&lt;n-1; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; a[n-1];
    return 0;
}

</code></pre>
<p>1009<br>
解题思路：<br>
利用栈先进后出的思想来倒叙输出字符串<br>
首先，将字符串压入栈，访问栈顶元素，弹出当前栈顶元素。<br>
由于题目要求，字符串之间有空格并且最后一个字符串没有空格，下面就循环先输出空格再输出字符串然后弹出<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

int main()
{
    stack&lt;string&gt; v;
    string s;
    while(cin &gt;&gt; s)
        v.push(s);
    cout &lt;&lt; v.top();
    v.pop();
    while(!v.empty())
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; v.top();
        v.pop();
    }
    return 0;
}

</code></pre>
<p>1010<br>
解题思路：<br>
1.每次输入两个变量，不用存放到数组中，规律是每次输出第一个变量*第二个变量；第二个变量-1<br>
2.对于上面规律使用前提是第二个变量不为0，若为0，不执行语句，进入下一次循环，看，在这里并不是<br>
3. 使用continue，而是循环中嵌套一个if，这样当条件不满足时，自动不执行if中的语句，直接进入下一次循环<br>
4.对于先输出数值，后输出空格，但在最后不能有空格的套路是用flag标记（你懂的）<br>
5.对于零项多项式和全部都是常数项而言，当整个循环结束后还是用flag==0判断，并输出0 0</p>
<p>注意事项：<br>
1 . 0项多项式表示前面没有式子，这样在循环到最后一个式子时输出 0 0<br>
2.对于前面有式子最后一个是0项多项式，这根本不叫0项多项式<br>
3.对于目前这个程序而言根本无法测试出输出&quot;0 0&quot;这个式子因为循环一直不结束，之所以能输出想要的结果那是因为在循环内部就给出值了</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int flag=0;
    int a,b;
    while(cin &gt;&gt; a &gt;&gt; b)
    {
        if(b!=0)
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a*b &lt;&lt; &quot; &quot; &lt;&lt; b-1;
            flag=1;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;0 0&quot;;
}

</code></pre>
<p>1012<br>
解题思路：<br>
1.将输入的数字存放到对5求余对应下标的二维数组中<br>
2.计算A1--A5<br>
1.A2：就是下标为偶数的加 - 下标为奇数的和<br>
3.输出，用printf简单<br>
注意事项：<br>
1.==不是=<br>
2.对于某个点一直过不去，重新敲一遍</p>
<pre><code class="language-cpp">/*
    解题思路：
    1.将输入的数字存放到对5求余对应下标的二维数组中
    2.计算A1--A5
            1.A2：就是下标为偶数的加 - 下标为奇数的和
    3.输出，用printf简单
*/
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,digit,A1=0,A2=0,A3=0,A5=-1;   //对应的变量注意设置出来
    double A4=0.0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a[5];

    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; digit;
        a[digit%5].push_back(digit);      //这里使用push_back就是将数字压入，自动生成一个二维数组
                                        //注意写法：数组[下标].push_back(要填入的数字);
    }

    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;a[i].size(); j++)
        {
            if(i==0 &amp;&amp; a[i][j]%2==0)
                A1+=a[i][j];
            if(i==1 &amp;&amp; j%2==0)
                A2+=a[i][j];
            if(i==1 &amp;&amp; j%2!=0)
                A2-=a[i][j];
            if(i==2)
                A3++;
            if(i==3)
                A4+=a[i][j];
            if(i==4 &amp;&amp; a[i][j]&gt;A5)     //一定要是大于A5
                A5=a[i][j];
        }
    for(int i=0; i&lt;5; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        if(i==0 &amp;&amp; A1==0 || i!=0 &amp;&amp; a[i].size()==0)
        {
            cout &lt;&lt; &quot;N&quot;;
            continue;
        }
        if(i==0)
            printf(&quot;%d&quot;,A1);
        if(i==1)
            printf(&quot;%d&quot;, A2);  //计算出结果为何不直接输出值？因为每一次输出都有条件限制，对于不存在的数输出N，
                            //为了保证思路的理解，就设置成循环，如果不满足条件就输出N，否则按照对应的值输出
        if(i==2)
            printf(&quot;%d&quot;,A3);
        if(i==3)
            printf(&quot;%.1f&quot;,A4/a[i].size());
        if(i==4)
            printf(&quot;%d&quot;,A5);
    }
    return 0;
}

</code></pre>
<p>1013<br>
解题思路：<br>
将从第M个素数到第N个素数放到数组中</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

bool isprime(int a)
{
    for(int i=2; i*i&lt;=a; i++)
        if(a%i == 0)
            return false;
    return true;
}

int main()
{
    int M,N,num=2,cnt=0;
    cin &gt;&gt; M &gt;&gt; N;
    vector&lt;int&gt; v;
    /*
        1.从素数列中找到第m个到第n个放到数组中
        2.用while循环，含义是循环至少执行N次，也就是M=5，N=27，循环至少执行27次，表示
          从第一素数到第27个素数，而且cnt必须从0开始，因为num初值为2，进入到isprime函数中，
          cnt++表示1与2为第一个素数相对应
        3.num++与循环的判断条件无关，循环的判断条件是第几个素数，其中cnt为N-1就表示第N个素数
          因为cnt从0开始
    */
    while(cnt &lt; N)       //cnt的值从0开始，自然要小于N
    {
        if(isprime(num))
        {
            cnt++;
            if(cnt &gt;= M)
                v.push_back(num);
        }
        num++;
    }
    cnt=0;
    /*
        对于每次先输出数字再输出空格，且最后一个不为空格，且每行10个的思想:
        1.将输出空格代码放前面，用if的一个条件判断（避开第一次输出空格），
          然后紧接着输出数字，依次循环
        2.对于每次换行，都希望能与1中的if语句相关联。这样保证每次换行时不会先输出一个空格，
          再输出数值，对于每次输出10个，那么每行的第一个就是1,11，21,31.....求余为1
          这样在if中可以设置%10!=1输出空格，当然在最后要有如果求余10就输出换行
    */
    for(int i=0; i&lt;v.size(); i++)
    {
        cnt++;
        if(cnt%10 != 1)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
        if(cnt%10 == 0)
            cout &lt;&lt; endl;
    }
}


/**********我的代码但是超时**********/
/*
    解题思路：
    1.素数公式判断
    2.从第m个素数到第n个素数
    主要是找到第一个
        1.用while，条件是k==n;k=0
*/
#include&lt;iostream&gt;
using namespace std;
bool f(int n)
{

    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
           return false;
    return true;
}

int s(int n)  //找到第n个素数
{
    int k=1,i=3;
    if(n==1)
    {
        return 2;
    }
    while(k!=n)
    {
        if(f(i))
            k++;
        i+=2;
    }
    return i-=2;
}

int main()
{

    int m,n,now=0,flag=0;
    cin &gt;&gt; m &gt;&gt; n;
    for(int i=s(m); i&lt;=s(n); i++)
    {
        if(f(i))
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; i;
            flag=1;
            now++;
    /*
        之前是换行后，先输出空格然后再输出值，我改为每次换行后，将flag的值修改，这样进入
        下次循环时，就不会输出空格，并且按照最后一个不为空格的方式输出
    */
            if(now%10==0)
            {
                cout &lt;&lt; endl;
                flag=0;
            }
        }

    }


    return 0;
}

</code></pre>
<p>1014<br>
解题思路：<br>
1.用两次while分别找出a,b字符串中第一个和第二个相同字符<br>
2.同样也用while遍历循环c，d两个字符串<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用两次while分别找出a,b字符串中第一个和第二个相同字符
    2.同样也用while遍历循环c，d两个字符串
*/
int main()
{
    string a,b,c,d;
    char t[2];
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    int i=0,j=0,e=0;
    //找到第一个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i] &amp;&amp; ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='G'))
        {
            t[0]=a[i];
            break;
        }
        i++;
    }
    i++;

    //找到第二个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i])
        {
            if(isdigit(a[i]) || ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='N'))  //isdigit(a[i])判断a[i]是否为数字字符
            {
                t[1]=a[i];
                break;
            }
        }
        i++;
    }

    //找到第三个字符
    while(j&lt;c.length() &amp;&amp; j&lt;d.length())
    {
        if(c[j]==d[j] &amp;&amp; isalpha(c[j]))          //isalpha(c[j])判断c[j]是否为字母
        {
            e=j;
            break;
        }
        j++;
    }


    char sa[7][5]={&quot;MON &quot;,&quot;TUE &quot;,&quot;WED &quot;,&quot;THU &quot;,&quot;FRI &quot;,&quot;SAT &quot;,&quot;SUN &quot;};
    cout &lt;&lt; sa[t[0]-'A'];
    int m=isdigit(t[1])? t[1]-'0': t[1]- 'A' + 10;    //切记这里用一个整形变量m来接受条件判断的结果，最后在输出
    printf(&quot;%02d:%02d&quot;,m,j);       //采用c的方式输出，是为了当数字为1位时，前面有0补充；否则直接输出2位数

    return 0;
}


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">isdigit(A)   //判断A是否为数字字符
isalpha(A)   //判断A是否为字母
</code></pre>
<p>1015德才论<br>
解题思路：<br>
1.用一个结构stu来存放数据信息<br>
2.设置一个排序函数，总分不同按照从大到小排列，总分相同，按照按照德分从大到小排列；德分相同，按照<br>
学号从小到大输出<br>
3.设置1个结构数组，一个临时变量结构用来存放每次的输入；循环中嵌套if判断，将对应的结构压入栈中，也就形成了二维数组<br>
4.最后压栈进行排序后并输出<br>
注意事项：<br>
在输入时，用scanf格式控制字符来输入，不会超时<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
/*
    解题思路：

*/
struct node
{
    int num,de,cai;
};

int cmp(struct node a, struct node b)
{
    if((a.de+a.cai)!=(b.de+b.cai))
        return (a.de+a.cai) &gt; (b.de+b.cai);   //如果总分数不同，就按照最大到小的顺序排列
    else if(a.de!=b.de)                    //如果总分数相同，但德分不同，按照德分从大到小排列
        return a.de&gt;b.de;         //从大到小
    else
        return a.num&lt;b.num;            //从小到大
}


int main()
{
    int low,high,n;
    cin &gt;&gt; n &gt;&gt; low &gt;&gt; high;
    node temp;
    vector&lt;node&gt; v[4];
    int total=n;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d&quot;, &amp;temp.num,&amp;temp.de, &amp;temp.cai);
        if(temp.de &lt; low || temp.cai &lt; low)
            total--;
        else if(temp.de &gt;= high &amp;&amp; temp.cai &gt;= high)
            v[0].push_back(temp);
        else if(temp.de &gt;= high &amp;&amp; temp.cai &lt; high)
            v[1].push_back(temp);
        else if(temp.de &lt; high &amp;&amp; temp.cai &lt; high &amp;&amp; temp.de &gt;= temp.cai)
            v[2].push_back(temp);
        else
            v[3].push_back(temp);

    }
    cout &lt;&lt; total &lt;&lt; endl;
    for(int i=0; i&lt;4; i++)
    {
        sort(v[i].begin(),v[i].end(),cmp);
        for(int j=0; j&lt;v[i].size(); j++)
            cout &lt;&lt; v[i][j].num &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].de &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].cai &lt;&lt;endl;
    }
    return 0;

}

</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">自定义排序：
struct stu
{
	int mark,num;
};
bool cmp(stu a, stu b)
{
	if(a.mark != b.mark)
		return a.mark &gt; b.mark  //降序排列
	else
		return a.num&lt;b.num      //mark相同按照num的升序排列
}
vector&lt;stu&gt; v[4];   //结构数组
sort(v[i].begin(),v[i].end(),cmp);  //对数组进行相应的排序
</code></pre>
<p>1016<br>
解题思路：<br>
1.用string存放要输入的字符串数组，用int来存放其他类型<br>
2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来<br>
3.两次循环记录相同数字的个数<br>
4.根据相同数字个数是否为0，否就再循环算出对应的值<br>
参考代码</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用string存放要输入的字符串数组，用int来存放其他类型
    2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来
*/
int main()
{
    string a,b;
    int a1,b1,num1=0,num2=0,suma=0,sumb=0;    //a1,b1表示要找的数字,num1,num2表示个数，suma,sumb表示和
    cin &gt;&gt; a &gt;&gt; a1 &gt;&gt; b &gt;&gt; b1;
    for(int i=0; i&lt;a.size(); i++)      //记录相同数字的个数
    {
        if(a1 == a[i]-'0')
            num1++;
    }
    for(int i=0; i&lt;b.size(); i++)        //记录相同数字的个数
    {
        if(b1 == b[i]-'0')
            num2++;
    }

    if(num1!=0)  
        suma=a1;   
    if(num2!=0)
        sumb=b1;
    for(int i=1; i&lt;num1; i++)
        suma=suma*10+a1;
    for(int i=1; i&lt;num2; i++)
        sumb=sumb*10+b1;
    cout &lt;&lt; suma+sumb;
    return 0;
}


</code></pre>
<p>1017<br>
解题思路：<br>
1.模拟手动求余的过程<br>
2.对于1000位的数字，用string；对于输出商，不用变量存储，直接输出<br>
参考代码：</p>
<pre><code class="language-cpp">int main()
{
    string s;
    int a,t=0,temp=0;
    cin &gt;&gt; s &gt;&gt; a;
    t=(s[0]-'0')/a;    //t就是商
    /*
        1.对于只有一位的数，直接输出商t
        2.对于2位及2位以上，如17 ，93 这种情况，前者就不输出，后者输出1
    */
    if((t != 0 &amp;&amp; s.length() &gt; 1) || s.length() == 1)
        cout &lt;&lt; t;
    temp = (s[0]-'0')%a;    //保存余数
    /*
        i从1开始，先计算下一位数的数，输出商，保存余数
    */
    for(int i=1; i&lt;s.length(); i++)   
    {
        t=(temp*10+s[i]-'0')/a;       
        cout &lt;&lt; t;
        temp=(temp*10+s[i]-'0')%a;
    }
    cout &lt;&lt; &quot; &quot; &lt;&lt; temp;
    return 0;
}
</code></pre>
<p>1018<br>
解题思路：<br>
1.统计甲赢的次数，乙赢的次数。甲输的次数就是赢的次数，同理，乙也是如此。平的次数就是总数-甲赢的次数-乙赢的次数<br>
2.如何确定赢次数最多的手势？<br>
答：将BCJ默认为012，在统计赢的次数时，记录甲乙赢的时候，对应手势所对应的下标的数组++，最后选出最大的个数，并且记住<br>
下标，最后定义一个字符数组&quot;BCJ&quot;这样刚才统计的下标就可以字符数组相对应<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.jiawin  yiwin 分别记录甲赢的次数和已赢的次数
    2.a[]  b[]两个数组分别统计B,J,C赢的次数，默认为012
    3.最后对数组元素比较得出最大的数组下标，同时设计一个变量，也是BJC这样就输出了对应的值
*/
int main()
{
    int jiawin=0,yiwin=0;
    int jia[3]={0};
    int yi[3]={0};
    char s,t;
    int n;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; s &gt;&gt; t;
        if(s=='B' &amp;&amp; t=='C')
        {
            jiawin++;
            jia[0]++;
        }
        else if(s=='C' &amp;&amp; t=='J')
        {
            jiawin++;
            jia[1]++;
        }
        else if(s=='J' &amp;&amp; t=='B')
        {
            jiawin++;
            jia[2]++;
        }
        else if(s=='C' &amp;&amp; t=='B')
        {
            yiwin++;
            yi[0]++;
        }
        else if(s=='J' &amp;&amp; t=='C')
        {
            yiwin++;
            yi[1]++;
        }
        else if(s=='B' &amp;&amp; t=='J')
        {
            yiwin++;
            yi[2]++;
        }
    }
    cout &lt;&lt; jiawin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; yiwin &lt;&lt; endl &lt;&lt; yiwin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; jiawin &lt;&lt; endl;
    int maxjia=jia[0]&gt;=jia[1]?0:1;    //设计大于等于的目的是：首先字母已经从字母序从小到大排列，当a[0]==a[1]时，结果max1还是0，不然最后max1就指向j
    maxjia=jia[maxjia]&gt;=jia[2]?maxjia:2;

    int maxyi=yi[0]&gt;=yi[1]?0:1;
    maxyi=yi[maxyi]&gt;=yi[2]?maxyi:2;
    char k[4]={&quot;BCJ&quot;};
    cout &lt;&lt; k[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; k[maxyi];
    return 0;
}
</code></pre>
<p>注意：BCJ对应012</p>
<p>1019<br>
解题思路：<br>
1.还是用string类来存放输入的数字<br>
2.自定义函数降序排列+结合sort升序排列+字符串转化为数字函数stoi()+数字转化为字符串函数to_string()+对不足四位的数补充0的相关函数s.insert(i,j,k)（题目要求四位输出）+do-while（当先输入0000时，还可以输出）<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(char a, char b)
{
    return a&gt;b;
}
int main()
{
    string s;
    cin &gt;&gt; s;
    s.insert(0,4-s.length(),'0');    //输入的数字不满足4位，则前补充0
    do          //先输入do-while是为了，当输入6174时还能执行一次循环
    {
        string a=s,b=s;
        sort(a.begin(),a.end(),cmp);  //数字以从大到小排列
        sort(b.begin(),b.end());      //默认为从小到大
        int result=stoi(a)-stoi(b);    //stoi将字符串转化为整数
        s=to_string(result);            //将数字转化为字符
        s.insert(0,4-s.length(),'0');
        cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; s &lt;&lt; endl;
    }while(s!=&quot;6174&quot; &amp;&amp; s!=&quot;0000&quot;);
    return 0;
}


/*
    知识总结：
    1.对字符串第i个位置开始，插入j个k
        s.insert(i,k,j);
    2.对字符串进行排序
        sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列
        sort(s.begin(),s.end());         //默认为从小到大排列
    3.stoi(str)   //将字符串转化为整数
    4.to_string(a)          //将数字转化为字符串
*/


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">​```cpp
    1.对字符串第i个位置开始，插入j个k
        s.insert(i,k,j);
    2.对字符串进行排序
        sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列
        sort(s.begin(),s.end());         //默认为从小到大排列
    3.stoi(str)   //将字符串转化为整数
    4.to_string(a)          //将数字转化为字符串
</code></pre>
<pre><code>  
1020
解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
   参考代码：
   

​```cpp
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
*/

struct mooncake
{
    float mount,price,unit;
};
int cmp(mooncake a, mooncake b)
{
    return a.unit &gt; b.unit;
}
int main()
{
    int n,need;
    cin &gt;&gt; n &gt;&gt; need;
    vector&lt;mooncake&gt; a(n); //且记要定义数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].mount);  //切记，float类型的scanf是%f
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].price);
    for(int i=0; i&lt;n; i++)
        a[i].unit=a[i].price/a[i].mount;

    sort(a.begin(),a.end(),cmp);

    float result=0.0;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i].mount &lt;= need)
            result = result+a[i].price;
        else
        {
            result=result+a[i].unit*need;
            break;
        }
        need=need-a[i].mount;
    }
    printf(&quot;%.2f&quot;,result);
    return 0;
}

</code></pre>
<p>知识总结：<br>
对于vector定义的数组连续for输入需要指明数组长度</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);  //不定以数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; b[i];
    return 0;
}


</code></pre>
<p>1021<br>
解题思路：<br>
用string存储整数，for遍历循环，定义9个长度的数组，对应的值++，最后按顺序输出数组元素不为0的</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.
*/
int main()
{
    string s;
    int a[10]={0};
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
        a[s[i]-'0']++;
    for(int i=0; i&lt;10; i++)
    {
        if(a[i]!=0)
            cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; a[i] &lt;&lt; endl;
    }
    return 0;
}


</code></pre>
<p>注意事项：<br>
有时候，用vector发生错误，就直接用普通数组定义法</p>
<p>1022<br>
解题思路：<br>
1.将余数存入数组，while的判断条件sum!=0<br>
2.将数组倒叙输出，j=i-1，<br>
3.不要忘记sum的0，输出0，return 0<br>
4.不要用VEctor压栈<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.将余数存入数组，while的判断条件sum!=0
    2.将数组倒叙输出，j=i-1，
    3.不要忘记sum的0，输出0，return 0
    4.不要用VEctor压栈
*/

int main()
{
    int sum,A,B,D,i=0;
    cin &gt;&gt; A &gt;&gt; B &gt;&gt; D;
    int a[100];
    sum=A+B;
    if(sum==0)
    {
        cout &lt;&lt; 0;
        return 0;
    }
    while(sum!=0)
    {
        a[i++]=sum%D;
        sum/=D;
    }
    for(int j=i-1; j&gt;=0; j--)
        cout &lt;&lt; a[j];
    return 0;
}



</code></pre>
<p>1023<br>
解题思路：<br>
1.没理解题意，切记数组是存放数字的个数<br>
2.先找出第一个不为0的数，并输出<br>
3.将所有0输出<br>
4.再输出所有第一个不为0的数<br>
5.双层for循环输出剩下的所有数，第一层for表示要输出的数字，第二层for表示要输出的个数<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a[10];
    int t;
    for(int i=0; i&lt;10; i++)
        cin &gt;&gt; a[i];
    for(int i=1; i&lt;10; i++)
    {
        if(a[i]!=0)
        {
            cout &lt;&lt; i;
            t=i;           //t存放第一个不为0的数
            break;
        }
    }

    for(int i=0; i&lt;a[0]; i++)   //输出所有的0
        cout &lt;&lt; 0;
    for(int i=0; i&lt;a[t]-1; i++)   //输出所有第一个不为0的数，因为之前输出了一个，所以这里就少输出1个
        cout &lt;&lt; t;
    for(int i=t+1; i&lt;10; i++)
        for(int j=0; j&lt;a[i]; j++)
            cout &lt;&lt; i;
    return 0;

}

</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.将余数压栈，sum&gt;D
*/

int main()
{
    vector&lt;int&gt; a(5);      //用vector定义数组长度就是后面加（n）n表示数组长度
    for(int i=0; i&lt;a.size(); i++)    //遍历数组时，i&lt;a.size()而不是a.end()
        cout &lt;&lt; a[i];
    int k=333;
    string s=to_string(k);      //将数字转化为字符串时用to_string切记是小写的to_string
    cout &lt;&lt; s;
    return 0;
}

</code></pre>
<p>1024<br>
解题思路：<br>
1.从E将字符串一分为2，但第一个字符串不包括符号位<br>
2.将后面的字符串转化为整数放到n<br>
3.根据n 的正负，选择输出不同的情况<br>
4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    /*
        解题思路：
        1.从E将字符串一分为2，但第一个字符串不包括符号位
        2.将后面的字符串转化为整数放到n
        3.根据n 的正负，选择输出不同的情况
        4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出
    */
    string s;
    cin &gt;&gt; s;
    int i=0;

    while(s[i]!='E')     //此时i表示E所在的位
        i++;

    string t=s.substr(1,i-1);     //t保存E之前的字符串，不包括符号位

    int n=stoi(s.substr(i+1));     //将E之后下一位开始到字符串结束的转化为数字

    if(s[0]=='-')
        cout &lt;&lt; &quot;-&quot;;

    cout &lt;&lt; n &lt;&lt; endl;
    if(n&lt;0)
    {
        cout &lt;&lt; &quot;0.&quot;;

        for(int j=0; j&lt;abs(n)-1; j++)  //输出0
            cout &lt;&lt; '0';

        for(int j=0; j&lt;t.length(); j++)   //遇到.就不输出
            if(t[j] != '.')
                cout &lt;&lt; t[j];
    }
    else
    {
        cout &lt;&lt; t[0];
        int cnt,j;

        for(j=2, cnt=0; j&lt;t.length() &amp;&amp; cnt&lt;n; j++,cnt++)  //若.和E之间的数字个数大于n，则只输出n个数字来
            cout &lt;&lt; t[j];

        /*
            根据上面for结束的情况，一种是j==t.length()表示.和E之间的数字个数小于n，后面直接输出（n-cnt）个0;
            另一种是cnt==n,表示.和E之间的数字个数大于或等于n，就得先输出. 然后从i=j开始一直到字符完输出
        */
        if(j==t.length())
        {
            for(int k=0; k&lt;n-cnt; k++)
                cout &lt;&lt; '0';
        }
        else
        {
            cout &lt;&lt; '.';
            for(int k=j; k&lt;t.length(); k++)
                cout &lt;&lt; t[k];
        }
    }
    return 0;
}

/*


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">知识总结：
1.s.substr() 截取字符串中的子串
    s.substr(4)  //表示从4开始到下标结束
    s.substr(5,3)   //表示从5开始3个字符*/

</code></pre>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用string存放输入，判断E之后是+还是-
    2.若为-，
        先输出0. + （后面的值-符号和.之间有几位）*输出0  + 输出s[1]  + 输出s[3]--&gt;s[E所在的前一位]
      若为+，
        先输出s[1] + （输出第3位开始到E之前的所有数字) + （后面的值-小数点和E之间的数字个数）*输出0
    3.若第一个字符为-，必须先输出-

*/

int main()
{
    string s,s1;
    cin &gt;&gt; s;
    int t,m,k;
    int sum=0;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='E')
        {
            t=i;
            break;
        }
    }
    //计算E之后符号后的数值
    for(int i=t+2; i&lt;s.length(); i++)
    {
        sum+=s[i]-'0';
        sum*=10;
    }
    sum/=10;
    if(s[0]=='-')
        cout &lt;&lt; '-';
    if(s[t+1]=='-')
    {
        cout &lt;&lt; 0 &lt;&lt; '.';
        for(int i=1; i&lt;=sum-1; i++)
            cout &lt;&lt; 0;
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
    }
    else
    {
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
        for(int i=1; i&lt;=sum-(t-3); i++)
            cout &lt;&lt; 0;
    }
    return 0;
}



</code></pre>
<p>1027<br>
解题思路：<br>
1.i表示从中间一行向外扩展的层数，比如样例中i为2<br>
2.3+5+7+...+2<em>i+1=i(i+2)这是上半部分字符的个数，一共有2</em>i*(i+2)+1个字符。当2<em>i</em>(i+2)+1&gt;N时，令row=i-1表示向外扩大的<br>
最大层数<br>
3.通过3个for嵌套循环输出字符：第一for控制打印的层数；第二个for控制打印空格(row-i)；第三for控制打印字符(2<em>i+1)（注意在每一行的最后面<br>
不需要打印空格，直接换行就能形成样例的效果）<br>
4.打印最中间一行<br>
5.打印最后下半部分<br>
6.输出剩余个数N-（2</em>i*(i+2)+1）</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
    int N,row=0;   //对row初始化否则超时
    char c;
    cin &gt;&gt; N &gt;&gt; c;
    for(int i=1; i&lt;N; i++)
    {
        if((2*i*(i+2)+1)&gt;N)
        {
            row=i-1;
            break;
        }
    }
    for(int i=row; i&gt;=1; i--)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    for(int i=0; i&lt;row; i++)
        cout &lt;&lt; ' ';
    cout &lt;&lt; c &lt;&lt; endl;
    for(int i=1; i&lt;=row; i++)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; N-(2*row*(row+2)+1);
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.对row要赋初值，否则运行超时</p>
<p>1028<br>
解题思路：<br>
1.用字符串来存储，还是用铁打的营盘流水兵的思想<br>
2.maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;都是string类的,string的比较从左至右；对于输入判断&quot;1814/09/06&quot;&lt;=tempbirth&lt;=&quot;2014/09/06&quot;<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
   
*/
int main()
{
    int n,cnt=0;
    cin &gt;&gt; n;
    string name,birth,maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;,maxname,minname;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; name &gt;&gt; birth;
        if(&quot;1814/09/06&quot;&lt;=birth &amp;&amp; birth&lt;=&quot;2014/09/06&quot;)
        {
            cnt++;
            if(birth&gt;maxbirth)
            {
                maxbirth=birth;
                minname=name;
            }
            if(birth&lt;minbirth)
            {
                minbirth=birth;
                maxname=name;
            }
        }
    }
    cout &lt;&lt; cnt;
    if(cnt!=0)
        cout &lt;&lt; &quot; &quot; &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; minname;
}


</code></pre>
<p>知识总结：<br>
对于string字符串的比较是从左至右，按照ascii码比较</p>
<p>1029<br>
解题思路：<br>
1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;<br>
并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的<br>
2.最后输出ans<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;
    并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的
    2.最后输出ans
    3.ans表示s1与s2中不相同的字符的字符串
*/
int main()
{
    string s1,s2,ans;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)
            ans+=toupper(s1[i]);
    }
    cout &lt;&lt; ans;
    return 0;
}


</code></pre>
<p>知识总结：<br>
1.toupper（）将小写字母转化成大写字母</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    /*
        1.toupper函数返回值为整数，在前面加个强制转化即可
    */
    char a='d';
    cout &lt;&lt; (char)toupper(a);
}


</code></pre>
<p>2.a.find(b)查找a字符串中是否含有b</p>
<pre><code class="language-cpp">/*
        1.a.find(b)如果字符串a中包含字符串b则值不等于string::npos，否则相同。a，b可以是字符串也可以是字符
        2.npos是一个常数，用来表示不存在的位置
        3.a字符串中如果包含b，则返回0；否则返回4294967295也就是npos
*/
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a,b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a.find(b) &lt;&lt; endl;
    cout &lt;&lt; string::npos;
    return 0;
}


</code></pre>
<p>1030<br>
解题思路：<br>
1.先对数组进行排序，从小到大<br>
2.通过两个for+if-else来找到满足题意的个数，外层for控制遍历整个数列，每次把v[i]当成最小的数，里面的for<br>
就是判断当前v[i]是最小值时，所对应的满足题意的最多的个数。这里j=i+result与if(v[j]&lt;=v[i]*p)用来表示：比如<br>
上次循环后result=3，此时一开始就判断从当前i开始往后第3个数是否满足条件，满足就修改result的值，不满足result<br>
值不变<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,temp,result=0;
    long long p;
    cin &gt;&gt; n &gt;&gt; p;
    vector&lt;int&gt;a(n);     //用vector定义有长度的数组时，数组名后用圆括号()中写数组长度
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        for(int j=i+result; j&lt;n; j++)
        {
            if(a[j]&lt;=a[i]*p)
            {
                temp=j-i+1;
                if(temp&gt;result)
                    result=temp;
            }
            else
                break;
        }
    }
    cout &lt;&lt; result;
    return 0;
}
</code></pre>
<p>知识总结：<br>
1.int：32位  0--2^32-1   long long： 64位 0--2^64-1<br>
2.用vector定义有长度的数组时，数组名后用圆括号()中写数组长度</p>
<p>1031<br>
解题思路：<br>
1.定义一个函数isTrue判断字符串是否满足题意<br>
2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag<br>
3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum<br>
4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与检验数组中的值对应</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.定义一个函数isTrue判断字符串是否满足题意
    2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag
    3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum
    4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与
    检验数组中的值对应
*/


bool isTrue(string s)
{
    int a[17]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    int b[11]={1,0,10,9,8,7,6,5,4,3,2};
    int sum=0;
    for(int i=0; i&lt;17; i++)
    {
        if(s[i]&lt;'0' || s[i]&gt;'9')
           return false;
        sum+=(s[i]-'0')*a[i];
    }
    int temp=(s[17]=='X')?10:(s[17]-'0');
    return b[sum%11]==temp;           //如果最后一位检验相同，就返回True；否则返回false；也可以用if-else来写

}
int main()
{
    int n,flag=0;
    string s;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; s;
        if(!isTrue(s))
        {
            flag=1;
            cout &lt;&lt; s &lt;&lt; endl;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;All passed&quot;;
    return 0;
}

</code></pre>
<p>1032<br>
解题思路：<br>
1.将成绩放到学校编号对应的下标数组中，数组表示成绩之和<br>
2.将max表示最大成绩的下标，由于题中，学校编号是从1开始，所以max初值为1，最后直接输出max1，和a[max1]。<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.学校编号school，成绩和数组a[]={0},
    2.
*/
int main()
{
    int n,tem,max1=1,school;
    cin &gt;&gt; n;
    int a[n+1]={0};
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; school &gt;&gt; tem;
        a[school]+=tem;
    }
    for(int i=2; i&lt;=n; i++)
    {
        if(a[i]&gt;a[max1])
            max1=i;
    }
    cout &lt;&lt; max1 &lt;&lt; &quot; &quot; &lt;&lt; a[max1];
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.定义数组a的长度时是n+1并且初值为0，因为题中含义是n个学生，所以学校的编号最大是n，查找最大值时的那个循环要能遍历到n，如果定义数组a的长度为n，那么最后成绩之和最大的是a[n]（未赋初值的数组元素值是任意数），而最大值下标是n。<br>
2.假设max1=1，也就是假设第一个学校的总分最大</p>
<ol start="1034">
<li></li>
</ol>
<p>解题思路：<br>
解题思路：<br>
1.三个函数：gcd求出最大公约数；func对分数进行化简，main输入a b c d<br>
2.gcd用辗转相除求最大约数，<br>
if(t2<mark>0)<br>
return t1;<br>
else<br>
gcd(t2,t1%t2);<br>
3.gcd函数<br>
1.如果m*n</mark>0,分为2种情况：分母为0或分母为0，输出时加上判断分子是否为0<br>
2.用flag表示异号为1，同号为0<br>
3.对m,n都取绝对值，并向除<br>
4.func函数：<br>
1.解决Inf与分子为0的问题<br>
2.定义flag，对m，n取整，x分子与分母的商<br>
3.解决对于分数可能添加(-的问题<br>
4.不论分子与分母是整除还是不整除，都先要输出x<br>
5.如果对于整除的情况，根据flag看输不输出),并最后退出此函数<br>
6.如果对于不是整除的情况，就要加上一个空格，以便让假分数的整数部分与分数分开<br>
7.输出真分数的问题<br>
1.先计算假分数去除整数部分的分子<br>
2.然后调用gcd函数算出此时分母与分子的最大公约数<br>
3.然后算出最简形式<br>
4.按照分数的格式输出，注意最后还要根据flag看输出输出）。<br>
5.main：<br>
1.输入四个值a b c d<br>
2.对于加法：通分手动算出分子分母然后将其作为参数代入func函数中求最简形式<br>
3.对于减法，类似只是相减<br>
4.对于乘法，类似根据手动的策略<br>
5.对于除法，类似手动求倒数然后代入</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
long long a, b, c, d;       //为啥要是long long类型？答：必须范围足够大
/*

*/


//辗转相除求最大约数
long long gcd(long long t1, long long t2) {
   if(t2==0)
    return t1;
  else
    gcd(t2,t1%t2);
}

//对分数进行化简
void func(long long m, long long n)
{
 if (m * n == 0)
 {
     printf(&quot;%s&quot;, n==0?&quot;Inf&quot;:&quot;0&quot;);
     return ;
 }

 //异号是1，同号0
 bool flag=((m&lt;0 &amp;&amp; n&gt;0) || (m&gt;0 &amp;&amp; n&lt;0));
 m=abs(m); n= abs(n);
 long long x = m/n;

 printf(&quot;%s&quot;, flag?&quot;(-&quot;:&quot;&quot;);

 if (x!=0)
    printf(&quot;%lld&quot;,x);    //注意这里的格式化输出格式是小写的LLL 不是 11111111

 if (m%n==0)
 {
        printf(&quot;%s&quot;,flag?&quot;)&quot;:&quot;&quot;);
    return ;
 }

 if (x!=0)
    printf(&quot; &quot;);
 m=m-x*n;
 long long t = gcd(m,n);
 m=m/t; n=n/t;
 printf(&quot;%lld/%lld%s&quot;,m,n,flag?&quot;)&quot;:&quot;&quot;);
}

int main()
{
 scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
 func(a,b); printf(&quot; + &quot;); func(c,d); printf(&quot; = &quot;); func(a*d+b*c,b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; - &quot;); func(c,d); printf(&quot; = &quot;); func(a*d-b*c,b*d); printf(&quot;\n&quot;);
 func(a,b); printf(&quot; * &quot;); func(c,d); printf(&quot; = &quot;); func(a*c, b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; / &quot;); func(c,d); printf(&quot; = &quot;); func(a*d, b*c);
 return 0;
}

</code></pre>
<p>易错点：</p>
<pre><code class="language-cpp">    if(m*n==0)
    {
        printf(&quot;%s&quot;,n==0?&quot;Inf&quot;:&quot;0&quot;);   
        return ;            // 易错：如果分子为0，或者分母为0，输出完Inf和0之后就应该退出程序；否则扣分
    }


    bool flag=((m&lt;0 &amp;&amp; n&gt;0)||(m&gt;0 &amp;&amp; n&lt;0));   //易错：flag设置为bool类型
</code></pre>
<ol start="1035">
<li></li>
</ol>
<p>解题思路：<br>
插入排序：<br>
i是数列b中第一个前一个数大于后一个数的位置<br>
j相当于从i开始一直到b数列结束a数列与b数列完全匹配<br>
对于插值排序：前面肯定是排好序的，也就是满足升序的序列，如果碰到前一位大于后一位则说明从此位的<br>
后一位开始一直到数组结束都是乱序的，所以刚好用j从此位的后一位开始一直到数组结束，判断j是否为n，<br>
如果是则为插序排列，然后对数组a进行sort排序（从头开始到i的下一位在排一次），表示他的下一次的插入排序，</p>
<pre><code>归并排序：
1.k初值为1，每次给自己乘2，
2.由于b是排序过程中的某一此序列，所以用a数列循环和b数列进行比较，flag是一个标记，初值为1，若在循环中
a[j]!=b[j]则令flag为1（意思是还要进行循环）本来模拟一次就行，但是测试点要求模拟整个过程。
3.理解while的思路：
    1.首先要明确，测试点要求整个的算法是模拟归并排序的整个过程，但输出时是要通过此算法得出下一次归并
    排序的结果。
    2.首先设置flag为1进入循环，将flag默认为0，下来的for用于判断初始数列和b数列是否相同，若相同则为0，
    否则为1
    3.k自乘2，然后for循环+sort(a+i*k,a+(i+1)*2)排序，最后还要有sort(a+n/k*k,a+n);
</code></pre>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int n,i,j;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int j=0; j&lt;n; j++)
        cin &gt;&gt; b[j];

    for(i=0; i&lt;n-1 &amp;&amp; b[i]&lt;=b[i+1]; i++)
        ;
    for(j=i+1; j&lt;n &amp;&amp; a[j]==b[j]; j++)
        ;
    if(j==n)
    {
        cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl;
        sort(a,a+i+2);
    }
    else
    {
        cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;
        int k=1,flag=1;
        while(flag)
        {
            flag=0;
            for(int i=0; i&lt;n; i++)
                if(a[i]!=b[i])
                    flag=1;
            k=k*2;
            for(int i=0; i&lt;n/k; i++)
                sort(a+i*k,a+(i+1)*k);
            sort(a+n/k*k,a+n);
        }
    }

    for(int i=0; i&lt;n; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; a[i];
    }
    return 0;
}

</code></pre>
<p>1036<br>
解题思路；无<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/
int main()
{
    int n;
    char c;
    cin &gt;&gt; n &gt;&gt; c;
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    cout &lt;&lt; endl;
    for(int j=0; j&lt;(n/2+n%2-2); j++)
    {
        cout &lt;&lt; c;
        for(int k=0; k&lt;(n-2); k++)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c &lt;&lt; endl;
    }
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    return 0;
}

</code></pre>
<p>易错点：</p>
<blockquote>
<p>对于50%的四舍五入是：n/2+n%2。比如17而言，结果为9<br>
但是如果只有n/2，结果为8；并非四舍五入的结果</p>
</blockquote>
<p>1037<br>
解题思路1：<br>
1.scanf输入<br>
2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。<br>
解题思路2：<br>
1.通过诸位比较，得出：实际付的钱小于应该付的钱时，要交换顺序，保证后面减的时候，是大的减小的；并且输出<br>
负号<br>
2.用实际付得钱mnt-应该付的钱abc,模拟手动减</p>
<p>参考代码1：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.scanf输入
    2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。
*/
int main()
{
    int a,b,c,a1,b1,c1;
    scanf(&quot;%d.%d.%d&quot;,&amp;a,&amp;b,&amp;c);
    scanf(&quot;%d.%d.%d&quot;,&amp;a1,&amp;b1,&amp;c1);
    int P,A;
    P=c+b*29+a*17*29;
    A=c1+b1*29+a1*17*29;
    int k=A-P;
    if(k&lt;0)
    {
        cout &lt;&lt; '-';
        k=abs(k);
    }
    cout &lt;&lt; k/(17*29) &lt;&lt; '.' &lt;&lt; (k%(17*29))/29 &lt;&lt; '.' &lt;&lt; (k%(17*29))%29;
    return 0;
}


</code></pre>
<p>参考代码2；</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int a,b,c,m,n,t,x,y,z;
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;m,&amp;n,&amp;t);
    if(a&gt;m || (a==m &amp;&amp; b&gt;n) || (a==m &amp;&amp; b==n &amp;&amp; c&gt;t))
    {
        swap(a,m);
        swap(b,n);
        swap(c,t);
        cout &lt;&lt; &quot;-&quot;;
    }
    z=c&gt;t?29+t-c:t-c;
    n=c&gt;t?n-1:n;
    y=b&gt;n?17+n-b:n-b;
    x=b&gt;n?m-1-a:m-a;
    printf(&quot;%d.%d.%d&quot;,x,y,z);
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.abc表示应该付款值，mnt表示实际付款值，如果实际付款值小于应该付款值，则交换位置，并输出符号，因为最后都是用大的减去小的也就是用mnt-abc模拟手动减法</p>
<p>1038<br>
解题思路1：<br>
1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中<br>
2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出</p>
<p>参考代码1：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中
    2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n];
    
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
        
    int k;
    cin &gt;&gt; k;
    int b[k],c[k]={0};
    
    for(int j=0; j&lt;k; j++)
        cin &gt;&gt; b[j];
    
    for(int s=0; s&lt;k; s++)
        for(int l=0; l&lt;n; l++)
        {
            if(a[l]==b[s])
                c[s]++;
        }
        
    for(int i=0; i&lt;k; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c[i];
    }
    return 0;
}


</code></pre>
<p>解题思路2：<br>
1.将成绩作为下标，然后对应的元素值++<br>
2.最后直接根据输入的值，循环输出</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int n,temp;
    cin &gt;&gt; n;
    vector&lt;int&gt;b(101);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; temp;
        b[temp]++;
    }
    int m;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        scanf(&quot;%d&quot;, &amp;temp);//这里要用scanf否则超时
        if(i!=0)
            printf(&quot; &quot;);
         printf(&quot;%d&quot;, b[temp]);
    }
    return 0;
}


</code></pre>
<p>注意事项：<br>
对于for循环中有输入+输出，其实在输入时，只有敲回车，才会输出要输出的值，如果用空格将输入分开，则结果直接根据根据循环次数输出对应的值：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    vector&lt;int&gt;b(101);
    int m=4;
    int temp;
     for (int i = 0; i &lt; m; i++)
    {
         scanf(&quot;%d&quot;, &amp;temp);
         if (i != 0)
            printf(&quot; &quot;);
         printf(&quot;0&quot;);
     }
     return 0;
 }


</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200211132105418.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021113212868.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>1039<br>
解题思路1：<br>
1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠<br>
2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#<br>
3.算出s1中不为#的字符个数，算出s2中为#的字符个数，<br>
4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果<br>
s2中#的个数不等于s2的字符长度，则输出剩余的字符个数</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠
    2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#
    3.算出s1中不为#的字符个数，算出s2中为#的字符个数，
    4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果
    s2中#的个数不等于s2的字符长度，则输出剩余的字符个数
*/
int main()
{
    string s1,s2;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s2.length(); i++)
    {
        for(int j=0; j&lt;s1.length(); j++)
        {
            if(s2[i]==s1[j])
            {
                s1[j]='#';
                s2[i]='#';
            }
        }
    }
    int num2=0,num1=0;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s1[i]!='#')
            num1++;
    }

    for(int i=0; i&lt;s2.length(); i++)
    {
        if(s2[i]=='#')
            num2++;
    }
    if(num2==s2.length())
        cout &lt;&lt; &quot;Yes &quot; &lt;&lt; num1;
    else
        cout &lt;&lt; &quot;No &quot; &lt;&lt; s2.length()-num2;
    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.将字符串中的字符转化成ascii码，存储到数组book中<br>
2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示<br>
相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++<br>
3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int book[150];   //book默认值全为0
int main() 
{
/*
    解题思路：
    1.将字符串中的字符转化成ascii码，存储到数组book中
    2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示
    相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++
    3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串
*/

     string a, b;
     cin &gt;&gt; a &gt;&gt; b;
     for (int i=0; i&lt;a.length(); i++)
        book[a[i]]++;
     int result = 0;
     for (int i=0; i&lt;b.length(); i++) 
     {
         if (book[b[i]] &gt; 0)
            book[b[i]]--;
         else
            result++;
     }
     if(result!=0)
        printf(&quot;No %d&quot;, result);
     else
        printf(&quot;Yes %d&quot;, a.length()-b.length());
     return 0; 
}
</code></pre>
<p>1040<br>
解题思路1：<br>
1.先找第一个p，然后依次找A，最后找T，然后构建起来</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    int a=1000000007,num=0,o,p;
    string s;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
        {
            o=i;
            for(int j=i+1; j&lt;s.length(); j++)
            {
                if(s[j]=='A')
                {
                    p=j;
                    for(int k=j+1; k&lt;s.length(); k++)
                    {
                        if(s[k]=='T')
                            num++;
                    }
                }
            }
        }
    }
    cout &lt;&lt; num%a;
    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.要知道PAT的个数等于对于每一个A，A前P的个数<em>A后T的个数累加起来即为PAT的个数<br>
2.先循环遍历T的个数<br>
3.for循环，若遇到P，则countp++，如果遇到A,则直接用countP</em>coutT累加到result，如果遇到T，则countT--，<br>
4.最后不要忘记对1000000007求余</p>
<p>参考代码2：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
/*
    解题思路：
    1.要知道PAT的个数等于对于每一个A，A前P的个数*A后T的个数累加起来即为PAT的个数
    2.先循环遍历T的个数
    3.for循环，若遇到P，则countp++，如果遇到A,则直接用countP*coutT累加到result，如果遇到T，则countT--，
    4.最后不要忘记对1000000007求余
*/
int main()
{
     string s;
     cin &gt;&gt; s;
     int len=s.length(), result=0, countp=0, countt=0;
     for(int i=0; i&lt;len; i++)
     {
         if (s[i]=='T')
         countt++;
     }
     for (int i=0; i&lt;len; i++)
     {
         if (s[i]=='P')
            countp++;
         if (s[i] == 'T')
            countt--;
         if (s[i] == 'A')
            result=(result+(countp * countt))%1000000007;
     }
     cout &lt;&lt; result;
     return 0;
 }


</code></pre>
<p>1041<br>
解题思路1：<br>
1.string存储一个二维数组，设置两个字符串变量s1，s2<br>
2.输入数据，保存在数组中<br>
3.输入整数，根据整数来对应数组中的值进行输出<br>
参考代码1：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.string存储一个二维数组，设置两个字符串变量s1，s2
    2.输入数据，保存在数组中
    3.输入整数，根据整数来对应数组中的值进行输出
*/
int main()
{
     string stu[1005][2], s1, s2;  //切记数组中的行标要超过1000
     int n, m, t;
     cin &gt;&gt; n;
     for(int i=0; i&lt;n; i++) 
     {
         cin &gt;&gt; s1 &gt;&gt; t &gt;&gt; s2;
         stu[t][0] = s1;
         stu[t][1] = s2;
     }
     cin &gt;&gt; m;
     for(int i=0; i&lt;m; i++) 
     {
         cin &gt;&gt; t;
         cout &lt;&lt; stu[t][0] &lt;&lt; &quot; &quot; &lt;&lt; stu[t][1] &lt;&lt; endl;
     }
     return 0;
 }


</code></pre>
<p>解题思路2：<br>
1.用结构类型来存储，然后循环找对应的输出即可<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用结构类型来存储，然后循环找对应的输出即可
*/
struct stu
{
    long long a;
    int b;
    int c;
};
int main()
{
    int n;
    cin &gt;&gt; n;
    stu s[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; s[i].a &gt;&gt; s[i].b &gt;&gt; s[i].c;
    int m,tem;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        cin &gt;&gt; tem;
        for(int i=0; i&lt;n; i++)
        {
            if(s[i].b==tem)
                cout &lt;&lt; s[i].a &lt;&lt; &quot; &quot; &lt;&lt; s[i].c &lt;&lt; endl;
        }
    }
    return 0;
}

</code></pre>
<p>1042<br>
解题思路：<br>
1.通过getline输入一个字符串<br>
2.定义一个数组a<br>
3.将字符串中所有字符改成小写<br>
4.如果是小写字符，就按照字符的ascii码，输入到数组a中<br>
5.假设a[0]是最大值，通过循环找出，最大值，以及对应的字符</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    string s;
    int a[26]={0};
    getline(cin,s);
    for(int i=0; i&lt;s.length(); i++)
        s[i]=tolower(s[i]);
    for(int i=0; i&lt;s.length(); i++)
        if(islower(s[i]))
            a[s[i]-'a']++;
    int max=a[0],t=0;
    for(int i=1; i&lt;26; i++)
    {
        if(a[i]&gt;max)
        {
            max=a[i];
            t=i;
        }
    }
    printf(&quot;%c %d&quot;,'a'+t,max);
    return 0;
}

</code></pre>
<p>知识总结：</p>
<blockquote>
<p>tolower ，toupper， isalpha， isalnum， islower，isupper<br>
用法</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main()
{

    /*tolower将字符改成小写
    string str=&quot;THIS IS A&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=tolower(str[i]);
    cout &lt;&lt; str;*/

    /*toupper将字符改成大写
    string str=&quot;this is a&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=toupper(str[i]);
    cout &lt;&lt; str;*/

    /*isalpha()判断一个字符是否为子母，如果是字符返回非0，否则返会0
    cout &lt;&lt; isalpha('2');  //返回0
    cout &lt;&lt; isalpha('A');   返回非0
    */

    /*isalnum用来判断是否为数字或者子母，
    cout &lt;&lt; isalnum('A'); 输出非0
    cout &lt;&lt; isalnum('2');  输出非0
    cout &lt;&lt; isalnum('.');  输出0
    */

    /*islower判断是否为小写字母，是，返回非0；不是，返回0
    cout &lt;&lt; islower('a');
    cout &lt;&lt; islower('A');
    */

    /*isupper判断是否为大写字母，是，返回非0，不是返回0
    cout &lt;&lt; isupper('A');
    cout &lt;&lt; isupper('a');
    */
}

</code></pre>
<p>1043<br>
解题思路1：<br>
1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......<br>
2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为<br>
0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......
    2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为
    0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环
*/
int main()
{
    string s;
    int a[6]={0};
    char c;
    int j=0;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
            a[0]++;
        if(s[i]=='A')
            a[1]++;
        if(s[i]=='T')
            a[2]++;
        if(s[i]=='e')
            a[3]++;
        if(s[i]=='s')
            a[4]++;
        if(s[i]=='t')
            a[5]++;
    }
  do
  {
    if(a[0]!=0)
    {
        cout &lt;&lt; 'P';
        a[0]--;
    }

    if(a[1]!=0)
    {
        cout &lt;&lt; 'A';
        a[1]--;
    }
    if(a[2]!=0)
    {
       cout &lt;&lt; 'T';
       a[2]--;
    }
    if(a[3]!=0)
    {
        cout &lt;&lt; 'e';
        a[3]--;
    }
    if(a[4]!=0)
    {
        cout &lt;&lt; 's';
        a[4]--;
    }
    if(a[5]!=0)
    {
        cout &lt;&lt; 't';
        a[5]--;
    }

  }while(a[0]!=0 || a[1]!=0 || a[2]!=0 || a[3]!=0 || a[4]!=0 || a[5]!=0);

    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.用cin.get()将字符串中的字符保存到其ASCII码下标的数组中<br>
2.用while+if进行循环</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
     int map[128]={0},c;
     while ((c = cin.get()) != EOF)   //表示没有到文件的结尾，判题的时候输入一个样例，就是到文件的结尾了
        map[c]++;
     while (map['P'] &gt; 0 || map['A'] &gt; 0 || map['T'] &gt; 0 || map['e'] &gt; 0 ||map['s'] &gt; 0 || map['t'] &gt; 0)
     {
         if (map['P']-- &gt;0)     //对于map['P']-- &gt;0是先比较后自减，对于--map['P'] &gt;0 是先自减后比较
            cout &lt;&lt; 'P';
         if (map['A']-- &gt;0)
           cout &lt;&lt; 'A';
         if (map['T']-- &gt;0)
           cout &lt;&lt; 'T';
         if (map['e']-- &gt;0)
           cout &lt;&lt; 'e';
         if (map['s']-- &gt;0)
           cout &lt;&lt; 's';
         if (map['t']-- &gt;0)
           cout &lt;&lt; 't';
     }
     return 0;
 }


</code></pre>
<p>1044<br>
解题思路：<br>
1.还是用字符串数组保存参数<br>
2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字<br>
3.对于func1而言：<br>
1.对于t/13的除数放到b数组中查找<br>
2.如t/13和t%13均不为0，则输出“ ”<br>
3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找<br>
4.对于func2而言：<br>
1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来<br>
2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]<br>
3.对于s1再在b数组中找，返回t1*13+t2;</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    1.还是用字符串数组保存参数
    2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字
    3.对于func1而言：
        1.对于t/13的除数放到b数组中查找
        2.如t/13和t%13均不为0，则输出“ ”
        3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找
    4.对于func2而言：
        1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来
        2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]
        3.对于s1再在b数组中找，返回t1*13+t2;
*/
string a[13] = {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string b[13] = {&quot;####&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
//将字符串和长度len设置为全局变量，这样方便调用函数时，不用传入过多的参数
string s;       
int len;

void func1(int t)
{
 if (t/13)
    cout &lt;&lt; b[t/13];
 if ((t/13) &amp;&amp; (t%13))
    cout &lt;&lt; &quot; &quot;;
 if (t%13 || t==0)
    cout &lt;&lt; a[t%13];
}

void func2()
{
     int t1=0, t2=0;
     string s1=s.substr(0,3),s2;   //substr复制字符串的函数
     if (len&gt;4)
        s2 = s.substr(4,3);
     for (int j = 1; j &lt;= 12; j++)
     {
         if (s1==a[j] || s2==a[j])    //为啥要填入s1=a[j]? 答：对于13进制以内的数有用，如feb=5;
            t2=j;
         if (s1==b[j])
            t1=j;
     }
     cout &lt;&lt; t1*13+t2;
 }

int main()
{
     int n;
     cin &gt;&gt; n;
     getchar();         //清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符
     for (int i = 0; i &lt; n; i++)
     {
         getline(cin, s);
         len=s.length();
         if (s[0]&gt;='0' &amp;&amp; s[0]&lt;='9')
            func1(stoi(s));
         else
            func2();
         cout &lt;&lt; endl;
     }
     return 0;
 }

</code></pre>
<p>注意事项：<br>
1.清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符<br>
2.注意格式，在主函数中每次循环一次输出endl，但在自身的输入时不要加endl</p>
<p>知识总结：<br>
stoi（将数字字符串改为整数）+ s.substr(pos,n)（将字符串中的字符复制到另一个字符串中）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{/*
    string str=&quot;abcdef&quot;;
    string a=str.substr(0,11);
    cout &lt;&lt; a;

0. 用途：一种构造string的方法

1. 形式：s.substr(pos, n)

2. 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）

3. 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾*/

/*字符串转化整数函数
    string s=&quot;123&quot;;
    cout &lt;&lt; stoi(s);
    */
}

</code></pre>
<p>1045<br>
解题思路1：<br>
解题思路：<br>
1.设置三个数组：abv分别表示原始数组，sort排列后的数组，主元元素数组<br>
2.核心思路，找a与b数组中相同的数字，并且该数字大于前的最大值，因为如果a与b的某个数字相同，说明后面的元素<br>
都比该元素大，故只用说明该数字大于之前的最大值即可<br>
3.输出数组v<br>
注意事项：<br>
1.输出主元元素的个数时，要换行<br>
2.最后整个数组输出完后，加换行</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int v[1000000];
int main()
{
    int n,max=-1,cnt=0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i] &amp;&amp; b[i]&gt;max)
        {
            v[cnt++]=b[i];
        }

        if(b[i]&gt;max)
            max=b[i];
    }
    cout &lt;&lt; cnt &lt;&lt; endl;
    for(int i=0; i&lt;cnt; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
    }
    cout &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>解题思路2；<br>
1.主元的判断条件：左边元素都比其小，右边的元素都比其大，或者换句话说，如果左边的某个数比其大或者右边的某个数比其小，则<br>
不是主元<br>
2.可以将合适的数组放到数组中，最后排序输出</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
/*

*/
int main()
{
    int n,num=0;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }

    sort(a,&amp;a[n]);
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
            num++;
    }
    cout &lt;&lt; num &lt;&lt; endl;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
        {
            if(i!=0)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a[i];
        }
    }
    return 0;
}


</code></pre>
<p>1046<br>
解题思路：<br>
1.设置四个，jiahan，jiahua，yihan，yihua, jiahe,yihe<br>
2.逻辑如下</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int jiahan,jiahua,yihan,yihua,jiahe=0,yihe=0;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d %d&quot;,&amp;jiahan,&amp;jiahua,&amp;yihan,&amp;yihua);
        if(jiahua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            yihe++;
        if(yihua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            jiahe++;


    }
        cout &lt;&lt; jiahe &lt;&lt; &quot; &quot; &lt;&lt; yihe &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>1047<br>
解题思路：<br>
1.必然有使用scanf输入<br>
2.完全可以将最后成绩保存在队伍编号的数组中</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/

int main()
{
    int n,duiwu,duiyuan,chengji,maxduiwu=0;
    cin &gt;&gt; n;
    int a[1001]={0};
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d-%d %d&quot;,&amp;duiwu,&amp;duiyuan,&amp;chengji);
        a[duiwu]+=chengji;
    }
    for(int i=0; i&lt;1001; i++)
    {
        if(a[i]&gt;a[maxduiwu])
            maxduiwu=i;
    }
    cout &lt;&lt; maxduiwu &lt;&lt; &quot; &quot; &lt;&lt; a[maxduiwu];
    return 0;
}

</code></pre>
<p>1048<br>
解题思路：<br>
1.将a，b字符串倒转过来<br>
2.根据比较字符串长度，给较短位补0<br>
3.设置str保存0,1..J,Q,K<br>
4.对于原来的数位而言，从个位开始就是奇数位，下一位就是偶数位，如果倒转过来，第一位虽然是偶数位，但是<br>
还是执行的是原来奇数位的操作。<br>
5.每次循环时将计算结果累加到字符串c中，最后倒叙输出</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    string a,b,c;
    string str=&quot;0123456789JQK&quot;;
    cin &gt;&gt; a &gt;&gt; b;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());

    if(a.length()&gt;b.length())
        b.append(a.length()-b.length(),'0');
    else
        a.append(b.length()-a.length(),'0');

    for(int i=0; i&lt;b.length(); i++)
    {
        if(i%2==0)
            c+=str[(b[i]-'0'+a[i]-'0')%13];
        else
        {
            int tem=b[i]-a[i];
            if(tem&lt;0)
                tem+=10;
            c+=str[tem];       //由于对应的数字位相减，所以最大差值为9，而c是字符串，所以也可以直接用str[tem]来连接
        }
    }
    for(int i=c.length()-1; i&gt;=0; i--)
        cout &lt;&lt; c[i];
    return 0;
}

</code></pre>
<p>知识总结：<br>
1.a.append(n,c)表示对字符串a的尾部添加n个字符c<br>
2.reverse(a.begin(),a.end()) 对字符串a进行倒转</p>
<p>1049<br>
解题思路：<br>
1.通过找规律，其实就是每个数字出现i*(n-i+1)次，<br>
2.规律如下图：</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    int n;
    cin &gt;&gt; n;
    double sum=0.0,tem;
    for(int i=1; i&lt;=n; i++)
    {
        cin &gt;&gt; tem;
        sum+=tem*i*(n-i+1);
    }
    printf(&quot;%.2f&quot;,sum);
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200220134238258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第九章笔记（排序）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/">
        </link>
        <updated>2020-03-01T04:22:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">9.1开场白</a><br>
<a href="#jump2">9.2排序的基本概念和分类</a><br>
      <a href="#jump3">9.2.1排序的稳定性</a><br>
      <a href="#jump4">9.2.2内排序与外排序</a><br>
      <a href="#jump5">9.2.3排序用到的结构与函数</a><br>
<a href="#jump6">9.3冒泡排序</a><br>
      <a href="#jump7">9.3.1最简单排序实现</a><br>
      <a href="#jump8">9.3.2冒泡排序算法</a><br>
      <a href="#jump9">9.3.3冒泡排序优化</a><br>
      <a href="#jump10">9.3.4冒泡排序复杂度分析</a></p>
<p><a href="#jump11">9.4简单选择排序</a><br>
      <a href="#jump12">9.4.1简单选择排序算法</a><br>
      <a href="#jump13">9.4.2简单选择排序复杂度分析</a></p>
<p><a href="#jump14">9.5直接插入排序</a><br>
      <a href="#jump15">9.5.1直接插入排序算法</a><br>
      <a href="#jump16">9.5.2直接插入排序复杂度分析</a></p>
<p><a href="#jump17">9.6直接插入排序</a><br>
      <a href="#jump18">9.6.1希尔排序原理</a><br>
      <a href="#jump19">9.6.2希尔排序算法</a><br>
      <a href="#jump20">9.6.3希尔排序复杂度分析</a></p>
<p><a href="#jump21">9.8 归并排序</a><br>
      <a href="#jump22">9.8.1归并排序算法</a><br>
      <a href="#jump23">9.8.2归并排序复杂度分析</a><br>
      <a href="#jump24">9.8.3非递归实现归并排序</a></p>
<p><a href="#jump25">9.7堆排序</a><br>
      <a href="#jump26">9.7.1堆排序算法</a><br>
      <a href="#jump27">9.7.2堆排序复杂度分析</a></p>
<p><a href="#jump28">9.9快速排序</a><br>
      <a href="#jump29">9.9.1快速排序算法</a><br>
      <a href="#jump30">9.9.2快速排序复杂度分析</a><br>
      <a href="#jump31">9.9.3快速排序优化</a></p>
<p><span id="jump2">9.2排序的基本概念和分类</span><br>
1.排序就是将无序的数据集合，按照某一定顺序进行排列<br>
2.对于有很多关键字的排序，可以将多个关键字的排序转化成单个关键字的排序，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200216211522213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021621153480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump3">9.2.1排序的稳定性</span><br>
如图：<br>
<img src="https://img-blog.csdnimg.cn/20200216211947313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump4">9.2.2内排序与外排序</span><br>
     1.什么叫内排序，外排序：（如下图）</p>
<p><img src="https://img-blog.csdnimg.cn/20200216212209422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     2.排序算法的性能主要是受3个方面影响：</p>
<p>            1.时间性能：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/20200216212512766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            2.辅助空间：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/2020021621252762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            3.算法的复杂性：（如下图） <img src="https://img-blog.csdnimg.cn/20200216212540588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump5">9.2.3排序用到的结构与函数</span><br>
1.排序用到的顺序表结构：</p>
<pre><code class="language-cpp">#define MAXSIZE 10     //用于要排序数组个数最大值，可根据需要修改
typedef struct         
{
	int r[MAXSIZE+1];     //用于存储要排序的数组，r[0]用作哨兵或临时变量
	int length;           //用于记录顺序表长度
}SqList;    
</code></pre>
<p>2.排序所用到的交换函数</p>
<pre><code class="language-cpp">//交换L中数组r的下标为i和j的值
void swap(SqList *L,int i,int j)
{
	int temp=L-&gt;r[i];
	L-&gt;r[i]=L-&gt;r[j];
	L-&gt;r[j]=temp;
}
</code></pre>
<p><span id="jump6">9.3冒泡排序</span><br>
      <span id="jump7">9.3.1最简单的排序实现</span></p>
<blockquote>
<p>冒泡排序一种交换排序，它的基本思想：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做交换排序（冒泡排序初级版）
void BubbleSort0(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=i+1; j&lt;=L-&gt;length; j++)
		{
			if(L-&gt;r[i]&gt;L-&gt;r[j])
			{
				swap(L,i,j);    //交换L-&gt;r[i]与L-&gt;r[j]的值
			}
		}
	}
}//详见代码如下图
</code></pre>
<blockquote>
<p>上述代码的思路：让每一关键字，都和它后面的每一个关键字比较，如果前面的大于后面的，则交换，这样第一位置的关键字在一次循环后一定是最小的<br>
上述代码缺陷：每次只能一个一个去排列，这样对其余关键字没有任何帮助<br>
<img src="https://img-blog.csdnimg.cn/20200218214434373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>      <span id="jump8">9.3.2冒泡排序算法</span></p>
<blockquote>
<p>此冒泡排序的思想：i从第一个位置开始，然后j从最后向前冒泡，不断地将小的值放到前面，这样不断的循环下去，便于将一部分小的数值移动一些位置</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做冒泡排序
void BubbleSort(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=L-&gt;length-1; j&gt;=i; j--)     //注意j是从后往前循环
		{
			if(L-&gt;r[j]&gt;L-&gt;r[j+1])   //若前者大于后者
			{
				swap(L,j,j+1);   //交换L-&gt;r[j]与L-&gt;r[j+1]的值
			}
		}
	}
}//详见代码如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200218214549665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200218214604810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump9">9.3.3冒泡排序优化</span></p>
<blockquote>
<p>为什么要有冒泡排序的优化？如下图中，如果不优化，还要不断地进行比较，浪费时间</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200218215111503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-cpp">//对顺序表L做改进冒泡算法
void BubbleSort2(SqList *L)
{
	int i,j;
	Status flag=TRUE;     //flag用来作为标记
	for(i=1; i&lt;L-&gt;length &amp;&amp; flag; i++)    //若flag为false则循环结束
	{
		flag=FALSE;    //初始为false
		for(j=L-&gt;length-1; j&gt;=i; j--)
		{
			if(L-&gt;r[j] &gt; L-&gt;[j+1])
			{
				swap(L,j,j+1);    //交换L-&gt;r[j]与L-&gt;r[j+1]的值
				flag=TRUE;       //如果有数据交换，则flag改true
			}
		}
	}
}//详见如下图：
</code></pre>
<blockquote>
<p>此代码的思想是：加入一个flag判断，flag初始值为TRUE，进入循环后如果后面循环中一但有交换则改flag值为TRUE，再次循环；如果循环中已经是升序排列，不会有前面的值大于后面的值，则flag为false，循环结束</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200218215911799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump10">9.3.4冒泡排序复杂度分析</span><br>
最好情况是o(n)<br>
最坏情况是o(n^2)</p>
<p><span id="jump11">9.4简单选择排序</span></p>
<p>      <span id="jump12">9.4.1简单选择排序算法</span></p>
<blockquote>
<p>简单选择排序的思想：从第一个位置开始，循环找到后面的最小值，然后与第一个位置的值进行交换，如此进行下去，则就是简单选择排序</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做简单选择排序
void SelectSort(SqList *L)
{
	int i,j,min;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		min=i;       //将当前下标定义为最小值下标
		for(j=i+1; j&lt;=L-&gt;length; j++)   //循环之后的数据
		{	
			if(L-&gt;r[min]&gt;L-&gt;r[j])   //如果有小于当前最小值的关键字
				min=j;         //将此关键字的下标赋值给min
		}
		if(i!=min)                     //若min不等于i，说明找到最小值了，交换
			swap(L,i,min);    //交换L-&gt;r[i]与L-&gt;r[min]的值
	}
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200218221732154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">9.4.2简单选择排序复杂度分析</span></p>
<blockquote>
<p>1.对上面代码中第二层的for（就是找最小值下标）的那个代码而言，对第一个值其比较次数为n-1，对于第2个值而言，其比较次数为n-2，则一共的比较次数为n(n-1)/2，后面中就是交换次序的代码，最坏情况需要交换n-1次，则一共的时间复杂度为o(n^2)</p>
</blockquote>
<p><span id="jump14">9.5直接插入排序</span><br>
      <span id="jump15">9.5.1 直接插入排序算法</span></p>
<blockquote>
<p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L作直接插入操作
void InsertSort(SqList *L)
{
	int i,j;
	for(i=2; i&lt;=L-&gt;length; i++)
	{
		if(L-&gt;r[i]&lt;L-&gt;r[i-1])          //需将L-&gt;r[i]插入有序子表
		{
			L-&gt;r[0]=L-&gt;r[i];            //设置哨兵
			for(j=i-1; L-&gt;r[j]&gt;L-&gt;r[0]; j--)
				L-&gt;r[j+1]=L-&gt;r[j];              //记录后移
			L-&gt;r[j+1]=L-&gt;r[0];            //插入到正确位置
		}
	}
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200220223032274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022022305317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump16">9.5.2直接插入排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/20200220224148149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200220224207118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump17">9.6希尔排序</span></p>
<p>      <span id="jump18">9.6.1希尔排序原理</span></p>
<blockquote>
<p>1.希尔排序就是为了突破O(n^2)的时间复杂度，思想就是每次循环一次后都将原来的数组排序成基本有序（P.S.基本有序就是大的数字基本在后面，小的数字基本在前面，不大不小的基本在中间）<br>
2.采用的是跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在自序列内分别进行直接插入排序后得到的结果时基本有序而不是局部有序</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200223211404857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump19">9.6.2 希尔排序算法</span></p>
<pre><code class="language-cpp">//对顺序表L做希尔排序
void ShellSort(SqList *L)
{
	int i,j;
	int increment=L-&gt;length;
	do
	{
		increment=increment/3+1;    //增量序列
		for(i=increment+1; i&lt;=L-&gt;length; i++)
		{
			if(L-&gt;r[i]&lt;L-&gt;r[i-increment])
			{//需将L-&gt;r[i]插入有序增量子表中
				L-&gt;r[0]=L-&gt;r[i];          //暂存到L-&gt;r[0]
				for(j=i-increment; j&gt;0 &amp;&amp; L-&gt;r[0]&lt;L-&gt;r[j]; j-=increment)
					L-&gt;r[j+increment]=L-&gt;r[j];        //记录向后移，查找插入位置
				L-&gt;r[j+increment]=L-&gt;r[0];          //插入
			}
		}
	}while(increment&gt;1);
}//详见如下图
</code></pre>
<p>1.待排数组<br>
<img src="https://img-blog.csdnimg.cn/20200223212218854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212236540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212256717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212313899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022321294273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump20">9.6.3希尔排序时间复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度为O(n^3/2)，要直接好于O(n的平方)<br>
2.增量序列的最后一个增量值必须等于1才行</p>
</blockquote>
<p><span id="jump21">9.8归并排序</span></p>
<blockquote>
<p>说白了就是对数组进行两两合并，详见下图</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224212407189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump22">9.8.1归并排序算法</span></p>
<blockquote>
<p>归并排序的原理，见下图：</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/2020022421255582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>总的归并排序代码：</p>
<pre><code class="language-cpp">//对顺序表L做归并排序
void MergeSort(SqList *L)
{
	MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);
}

</code></pre>
<blockquote>
<p>上述代码，为了和前面的排序算法统一，用了同样的参数定义SqList *L，MSort的代码实现如下：</p>
</blockquote>
<p>递归拆分代码：</p>
<pre><code class="language-cpp">void MSort(int SR[], int TR1[], int s, int t)  //SR[]数组相当于原始数组，TR1[]相当于排好序的数组
{
	int m;
	int TR2[MAXSIZE+1];
	if(s==t)
		TR1[s]=SR[s];    
	else
	{
		m=(s+t)/2;     //相当于从中间开始分
		MSort(SR,TR2,s,m);    //将原始数组SR[]的前半部分递归到TR2[]中
		MSort(SR,TR2,m+1,t);     //将原始数组SR的后半部分放到TR2[]中
		Merge(TR2,TR1,s,m,t);   //将TR2[]递归到已排好序的数组TR1[]中
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224213548144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224213607291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022421364571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Merge函数如何实现（归并算法）：</p>
<pre><code class="language-cpp">//将数组直接归并为有序的
void Merge(int SR[], int TR[], int i,int m,int n)
{
	int j,k,l;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j&lt;=n; k++)   //将SR中记录有小到大归并入TR中
	{
		if(SR[i]&lt;SR[j])
			TR[k]=SR[i++];
		else
			TR[k]=SR[j++];
	}
	if(i&lt;=m)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=m-i; l++)
			TR[K+l]=SR[i+1];
	}
	if(j&lt;=n)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=n-j; l++)
			TR[k+l]=SR[j+l];
	}
} //详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224214436361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224214448493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump23">9.8.2 归并排序复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度分析：<br>
对于上面那个merge函数中，将原始数列SR[]放入到TR1[]中，由于要遍历循环所有的记录所以时间复杂度为O(n)，而由完全二叉树的深度可知，整个总的归并排序需要进行log2n次，总的时间复杂度为O(nlogn)<br>
2.空间复杂度分析：<br>
由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，所以空间复杂度为o(n)。同时还有递归时深度为log2n的栈空间，因此空间复杂度为O(n+logn)<br>
3.Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明他需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法</p>
</blockquote>
<p>      <span id="jump24">9.8.3 非递归实现归并排序</span></p>
<p>直接进行归并排序代码如下：</p>
<pre><code class="language-cpp">//对顺序表L作归并非递归排序
void MergeSort2(SqList *L)
{
	int* TR=(int *) malloc (L-&gt;length*sizeof(int));    //申请额外空间
	int k=1;
	while(k&lt;L-&gt;length)
	{
		MergePass(L-&gt;r,TR,k,L-&gt;length);
		k=2*k;                           //子序列长度加倍
		MergePass(TR,L-&gt;r,k,L-&gt;length);
	    k=2*k;                    	//子序列长度加倍
	}
} //详见代码如下图：

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200224215853578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<table><tr><td bgcolor=GreenYellow>非递归算法和递归算法的区别</td></tr></table>
<blockquote>
<p>1.非递归算法：对数组直接归并<br>
2.递归算法： 先递归拆分数组然后再归并退出递归</p>
</blockquote>
<p>上面的MergePass（归并排序）代码如下：</p>
<pre><code class="language-cpp">void MergePass(int SR[],int TR[],int s,int n)
{
	int i=1;
	int j;
	while(i&lt;=n-2*s+1)
	{
		Merge(SR,TR,i,i+s-1,i+2*s-1);       //两两归并
		i=i+2*s;
	}
	if(i&lt;n-s+1)         //归并最后两个序列
		Merge(SR,TR,i,i+s-1,n);
	else
		for(j=i; j&lt;=n; j++)
			TR[j]=SR[j];
}//详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224220712223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224220724375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>非递归归并排序的时间复杂度如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200224220803431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump25">9.7堆排序算法</span></p>
<blockquote>
<p>大顶堆+小顶堆如下图：</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202002242213116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>如果按照层序遍历的方式给结点从1开始编号，有如下关系：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224221455607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224221554850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>将大顶堆和小顶堆用层序遍历存入数组，如下图：</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200224221707148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump26">9.7.1堆排序算法</span></p>
<blockquote>
<p>堆排序的基本思想如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022422185751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022422191275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
堆排序的整体代码：</p>
<pre><code class="language-cpp">//对顺序表L进行堆排序
void HeapSort(SqList *L)
{
	int i;
	for(i=L-&gt;length/2; i&gt;0; i--)         //将原来的数组构建为一个大顶堆
		HeapAdjust(L,i,L-&gt;length);
	
	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224222615378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224222629819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
上述代码中HeapAdjust函数如何实现：</p>
<pre><code class="language-cpp">void HeapAdjust(SqList *L,int s,int m)
{
	int temp,j;
	temp=L-&gt;r[s];
	for(j=2*s; j&lt;=m; j*=2)   //沿关键字较大的孩子结点向下筛选
	{
		if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])
			++j;            //j为关键字中较大的记录的下标
		if(temp&gt;L-&gt;r[j])
			break;
		L-&gt;r[s]=L-&gt;r[j];
		s=j;
	}
	L-&gt;r[s]=temp;   //插入
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224223320292.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223337424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223348267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223402125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
接下来就是HeapSort函数中正式的排序过程</p>
<pre><code class="language-cpp">	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}//详见如下图：

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200224223738871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump27">9.7.2堆排序复杂度分析</span></p>
<blockquote>
<p>1.在第一次构建堆的过程中，时间复杂度如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224224117512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224224130379.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.在正式排序的过程中，时间复杂度如下：</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200224224223924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump28">9.9快速排序</span></p>
<blockquote>
<p>1.希尔排序相当于直接插入排序的升级，他们都属于插入排序类<br>
2.堆排序相当于简单选择排序的升级，他们都属于选择排序类<br>
3.快速排序就是冒泡排序的升级，他们都属于交换排序类</p>
</blockquote>
<p>       <span id="jump29">9.9.1快速排序算法</span></p>
<blockquote>
<p>快速思想的思想，如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200225113932704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
快速排序的代码：</p>
<pre><code class="language-cpp">void QuickSort(SqList *L)
{
	QSort(L,1,L-&gt;length);
}

</code></pre>
<p>QSort函数的代码：</p>
<pre><code class="language-cpp">//对顺序表L中的子序列做快速排序
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if(low&lt;high)
	{
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200225114522383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>上述代码中Partition函数（将原始数组一分为2的数组）如下：</p>
<pre><code class="language-cpp">//交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
//此时在他之前的记录均不大于他，在后面的记录均不小于他
int Partition(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		swap(L,low,high);                 //将比枢轴记录小的记录交换到低端
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		swap(L,low,high);                      //将比枢轴记录大的记录交换到高端
	}
	return low;              //返回枢轴所在位置
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200225115335261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115345893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115359275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump30">9.9.2快速排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/202002251156198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115918926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002251159399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump31">9.9.3快速排序优化</span><br>
               1.优化选取枢轴<br>
                         1.为啥要优化选取枢轴？<br>
<img src="https://img-blog.csdnimg.cn/20200225120248306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225120308181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>                         2.三数取中法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200225120455867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在Partition函数中的第3行与第4行之间加上如下代码：</p>
<pre><code class="language-csharp">3 int Pivotkey;
	int m=low+(high-low)/2;           //计算数组中间的元素的下标
	if(L-&gt;r[low]&gt;L-&gt;r[high])
		swap(L,low,high);        //交换左端与右端，保证左端较小
	if(L-&gt;r[m]&gt;L-&gt;r[high])
		swap(L,high,m);             //交换中间与右端数据，保证中间较小
	if(L-&gt;r[m]&gt;L-&gt;r[low])
		swap(L,m,low);               //交换中间与左端数据，保证左端较小
	//此时L.r[low]已经是整个序列做左中右三个关键字的中间值
4 pivotkey=L-&gt;r[low];          //还是用子表的第一个记录做枢轴记录
//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022512114547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
                         3.优化不必要的交换：<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225121325776.png" alt="在这里插入图片描述" loading="lazy"><br>
2.详细代码：</p>
<pre><code class="language-cpp">//快速排序优化算法
int Partition1(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	//这里省略三数取中的代码
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	L-r[0]=L-&gt;r[high];              //增加1：叫枢轴关键字备份到L-&gt;r[0]
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		L-&gt;r[low]=L-&gt;r[high];              //增加2：采用的是替换而不是交换
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		L-&gt;r[high]=L-&gt;r[low];        //增加3：采用的是替换而不是交换
	}
	L-&gt;r[low]=L-&gt;r[0];              //增加4：将枢轴数值替换回L.r[low]
	return low;              //返回枢轴所在位置

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200225122008154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         4.优化小数组的排序方案<br>
1.原因如下：<br>
<img src="https://img-blog.csdnimg.cn/20200225122148402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.详见代码：</p>
<pre><code class="language-cpp">#define MAX_LENGTH_INSERT_SORT 7            //数组长度阈值
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200225122542336.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         5.优化递归的操作<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225122706361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
于是对QSort进行尾递归操作：</p>
<pre><code class="language-cpp">void QSort1(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		while(low&lt;high)
		{
			pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
			QSort1(L,low,pivot-1);             //对低字表递归排序
			low=pivot+1;              //尾递归			
		}

	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200225123002786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第五章笔记（串）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/">
        </link>
        <updated>2020-03-01T04:20:53.000Z</updated>
        <content type="html"><![CDATA[<p>5.2<br>
1.串是由零个或多个字符组成的有限序列，又名叫字符串。<br>
2.串中的字符数目n称为串的长度。<br>
3.零个字符的串称为空串，它的长度为0，也可以直接用双引号&quot;&quot;直接括起来。<br>
4.空格串，是包含空格的串。空格串是有长度的，而且可以不止一个空格。<br>
5.子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。<br>
6.子串在主串中的位置就是子串的第一个字符在主串中的序号</p>
<p>5.3串的比较：<br>
1.将两个字符串都从左至右对齐，然后开始比较，字符串的数量可以不同，比较字符串时一一对应，按照ascii码的方式，字母在前的小，到第一个不同字母比较完之后就完。</p>
<p>5.4串的数据结构：</p>
<pre><code class="language-cpp">ADT 串（string）
Data 
	串中元素仅有一个字符组成，相邻的元素具有前驱和后继关系
Operation
	StrAssign (T,*chars): 生成一个其值等于字符串的常量chars的串T
	StrCopy (T,S):串S存在，由串S复制得到串
	ClearString(S): 串s存在，将串清空
	StringEmpty(S):若串S为空，返回true，否则返回false
	StrLength(S):返回串中的元素个数，即串的长度
	StrCompare(S,T):若S&gt;T,返回值&gt;0,若S=T，返回0，若S&lt;T,返回值&lt;0
	Concat(T,S1,S2):用T返回又S1和S2链接而成的新串
	SubString (Sub,S,pos,len):  串s存在，1&lt;=pos&lt;=StrLength(S),且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符起长度为len的子串
	Index (S,T,pos): 串S和T存在，T是非空串, 1&lt;=pos&lt;=StrLength(S)
					若主串S中存在和串T值相同的子串，则返回它在主串S中
					 第pos个字符之后第一次出现的位置，否则返回0
	Replace(S,T,V):  串S,T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重复的子串
	StrInsert(S,pos,T):  串S和T存在，1&lt;=pos&lt;=Strlength(S)+1
						在串S的第pos个字符之前插入串T
	Strlength(S,pos,len): 串S存在，1&lt;=pos&lt;=Strlength(S)-len+1
						`  从串S中删除第pos个字符起长度为len的子串
endADT
</code></pre>
<p>5.4.1index的操作（取主串中，与子串相同的字符串的第一个字符的位置）</p>
<pre><code class="language-cpp">/*T为非空串。若主串s中第pos个字符之后存在于T相等的子串*/
/*则返回第一个这样的子串在S中的位置，否则返回0*/
int Index(String S, String T, int pos)
{
	int n,m,i;
	String sub;
	if(pos&gt;0)
	{
		n=StrLength(S);
		m=Strlength(T);
		i=pos;           //刚开始这个pos不是要所要的位置，不知道也不必说
		while(i &lt;= n-m+1)   //见下图有这代码的解释
		{
			SubString(sub,S,i,m);     //取主串第i个位置
										//长度与T相等子串给sub
			if(StrCompare(sub, T) !=0 )   //如果两个串不相等
				++i;
			else                  //如果两串相等
				return i;  			//则返回i值
		}
		
	}
	return 0;    //若无子串与T相等，返回0
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227210942916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的顺序存储结构：<br>
<img src="https://img-blog.csdnimg.cn/20191227211456716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的链式存储结构：没有占满的位置，可以用其他非字符替代<br>
<img src="https://img-blog.csdnimg.cn/20191227211514657.png" alt="在这里插入图片描述" loading="lazy"><br>
、<br>
5.6朴素的模式匹配法：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//T非空，1&lt;=pos&lt;=Strlength(S)
int Index(String S, String T, int pos)
{
	int i=pos;        //i主要用于主串s中当前位置的下标，若pos不为1
						//则从pos位置开始匹配
	int	j=1;					 //j用于子串T中当前位置下标值
	while(i &lt;= S[0] &amp;&amp; j &lt;= T[0])    //若i小于s长度且j小于T的长度时循环
	{
		if(S[i] == T[j])      //两个字母相等则继续
		{
			++i;
			++j;
		}
		else        //指针后退重新开始匹配
		{
			i=i-j+2;    //i退回到上次匹配首位的下一位,详细看下图1处
			j=1;     //j退回到子串T的首位
		}
	}
	if(j&gt;T[0])   //上面的while结束有两种情况，i&gt;S[0] 或者  j&gt;T[0] 当i&gt;S[0]一定没有对应的字符串匹配，当j&gt;T[0]时，表示走完了字串，找到了相对应的
		return i-T[0];      //详细看下图2处
	else
		return 0;
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227220444240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
朴素算法的时间复杂度：<br>
<img src="https://img-blog.csdnimg.cn/20191229233628356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191229233657400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>5.7KMP模式匹配法<br>
1.kmp算法的普遍理解：如下图，kmp算法的使用前提是T串中的首字符a与后面的均不相等，由于a到e子串T与主串S都对应相同，所以下一次直接比较a与f即可，这便是kmp的引入<br>
<img src="https://img-blog.csdnimg.cn/20191230202900263.png" alt="在这里插入图片描述" loading="lazy"><br>
2.实际上，j的回溯位置的变化与主串S没有什么关系，主要是看子串T中是否有相同的字符，如下图中不用在比较a,b,<br>
j从6回溯到j=3<br>
<img src="https://img-blog.csdnimg.cn/20191230203551303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关于j的回溯的数组next的原理：如下图<br>
<img src="https://img-blog.csdnimg.cn/20191230203909316.png" alt="在这里插入图片描述" loading="lazy"><br>
这里对于5这个位置下要看前4个字符，第一个a与最后一个a相同，相同字母只有一个，所以5下就写2<br>
这里对于6这个位置下要看前5个字符，前两个字符ab与最后两个字符ab完全相同，所以6下就写3<br>
如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191230204256407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
j回溯位置下标的数组：</p>
<pre><code class="language-cpp">//通过计算返回子串T的next数组
void get_next (String T, int *next)
{
	int i,j;
	i=1;             
	j=0;               
	next[1]=0;
	while(i&lt;T[0])        //此处T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])
		{
			++i;
			++j;
			next[i]=j;       //将j回溯的位置保存到next中
		}
		else
			j=next[j];          //j回溯到对应位置
	}
}
</code></pre>
<p>下面是KMP的整体代码：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
int Index_KMP(String S, String T, int pos)
{
	int i=pos;       //i就是那里的代码值不同就从哪里开始，如图5-7-3 i为6就从6开始
	int j=1;       //j用于当前位置中下标值
	int next[255];    //定义一next数组
	get_next(T,next);   //对串做分析，得到next数组
	while(i &lt;= s[0] &amp;&amp; j &lt;= T[0])   //若i小于s的长度且j小于且小于T的长度时，循环继续
	{
		if(j==0 || s[i]==T[j])    //两个字母相等则继续，相对于朴素算法增加了j=0判断
		{
			++i;
			++j;
		}
		else
		{
			j=next[j];    //如果字母不相同，则j的值回溯
		}
	}
	
//后面两行代码和朴素算法相同
	if(j&gt;T[0])    
		return i-T[0];
	else
		return 0;
	
}
</code></pre>
<p>kmp算法的时间复杂度分析：<br>
在这里，创建next数组时间复杂度为o(m)，后面的时间复杂度为o(n)，则整体的时间复杂度为o(m+n)<br>
kmp的核心思路：如果子串中一前一后有相同的字符，后面的字符不管与主串中是相同还是不同，对于前面的字符在往后走时不用在与之前</p>
<p>5.7.4kmp模式匹配算法的改进</p>
<pre><code class="language-cpp">//求模式串T的next函数修正值并存入数组nextval，整个nextval还是以计算next的方法来构建，区别在于数值不同，目的就是减少j的回溯次数，以减少复杂度
void get_nextval(String T, int *nextval)
{
	int i,j;
	i=1;
	j=0;
	nextval[1]=0;
	while(i&lt;T[0])           //T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])       //T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
		{
			++i;
			++j;
/* 这里的代码是改进后不同于之前的next算法
			if(T[i]!=T[j])   //若当前字符与前缀字符不同
				nextval[i]=j;		//就将next中的值给nextval
			else
				nextval[i]=nextval[j];  //字符相同,nextval与之前相同字符所对应的nextval值相同
*/
		}
		else
			j=nextval[j];      //相当于计算next数组中的值，只是改了个名，就这样理解
	}
}
</code></pre>
<p>5.7.4 kmp算法的改进<br>
1.相对于之前的kmp算法j的回溯位置变化太多，而改进后，j回溯的变化位置不多，这里应该是T中有太多连续字符相同的情况下<br>
next数组中，数字不同的程度与j回溯到不同位置的次数成正比，数字越复杂，回溯的次数越多，时间复杂度越大。<br>
2.nextval[]数组变化是：第一数组值为0，往后每一个数组值，如果串中的字符与next数组中对应位置的字符相同，则nextval中的值也与对应位置的nextval相同，如果不同则nextval值就是next值<br>
<img src="https://img-blog.csdnimg.cn/20191230223215549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第六章笔记（树）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/">
        </link>
        <updated>2020-03-01T04:20:04.000Z</updated>
        <content type="html"><![CDATA[<p>6.2树的定义：<br>
1.树是n个结点的有限集，n=0时称为空树<br>
2.有且仅有一个特定的根<br>
3.子树的个数没有限制，但他们一定是不相交，如下图，就不是子树<br>
<img src="https://img-blog.csdnimg.cn/20191231202354754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.结点拥有的子树数称为结点的度。度为0的结点称为叶节点；度不为0的结点称为分支结点。除根节点之外，分支节点也称内部结点；树的度是树内各结点的度的最大值，如下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203344509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.3结点间的关系：<br>
1.结点的祖先是从根到该结点所经分支上的所有结点 对于H而言ABD都为他的祖先。其他各种关系见下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203245223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.树的相关概念，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203808831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.树与线性表之间的差别，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203824606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.3树的抽象数据类型，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231204652847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4树的存储结构=== 双亲表示法<br>
1.除了根节点啊外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲<br>
2.以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置，结构如下：</p>
<pre><code class="language-bash">data parent  //data是数据域，存储结点的数据信息。parent是指针域，存储该结点的双亲在数组中的下标
</code></pre>
<p>双亲表示法的结点结构定义代码：</p>
<pre><code class="language-cpp">//树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定位整型
typedef struct PTNode   //结点结构
{
	TElemType data;   //结点数据
	int parent;        //双亲位置
}PTNode;
typedef struct       //树的结构
{
	PTNode nodes[MAX_TREE_SIZE];   //结点数组
	int r,n;         //根的位置和结点数
}
</code></pre>
<p>上面的代码对应下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231210350239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进1：在结点中加入左孩子：<br>
<img src="https://img-blog.csdnimg.cn/20191231210401533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进2：在结点中加入有兄弟：<br>
<img src="https://img-blog.csdnimg.cn/20191231210410793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.2孩子表示法：由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表法：如下图，有两种方案：<br>
方案一：<br>
指针域的个数就是树的度，树的度是树中各个结点度的最大值，结构如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213303600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
方案2：<br>
每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213251681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
重点是如下：<br>
孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个维数组中，如图</p>
<pre><code class="language-cpp">//树的孩子表示法结构定义：
#define MAX_TREE_SIZE 100
typedef struct CTNode   //孩子结点
{
	int chile;  //数据域：用来存储某个结点在表头数组中的下标
	struct CTNode *next;  //指针域：存储指向某结点另一个孩子结点的指针
}*ChildPtr;
typedef struct 
{
	TElemType data;  //存储某结点的数据信息
	ChildPtr firstchild; //存储该结点的孩子链表的头指针
}CTBox;
typedef struct     //树结构
{
	CTBox nodes[MAX_TREE_SIZE];  //结点数组
	int r,n;        //根的位置和结点数
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2019123121443736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
双亲表示法和孩子表示法综合，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231214837104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.3孩子兄弟表示法：<br>
结点结构如下图：<br>
firstchild 为指针域，存储该结点的第一个孩子存储地址<br>
<img src="https://img-blog.csdnimg.cn/2019123121564494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
结构定义代码如下：</p>
<pre><code class="language-cpp">//树的孩子兄弟表示法结构定义：
typedef struct CSNode
{
	TElemType data;
	struct CSNode *fitstchild, *rightsib;
}CSNode, *CSTree;
</code></pre>
<p>上面代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231215849928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.5二叉树<br>
1.如图便是二叉树，不能有3个结点：<br>
<img src="https://img-blog.csdnimg.cn/20191231220217170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">6.5.1二叉树特点：<br>
1.每个结点最多有两颗子树<br>
2.左子树与右子树是有顺序的，次序不能任意颠倒<br>
3.即使树中某结点只有一颗树，也要区分它是左子书还是右子树</p>
<p>二叉树的五种基本形态：<br>
1.空二叉树<br>
2.只有一个根节点<br>
3.根结点只有左子树<br>
4.根结点只有右子树<br>
5.根结点既有左子树又有右子树</p>
<p>6.5.2特殊二叉树<br>
1.斜树，满二叉树，完全二叉树 以及 满二叉树的特点和完全二叉树的特点，：如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101205140586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101205158141.png" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205220907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树与满二叉树的关系：<br>
<img src="https://img-blog.csdnimg.cn/20200101205227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200101205248318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
满二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205312212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.6二叉树的性质：<br>
1.某一层上最多有多少个结点<br>
<img src="https://img-blog.csdnimg.cn/20200101210138616.png" alt="在这里插入图片描述" loading="lazy"><br>
2.深度为k的二叉树最多有几个结点：<br>
<img src="https://img-blog.csdnimg.cn/20200101210128770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.n0表示度为0的结点个数，n1表示度为1的结点的个数，n2表示度为2的结点的个数<br>
<img src="https://img-blog.csdnimg.cn/20200101210056806.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210115437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.完全二叉树的深度<br>
<img src="https://img-blog.csdnimg.cn/20200101210030592.png" alt="在这里插入图片描述" loading="lazy"><br>
5.对于根结点，左孩子，右孩子的判定方法：<br>
<img src="https://img-blog.csdnimg.cn/20200101210019979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.7.1二叉树的顺序存储结构：<br>
用数组存放，没有就像倒V表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101210629187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210615923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.7.2二叉链表：<br>
用链式存储结构来存放二叉树，设计一个数据域，两个指针分别指向左孩子和右孩子，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101211952142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>二叉链表的结点结构定义：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode        //结点结构
{
	TElemType data;       //结点数据
	struct BiTNode *lchild, *rchild;    //左右孩子指针
}BiTNode, *BiTree;
</code></pre>
<p>结构示意图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200101211934670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.2二叉树4中遍历方法：<br>
1.前序遍历法<br>
2.中序遍历法<br>
3.后序遍历法<br>
4.层序遍历法</p>
<p><img src="https://img-blog.csdnimg.cn/20200101212151521.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101212228822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.3前序遍历法：</p>
<pre><code class="language-cpp">//二叉树的前序遍历递归算法
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	printf(&quot;%c&quot;,T-&gt;data);      //显示结点数据，可以更改为为其它节点的操作
	PreOrderTraverse(T-&gt;lchild);     //先遍历左子树
	PreOrderTraverse(T-&gt;rchild);        //最后遍历右子树
}
</code></pre>
<p>按照如下的顺序访问：<br>
<img src="https://img-blog.csdnimg.cn/20200101212935308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010121295030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213004977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213046165.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.4中序遍历算法代码：</p>
<pre><code class="language-cpp">//二叉树的中序遍历递归算法
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	InOrderTraverse(T-&gt;lchild);    //中序遍历左子树
	printf(&quot;%c&quot;,T-&gt;data)         //显示节点数据，可以更改为其他对结点操作
	InOrderTraverse(T-&gt;rchild);     //最后中序遍历右子树
}
</code></pre>
<p>中序遍历结点示意图：<br>
<img src="https://img-blog.csdnimg.cn/20200101213810373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.5后续遍历法代码：</p>
<pre><code class="language-cpp">//二叉树后序遍历递归算法：
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	PostOrderTraverse(T-&gt;lchild);   //先后序遍历左子树
	PostOrderTraverse(T-&gt;rchild);    //后序遍历右子树
	printf(&quot;%c&quot;,T-&gt;data);       //显示结点数据，可以更改为对其他结点操作
}
</code></pre>
<p>6.9二叉树的建立：<br>
1.扩展二叉树：将二叉树中每个结点的空指针引出一个虚节点，其值为以特定值，比如&quot;#&quot;，称这种处理后的二叉树为原二叉树的扩展二叉树。如下图：</p>
<p>2.把前序遍历序列：AB#D##C##用键盘诶个输入，代码如下：<br>
也可以用中序或后序遍历的方法实现<br>
中序：输入顺序为#B#D#A#C#      对应代码顺序为：构造左子树—》生成结点-》构造右子树<br>
后序：输入顺序为###DB##CA     对应代码顺序为： 构造左子树-》构造右子树-》生成结点</p>
<pre><code class="language-cpp">//按前序输入二叉树中结点的值（一个字符）
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BiTree *T)
{
	TElemType ch;
	scanf(&quot;%c&quot;, &amp;ch);
	if(ch==&quot;#&quot;)
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)-&gt;data=ch;     //生成根结点
		CreateBiTree(&amp;(*T)-&gt;lchild);             //构造左子树
		CreateBitree(&amp;(*T)-&gt;rchild);            //构造右子树
	}
}

</code></pre>
<p>6.10线索二叉树<br>
以中序遍历为例：下面二叉树中中序遍历的结果为：HDIBJEAFCG<br>
线索二叉树的实质：将二叉链表中的空指针改为指向前驱或后继的线索。<br>
<img src="https://img-blog.csdnimg.cn/202001022049073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将rchild改为后继，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204323143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将lchild改为它的前驱，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204350104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
整个二叉树的中序遍历结果中的前驱后继关系如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204638116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>将lchild,ltag,data,rtag,rchild组合成一个结构，如下图：<br>
具体如下：<br>
ltag为0表示指向该节点的左孩子，为1表示指向该节点的前驱<br>
rtag为0表示指向该结点的右孩子，为1指向该结点的后继<br>
<img src="https://img-blog.csdnimg.cn/20200102204422155.png" alt="在这里插入图片描述" loading="lazy"><br>
二叉树的搜索存储结构定义</p>
<pre><code class="language-cpp">//二叉树的二叉搜索存储结构定义
typedef enum{Link,Thread} PointerTag;         //Link==0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索
typedef struct BiThrNode           //二叉搜索存储结点结构
{
	TElemType data;
	struct BiThrNode *lchild, *rchild;        //左右孩子指针
	PointerTag LTag;                 //左右标志            
	PointerTag RTag;      
}BiThrNode, *BiThrTree;

												

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200102204454222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>中序遍历线索化递归函数代码：(构建线索二叉树)<br>
可以根据上图二叉树来理解</p>
<pre><code class="language-cpp">//中序遍历进行中序线索化
void InThreading(BiThrTree p)
{
	InThreading(p-&gt;lchild);             //递归左子树线索化
	if(!p-&gt;lchild)                //没有左孩子
	{
		p-&gt;LTag=Thread;                   //将LTag改为1
		p-&gt;lchild=pre;               //左孩子指针指向前驱
	}
	if(!pre-&gt;rchild)
	{
		pre-&gt;RTag=Thread;                    //将RTag改为1，为了理解见下图
		pre-&gt;rchild=p;                //前驱右孩子指针指向后继(当前结点p)
	}
	pre=p;                       //保持pre指向p的前驱
	InThreading(p-&gt;rchild);           //递归右子树线索化
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200102214224564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
二叉线索树的遍历，见下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102220110750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
遍历代码如下：</p>
<pre><code class="language-cpp">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T
Status InOrderTraverse_Thr(BiThTree T)
{
	BiThrTree p;
	p=T-&gt;lchild;             //p指向根结点
	while(p!=T)               //空树或遍历结束时，p==T
	{
		while(p=&gt;LTag==Link)            //当LTag==0时循环到中序序列的第一个结点
			p=p-&gt;lchild;
		printf(&quot;%c&quot;,p-&gt;data);           //显示结点数据，可以更改为其他对结点的操作
		while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)
		{
			p=p-&gt;rchild;                  //p中RTag是1表示存放的是他的后继结点
			printf(&quot;%c&quot;,p-&gt;data); 
		}
		p=p-&gt;rchild;            //p中RTag是0表示，p进入他的右子树  区分上面的
	}
	return OK;
}

</code></pre>
<p>如果所用二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，采用线索二叉树的存储结构</p>
<p>6.11.1树转换为二叉树<br>
1.加线。在所有兄弟节点之间加一条线<br>
2.去线。 就是按照你的思路去就对<br>
3.层次调整。 以树的根结点为轴心，顺时针旋转，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来为结点的右孩子<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103194908705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.2将森林转换为二叉树：<br>
1.将每个树按照上面的方法转化成二叉树<br>
2、第一棵树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103195444927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.3二叉树转化为树<br>
1.将结点的左孩子n个右孩子，用线连接起来<br>
2.删除原二叉树中所有结点与其右孩子结点的连线<br>
3.层次调整。  如果只有一个孩子，就直接转化为竖线即可<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103200346330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.4二叉树转化为森林：<br>
1.从根结点开始，若右孩子存在则删除连线，若右孩子存在则删除连线，只要有右孩子就把连线删了<br>
2.再将每棵二叉树转化成树<br>
<img src="https://img-blog.csdnimg.cn/20200103201021824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.5.森林的遍历：<br>
1.前序遍历：一颗树接着一棵树来，每棵树都用先序遍历法，对于上图的二叉树的遍历结果为：ABCDEFGHJI<br>
2.后序遍历：还是一棵树接着一棵树来，每棵树都用后序遍历法，对于上图的二叉树的遍历结果为：BCDAFEJHIG<br>
对于上图而言，森林的前序遍历法和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历法相同。</p>
<p>6.12赫夫曼树及其应用：<br>
树的路径长度表示从根结点到每一个结点的长度总和，如下图中二叉a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+2+3+3+1+2+2=16<br>
<img src="https://img-blog.csdnimg.cn/20200103204819966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
带权路径长度wpl最小的二叉树称作赫夫曼树，上图中二叉树a的wpL=5<em>1+15</em>2+40<em>3+30</em>4+10<em>4=315 ，二叉树b的wpl=40</em>2+15<em>3+5</em>3+30<em>2+10</em>2=220</p>
<p>6.12.2最优赫夫曼树构造方法：<br>
1.将把有权值的叶子结点按照从小到大的顺序排成一个有序列<br>
2.取头两个最小权值的结点之和作为一个新的结点，注意较小的为新的结点的左孩子，每次如此重复，直至结束。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103210711134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210742955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210759426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
赫夫曼编码：<br>
根据赫夫曼树左0右1，对应每个字符编码。这样可以将字符串的长度变少，同样解码也是根据表6-12-3表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103213334549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第七章笔记（图）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/">
        </link>
        <updated>2020-03-01T04:18:59.000Z</updated>
        <content type="html"><![CDATA[<p>1.图的定义G（V,E）其中G表示一个图，V表示图G中顶点集，E表示图G中边的集合<br>
2.线性表中数据元素叫元素，树中数据元素叫结点，在图中数据元素称为顶点<br>
3.线性表中没有数据元素称为空表，树中没有数据元素称为空树，在图的结构中，不允许没有顶点<br>
4.在线性表中相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，在图中，任意两个顶点可能有关系，顶点之间的逻辑关系用边来表示。</p>
<p>7.2.1各种图的定义：<br>
1.如下图 7-2-2是无向图G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}   边集合={(A,B),(B,C),(C,D),(D,A),(A,C)}其中边之间用()来表示<br>
2.如下图7-2-3，是有向图G2=(V2,{E2})， 顶点集合V2={A,B,C,D}  弧集合E2={&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;} A是弧头，D是弧尾 。无向边用()表示，有向边用&lt;&gt;表示<br>
<img src="https://img-blog.csdnimg.cn/2020010619471683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.无向完全图：任意两顶点之间都存在边。含有n个顶点的无向完全图有n*(n-1)/2条边<br>
4.有向完全图：任意两定点之间存在方向相反互为相反的两条弧，含有n个顶点的有向完全图有n*(n-1)条边<br>
5.无向图：边数就是各顶点度数之和的一半<br>
6.有向图：某顶点的度数=出度数+入度数；所有顶点的入度数之和=所有顶点的出度数之和=边数；<br>
7.路径长度：路径上的边或弧的数目，图7-2-9中上方两条路径长度为2，下放两条路径长度为3；图7-2-10中左侧路径长为2，右侧路径长度为3<br>
<img src="https://img-blog.csdnimg.cn/20200106200638165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
8.回路，简单路径，简单回路：<br>
能从出发点绕了一圈又回到出发点，称为回路或环；<br>
序列中顶点不重复出现的路径称为简单路径。<br>
除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路。<br>
如图7-2-11中，左侧的回路是简单回路，右侧的环是不是简单回路，因为c重复了。<br>
<img src="https://img-blog.csdnimg.cn/20200106200657617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
9.若无重复的边或顶点到自身的边则叫简单图，如下图，就不是简单图：<br>
<img src="https://img-blog.csdnimg.cn/20200106204054344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>7.2.3连通图：任意两点之间都是连通的<br>
无向图中的极大连通子图称为连通分量：</p>
<ul>
<li>要是子图</li>
<li>子图是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边<br>
如图7-2-12,图1不是连通图，图2，图3都是子图且都连通，但图4不是连通分量，因为他只有3个顶点<br>
<img src="https://img-blog.csdnimg.cn/20200106201713177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200106201724638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<p>7.2.3.2强连通图：有向+连通图<br>
图中有子图，若子图极大连通就是连通分量，有向的就是强连通分量，如下图中图1不是强连通图，图2是强连通图，同样图2是图1的强连通分量<br>
<img src="https://img-blog.csdnimg.cn/20200106202052518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.3连通图的生成树：包含图中全部的n个顶点，但只有足以构成一棵树的n-1条边，如图2.图3；如果有n个顶点，但是小于n-1条边则是非连通图；如果边多于n-1，则构成环，如图2,3任意给两个顶点之间一条边，就构成环；不过有n-1条边并不一定是生成树，如图4。<br>
<img src="https://img-blog.csdnimg.cn/20200106202847268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.4<br>
如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗有向树。<br>
一个有向图的生成森林由若干课有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧，如下图中，图1是有向图，	去掉弧之后，分解为两个有向树，如图2 图3，这两颗就是图1的有向图的生成森林。<br>
<img src="https://img-blog.csdnimg.cn/20200106203812838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.3图的抽象数据类型：<br>
<img src="https://img-blog.csdnimg.cn/20200106204941634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.4图的五种存储结构：<br>
一.邻接矩阵：<br>
1.图的邻接矩阵存储方式用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。<br>
2.无向图的邻接矩阵的特点：<br>
a.矩阵是关于主对角线对称的<br>
b.Vi顶点的度=第i行或者第i列上的元素之和<br>
c.Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，数组元素为1就是邻接点<br>
d.主队角线上元素为0<br>
<img src="https://img-blog.csdnimg.cn/20200106211104874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.有向图的邻接矩阵的特点：<br>
a.不是对称矩阵<br>
b.主队角线上元素为0<br>
c.顶点Vi的入度为第Vi列各数之和；出度数为第Vi行各数之和<br>
d.判断Vi到Vj是否存在弧，只需要查找矩阵中元素是否为1<br>
e.要求Vi的所有邻接点就是将第i行元素扫描一遍，查找矩阵中元素为1的点<br>
<img src="https://img-blog.csdnimg.cn/20200106211123418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.对于边上的权值而言，如果不存在则为无穷；自身到自身的度为矩阵元素为0,<br>
<img src="https://img-blog.csdnimg.cn/20200106211145807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.图的邻接矩阵存储的结构：</p>
<pre><code class="language-cpp">typedef char VertexType;              //顶点类型应由用户定义
typedef int EdgeType;                //边上的权值类型应由用户定义
#define MAXVEX 100               //最大顶点数
#define INFINITY 65535          //用65535来表示无穷
typedef struct 
{
	VertexType vexs[MAXVEX];            //顶点表
	EdgeType arc[MAXVEX][MAXVEX];           //邻接矩阵，
	int numVertexes, numEdges;         //图中当前顶点数和边数
}MGraph;
</code></pre>
<p>6.构造一个无向图</p>
<pre><code class="language-cpp">//建立无向图的邻接矩阵
void CreateMGraph(MGraph *G)
{
	int i,j,k,w;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);     //输入顶点数，边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)            //读入顶点信息，建立顶点表
		scanf(&amp;G-&gt;vexs[i]);
	for(i=0; i&lt;G-&gt;numVertexes; i++)
		for(j=0; j&lt;G-&gt;numVertexes; j++)
			G-&gt;arc[i][j]=INFINITY;            //邻接矩阵初始化
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的下标i，下标j和权w:\n&quot;);
		scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;w);    //输入边(Vi,Vj)上的权W
		G-&gt;arc[i][j]=w;
		G-&gt;arc[i][j]=G-&gt;arc[i][j];      //因为是无向图，矩阵对称
	}
//时间复杂度为o(n+n^2+e):n个顶点，e条边 最终为o(n^2)
}
</code></pre>
<p>二.邻接表：<br>
1.顶点用一维数组来存放，另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针；每个顶点的所有邻接点构成一个线性表，用单链表存储<br>
2.第Vi个顶点的度，就去查这个顶点的边表中结点的个数<br>
3.要判断Vi与Vj之间是否存在边，只需要测试顶点Vi的边表中是否存在结点Vj的下标j就行<br>
4.若要求顶点的所有邻接点，就对此顶点的边表进行遍历，得到的就是邻接点。见下图7-4-6<br>
5.有向图的逆邻接表，就是看谁往这个点里干，如下图7-4-7(2)<br>
6.有向图的邻接表，如下图7-4-7（1）<br>
7.带权值的邻接表，如下图7-4-8<br>
<img src="https://img-blog.csdnimg.cn/20200106215146181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621520519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621522774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
邻接表结点定义的代码：</p>
<pre><code class="language-cpp">typedef char VertexType;             //顶点类型由用户定义
typedef int EdgeType;                 //边上的权值类型由用户定义

typedef struct EdgeType          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}GraphAdjList；
</code></pre>
<p>无向图的邻接表创建代码：</p>
<pre><code class="language-cpp">//建立图的邻接表结点
void CreateALGraph (GraphAdjList *G)
{
	int i,j,k;
	EdgeNode *e;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);        //输入顶点数和边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)          //读入顶点信息，建立顶点表
	{
		scanf(&amp;G-&gt;adjList[i].data);       //输入顶点信息
		G-&gt;adjList[i].firstedge=NULL;        //将指向边表的头结点置为空
	}
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的顶点序号:\n&quot;);
		scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);          //输入边（vi,vj）上的顶点序号
		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=j;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[i].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[i].firstedge=e;          //把e这个结点在放回头结点 

		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=i;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[j].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[j].firstedge=e;          //把e这个结点在放回头结点 
	}
}
时间复杂度为o(n+e)=o(n)  //n个顶点，e条边
</code></pre>
<p>第三种：十字链表：就是将邻接表和逆邻接表相结合方便了解结点的出度和入度<br>
1.重新定义顶点表结点结构，如下图，<br>
firstin 表示入边表头指针，指向该顶点的入边表中第一个结点<br>
firstout 表示出边表指针，指向该顶点的出边表中的第一个结点<br>
<img src="https://img-blog.csdnimg.cn/20200107202857870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义边表结点结构，如下图：<br>
tailvex是指弧起点在顶点表的下标<br>
headvex是指弧终点在顶点表中的下标<br>
headlink是指边表指针域，指向终点相同的下一条边<br>
taillink 是指边表指针域，指向起点相同的下一条边<br>
<img src="https://img-blog.csdnimg.cn/20200107202912422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200107204325664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
v0中firstout指向它自己的边表结点，后面那个边表结点中03表示从0开始走到3；v0中fistrtin表示V1走向它，他犯贱再走向v1，v0再也没有可走的下一个结点，所以taillink为NULL；v0走向v3，没有人与他一样再走向v3所以headlink为NULL<br>
v1中firstou指向自己的边表结点，后面10 。12分别表示从v1走向V0，从v1走向V2；所以v1第一个边表结点中taillink指向下一个，由于1走向0,2也走向0，所以v1中第一个边表结点走到v2中第一个边表结点；同样V2走向V1，v1犯贱它的fisttin指向V2中第2个边表结点<br>
v2也是如此，重点强调由于v2走向v0，没有人再走向v0所以v2中第一个边表结点的healink为空</p>
<p>第四种：邻接多重表<br>
1.如果要删除边，则对于下图的邻接表而言太复杂对于结点而言改动太多<br>
<img src="https://img-blog.csdnimg.cn/20200107210841424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义如下结构：<br>
ivex和jvex表示与某条边依附的两个顶点在顶点表中的下标。<br>
ilink指向依附顶点ivex的下一条边。<br>
jlink指向依附顶点jvex的下一条边</p>
<p><img src="https://img-blog.csdnimg.cn/20200107211110577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010721132679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
1-4表示连接它自己的边表结点<br>
5表示依附于v0的下一条边：v0--v3   6表示依附于v0的下一条边：v0--v2  7表示依附于v1的下一条边：v1--v0<br>
8表示依附于v2的下一条边：v2--v3  9表示依附于v2的下一条边：v2--v0  10表示依附于v2的下一条边：v3--v2</p>
<p>第五种：边集数组：<br>
如下图，就能看懂</p>
<p><img src="https://img-blog.csdnimg.cn/20200107212244138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.5.1深度优先遍历：<br>
1.简称DFS，说白了就是遍历图中每个顶点然后，所有路径都走一遍。遍历过的顶点做好标记就不在遍历<br>
邻接矩阵的DFS代码如下：</p>
<pre><code class="language-cpp">typedef int Boolean;        //Boolean是布尔类型，其值是TRUE或FALSE
Boolean visited[MAX];       //访问标志的数组
//邻接矩阵的深度优先递归算法
void DFS(MGraph G, int i)
{
	int j;
	visited[i]=TRUE;
	printf(&quot;%c&quot;,G.vexs[i]);              //vexs【】表示顶点数组
	for(j=0; j&lt;G.numVertexes; j++)
			if(G.arc[i][j]==1 &amp;&amp; !visited[j])   //arc表示边表数组，1表示两个点之间有值
				DFS(G,j);          //对访问的邻接顶点递归调用
}
//邻接矩阵的深度遍历操作
void DFSTraverse(MGraph G)
{
	int i;
	for(i=0; i&lt;G.numVeretexes; i++)
		visited[i]=False;          //初始所有顶点都是未访问过的状态
	for(i=0; i&lt;G.numVertexes; i++)
		if(!visited[i])            //对未访问过的顶点调用DFS
			DFS(G,i); 
}
时间复杂度是o(n^2)
</code></pre>
<p>邻接表的深度优先递归算法：</p>
<pre><code class="language-cpp">void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
	visited[i]=TRUE;
	printf(&quot;%c &quot;, GL-&gt;adjList[i].data);           //打印顶点，adjLIst表示顶点结构数组，结构成员有data和fistredge指针
	while(p)
	{
		if(!visited[p-&gt;adjvex])
			DFS(GL,p-&gt;adjvex);          //对访问的邻接顶点递归调用
		p=p-&gt;next;
	}
}

//邻接表的深度遍历操作
void DFSTraverse(GraphAdjList GL)
{
	int i;
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		visited[i]=FALSE:     //初始化所有顶点都是未访问过的
	for(i=0; i&lt; GL-&gt;numVertexes; i++)
		if(!visited[i])     //对访问过的顶点调用DFS
		DFS(GL,i);
}

时间复杂度是o(n+e);
</code></pre>
<p>邻接矩阵的广度遍历算法：简称BFS</p>
<pre><code class="language-cpp">/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G)
{
    int i,j;
    Queue Q;
    for(i=0; i&lt;G.numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //初始化一辅助队列
    for(i=0; i&lt;G.numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, G.vex[i]);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                for(j=0; j&lt;G.numVertexes; j++)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
                        {
                            visited[j]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, G.vexs[j]);   //打印顶点
                            EnQueue(&amp;Q,j);        //将找到的此顶点入队列
                        }
                    }
            }
        }
    }
}
</code></pre>
<p>邻接表的广度遍历算法</p>
<pre><code class="language-cpp">/*邻接表的广度遍历算法*/
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;     //边表结点
    Queue Q;
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //舒适化一辅助队列
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, GL-&gt;adjList[i].data);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                p=GL-&gt;adjList[i].firstedge; //找到当前顶点边表链表表头指针
                while(p)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(!visited[p-&gt;adjvex])  //若顶点未被访问过
                        {
                            visited[p-&gt;adjvex]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, GL-&gt;adjList[p-&gt;adjvex].data);   //打印顶点
                            EnQueue(&amp;Q,p-&gt;adjvex);        //将找到的此顶点入队列
                        }
                        p=p-&gt;next;     //指针指向下一个邻接点
                    }
            }
        }
    }
}
</code></pre>
<p>深度优先遍历：更适合目标比较明确，已找到目标为主要目的，类似于前序遍历<br>
广度优先遍历：更适合在不断扩大遍历范围时找到相对最优解情况 ，类似于层序遍历</p>
<p>7.6.1Prim算法：<br>
<img src="https://img-blog.csdnimg.cn/20200108213856363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
Prim算法生成最小生成树</p>
<pre><code class="language-cpp">/*Prim算法生成最小生成树*/
void MiniSpanTree_Prim(MGraph G)
{
    int min,i,j,k;
    int adjvex[MAXVEX];     //保存相关顶点下标
    int lowcost[MAXVEX];      //保存相关顶点间边的权值
    
    lowcost[0]=0;      //初始化第一个权值为0，即v0加入生成树
                       //lowcost的值为0，在这里就是此下标的顶点已经加入生成树
    adjvex[0]=0;        //初始化第一个顶点下标为0
    
    for(i=1; i&lt;G.numVertexes; i++)      //循环除下标为0外的全部顶点
    {
        lowcost[i]=G.arc[ 0][i];    //将V0顶点与之有边的权值存入数组
        adjvex[i]=0;     //初始化都为v0的下标
    }
    
    for(i=1; i&lt;G.numVertexes; i++)
    {
        min=INFINITY;         //初始化最小权值为无穷
        j=1;k=0;      //j用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标、
        
        //20--29表示找出最小值min和对应的数组下标k
        while(j&lt;G.numVertexes)    //循环全部顶点
        {
            if(lowcost[j]!=0 &amp;&amp; lowcost[j]&lt;min)
                {
                    //如果权值不为0且权值小于min
                    min=lowcost[j];      //则让当前权值称为最小值
                    k=j;                    //将当前最小值的下标存入k
                }
            j++;
        }
        
        printf(&quot;(%d,%d)&quot;,adjvex[k],k);      //打印当前顶点边中权值最小边,比如打印结果为(0,1),表示V0至v1遍为最小生成树的第一条边
        
        lowcost[k]=0;     //将当前顶点的权值设置为0，表示此顶点已经完成任务
        
        for(j=1; j&lt;G.numVertexes; j++)   //循环所有顶点
        {
            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])
            {
                //若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值
                lowcost[j] = G.arc[k][j];   //将较小权值存入lowcost
                adjvex[j]=k;  //将下表为k的顶点存入adjvex
            }
        }
        
    }
}

</code></pre>
<p>以下便是Prim算法的过程，最终构成n-1条边，遍历完所有顶点，以某顶点为起点，逐步找各顶点上权值最小的边构建最小生成树<br>
<img src="https://img-blog.csdnimg.cn/20200108214446923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214454992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Krskal算法：求最小生成树<br>
1.将邻接矩阵转化为边集数组：<br>
如下图<br>
<img src="https://img-blog.csdnimg.cn/20200109205012741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">/*Kruskal算法*/
void MiniSpanTree_Kruskal(MGraph G) //生成最小生成树
{
    int i,n,m;
    Edge edges[MAXEDGE];    //定义边集数组
    int parent[MAXEDGE];   //定义一数组用来判断边与边是否形成环路
    
    //此处省略将邻接矩阵G转化为边集数组edges并按权值由小到大排列的代码
    for(i=0; i&lt;G.numVertexes; i++)
            parent[i]=0;      //初始化数组为0
    for(i=0; i&lt;G.numEdges; i++)  //循环每一条边
    {
        n=Find(parent,edges[i].begin);
        m=Find(parent,edges[i].end);
        if(n!=m)
            {
                parent[n]=m;   //将此边的结尾顶点放入下表为起点的parent中
                                //表示此顶点已经在生成树集合中
                print(&quot;(%d,%d)&quot;,edges[i].begin,edges[i].end,edges[i].weight);
            }
    }
}

int Find(int *parent, int f)  //查找连线顶点的尾部下标
{
    while(parent[f]&gt;0)
        f=parent[f];
    return f;
}
算法中find函数有e决定，时间复杂度为o(loge)，而外面有一个for循序e次，所以时间复杂度为o(eloge)

</code></pre>
<p>具体执行过程如下：<br>
<img src="https://img-blog.csdnimg.cn/20200109205414490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205430984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205507351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205531372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205550570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205617883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在E中选择最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此加入到T中，否则舍去此边而选择下一条代价最小的边<br>
k式算法主要针对边来展开，边数少效率非常高，适合稀疏图。p式算法对于稠密图，边数非常多情况会更好<br>
锋说：就是每次找最小的边，不要形成回路，然后最终能将图中所有顶点连接起来<br>
总结：p式算法就是以某个顶点开始找与这个点相关的最小 的边，每次这样寻找；而k式算法就是直接上来找最小的边不形成回路，最终将整个点连起来，他俩都是去找连通图的最小生成树</p>
<p>7.7迪杰斯特拉算法：求最短路径</p>
<pre><code class="language-cpp">#define MAXVEX 9
#define INFINITY 65535
typedef int Patharc[MAXVEX];      //用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX];    //用于存储到各个顶点路径权值和
//Dijkstra算法，求有向网G的v0顶点到其余顶点V最短路径p[V]即带权长度D[V]
//P[V]的值为前驱顶点下标，D[V]表示v0到v的最短路径长度和
void ShortestPath_Dijkstra (MGraph G, int v0, Patharc *p, ShortPathTable *D)
{
	int v,w,k,min;
	int final[MAXVEX];   //final[w]=1 表示求得顶点v0至vw的最短路径
	for(v=0; v&lt;G.numVertexes; v++)     //初始化数据
	{
		final[v]=0;
		(*D)[V]=G.arc[v0][v];         //将与v0点有连线的顶点加上权值
		（*p）[v]=0;            //初始化路径数组p为0
	}
	(*D)[v0]=0;     //v0至v0的路径为0
	final[v0]=1;           //v0至v0不需要求路径
	
	//开始主循环，每次求得V0到某个顶点v的最短路径
	for(v=1; v&lt;G.numVertexes; v++)
	{
		min=INFNITY;      //当前所知离v0顶点的最近距离
		
		for(w=0; w&lt;G.numVertexes; w++)    //寻找离v0最近的顶点
		{
			if(!final[W] &amp;&amp; (*D)[W]&lt;min)
			{
				k=w;
				min=(*D)[W];         //w顶点离v0顶点更近
			}
		}
		
		final[k]=1;      //将目前找到的最近的顶点置位1
		
		for(w=0; w&lt;G.numVertexes; w++)    //修改当前最短路径及距离
		{
			//如果经过v顶点的路径比现在这条的路径长度短的话
			if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[W]))
			{
				//说明找到了更短的路径，修改D[W]和p[W]
				（*D)[w]=min+G.arc[k][w];    //修改当前路径长度
				(*p)[w]=k;
			}
		}
	}
}
时间复杂度：o(n^2)

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200110010608603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110010632915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
数组D，数组P含义：上图中比如到v3的最短路径长度是7，比如到v5的最短路径长度是8。。<br>
数组p表示V0-----&gt;V8的最短路径中，P[8]=7表示V8的前驱节点为V7；P[4]=2表示V4的前驱节点是2.。。<br>
如果想要知道任意顶点开始到某结点的最短路径，那就没到一个结点就用一次迪杰斯特拉算法，这 样的复杂度为o(n^3)<br>
<img src="https://img-blog.csdnimg.cn/20200110010656741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：其实迪杰斯特拉算法目的是计算从某个点到某个点的最短路径，思想就是每次找到最短的路径，把他放入到已经找到的路径中，很漂亮的思想</p>
<p>7.7.2.FLoyd算法：求最短路径</p>
<pre><code class="language-cpp">typedef int Pathmatirx[MAXVEX][MAXVEX];
typedef int ShortPathTable [MAXVEX][MAXVEX];
//FLoyd算法，求网图中G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]
void ShorttestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)
{
	int v,w,k;
	for(v=0; v&lt;G.numVertexes; ++w)
	{
		for(w=0; w&lt;G.numVertexes; w++)
		{
			(*D)[v][w]=G.matirx[v][w];     //D[v][w]值即为对应点间的权值
			(*p)[v][w]=w;                 //初始化p
		}
	}
	for(k=0; k&lt;G.numVertexes; ++k)     //k相当于每次拐出来的点
	{
		for(v=0; v&lt;G.numVertexes; ++v)
		{
			for(w=0; w&lt;G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k]+(*D)[k][w])
				{
					//如果经过下标为k顶点路径比原两点间路径更短
					//将当前两点间权值设为更小的一个
					(*D)[v][w]=(*D)[v][k]+(*D)[k][w];
					(*p)[v][w]=(*p)[v][k];           //路径设置为下标为k的顶点
				}
			}
		}
	}
}   时间复杂度o(n^3)

</code></pre>
<p>最短路径的显示代码</p>
<pre><code class="language-cpp">for(v=0; v&lt;G.numVertexes; ++v)
{
	for(w=v+1; w&lt;G.numvertexes; w++)
	{
		printf(&quot;v%d-v%d weight: %d&quot;,v,w,D[v][w]);  //输出从某个点到某个点的路径权值
		k=p[v][w];       //获得第一个路径顶点的下标
		printf(&quot; path: %d&quot;,v);         //打印原点
		while(k!=w)            //如果路径顶点下标不是终点
		{
			printf(&quot; -&gt; %d&quot;,k);          //打印路径顶点
			k=p[k][w];           //获得下一个路径顶点下标，p数组已经设置好了
		}
		printf(&quot; -&gt; %d\n&quot;,w);     //打印终点
	}
	printf(&quot;\n&quot;);         
}

</code></pre>
<p>上面代码图示：<br>
<img src="https://img-blog.csdnimg.cn/20200110220429452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110215942248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
矩阵D表示从某个点到某个点的最短路径长度<br>
p矩阵的含义不用知道，只要知道怎么通过此矩阵找到最短路径<br>
以v0--v8<br>
首先p[0][8]=1,表示经过v1<br>
再看v[1][8]=2，表示经过v2<br>
再看v[2][8]=4, 表示经过v4.。。。。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200110220005694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：迪杰斯特拉算法和弗洛伊德算法的相同与不同：<br>
相同点：<br>
1.都是求某个点到某个点的最短路径<br>
2.核心思路都是不断的找最短的路径归并到已经找到的路径集合中<br>
不同点：<br>
1.D通过min+下一次的路径和直接到达路径长度比较；而F通过拐点k来表示i--&gt;k---&gt;j要比i---&gt;j路径要短<br>
2.最终得到的数组D都是表示vi到vj的最短路径，而p不同，其中D中p只能表示以v0为起点，到其余各点的最短路径；比如要想知道v2，v3...到其余各点的最短路径，只能再次将v2，v3当做源头再次使用D式算法。但是F式算法中p可以知道所有顶点到所有顶点的最短路径</p>
<p>7.8.2拓扑排序：判断工程能否顺利进行<br>
在一个有向图中，就像拍电影有先后顺序，这样的网图称为AOV图，如下所示：<br>
下图中的一个拓扑序列是：v0v1v2v3v4v5v6v7v8v9v10v11v12v13v14v15v16<br>
<img src="https://img-blog.csdnimg.cn/2020011221284919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
而且AOV图不存在回路，所以在输出时如果顶点数少了一个，则说明不是回路，如果顶点被全部输出，则说明它不存在回路。</p>
<p>对AOV网进行拓扑排序的基本思路：<br>
从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>
在拓扑排序算法中，涉及的结构代码如下，使用邻接表来构造：</p>
<pre><code class="language-cpp">​```cpp
typedef struct EdgeNode          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	int in;
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}graphAdjList,*GraphAdjList；

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200120200549858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
in表示入度域，下面的邻接表就是表示上图<br>
<img src="https://img-blog.csdnimg.cn/20200120200610526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
拓扑排序的代码：</p>
<pre><code class="language-cpp">//拓扑排序
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);        //打印此顶点
		count++;              //统计输出顶点数
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}
时间复杂度：
第一个for循环，一共n个顶点，时间复杂度为o(n)
下面while，从下图6可以看出，最后删除边都没有了，所以时间复杂度为o(e)
最终时间复杂度为o(n+e)

</code></pre>
<p>具体过程如下：<br>
先从v3开始<br>
<img src="https://img-blog.csdnimg.cn/20200120205711970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
打印输出v3<br>
<img src="https://img-blog.csdnimg.cn/20200120205731362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
依次类推，如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120205817307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200120205824667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
最终拓扑排序的结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;8-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11，当然这个拓扑排序结果不唯一</p>
<p>7.9关键路径：求完成工程最短的时间问题，利用求出关键路径算法，求出完成工程的最短时间和关键活动有哪些？<br>
1.关键路径用AOE表示，AOV表示活动之间以相互制约关系，而AOE是在AOV的基础上来分析完成整个活动所需的最短时间，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120210958150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
其中每个AOE网图都有一个源点和汇点<br>
路径长度：路径上各个活动所持续的时间之和称为路径长度<br>
从源点到汇点的具有最大长度的路径叫关键路径，关键路径上的活动叫关键活动<br>
<img src="https://img-blog.csdnimg.cn/20200120211017839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.9.1关键路径的算法原理：<br>
放学回家到睡觉，一共4个小时。写作业两个小时，最早开始时间是一回来，可以理解为0。最晚开始时间为2个小时之后，可以理解为2。当最早开始时间和最晚开始时间不相同时，表示有空闲时间。当买了很多的习题时，时间全部被占满，则最早和最晚开始时间为都是0，因此他就是关键活动。<br>
1.事件的最早发生时间etv：即顶点vk的最早发生时间<br>
2.事件的最晚发生时间ltv：即顶点vk的最晚发生时间，如果超过此时间，就会延误整个工期<br>
3.活动最早开工时间ete：即弧ak的最早发生时间<br>
4.活动最晚开工时间lte：即弧ak的最晚发生时间<br>
通过1,2求得3,4，然后根据ete[k]与lte[k]是否相等来判断ak是否为关键活动</p>
<p><img src="https://img-blog.csdnimg.cn/20200201213730233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
下列代码求etv的过程，与拓扑排序类似</p>
<pre><code class="language-cpp">int *etv, *ltv;           //时间最早发生时间和最迟发生时间数组
int *stack2;            //用于存储拓扑排序的栈
int top2;            //用于stack2的的指针

//拓扑排序，用于关键路径计算
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	top2=0;           //初始化为0
	etv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));        //事件最早发生的时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		etv[i]=0;             //初始化为0
	stack2=(int *)malloc(GL-&gt;numVertexes*sizeof(int));      //初始化
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		count++;              //统计输出顶点数
		stack2[++top2]=gettop;       //将弹出的顶点序号压入拓扑序列的栈
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
			if((etv[gettop]+e-&gt;weight)&gt;etv[k])     //求各顶点事件最早发生时间
				etv[k]=etv[gettop]+e-&gt;weight;
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}

</code></pre>
<p>上面代码的例子如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200201214810950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
对于v3来说，4+8&gt;3+5，所以v3=12。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200201214925217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关键路径的算法代码：</p>
<pre><code class="language-cpp">//求关键路径，GL为有向图，输出GL的各项关键活动
void CriticalPath(GraphAdjList GL)
{
	EdgNode *e;
	int i,gettop,k,j;
	int ete,lte;             //声明活动最早发生时间和最迟发生时间
	TopologicalSort(GL);           //求拓扑序列，计算数组etv和stack2
	ltv=(int *)malloc(GL-&gt;numverteces*sizeof(int));    //事件最晚发生时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		ltv[i]=etv[GL-&gt;numVertexes-1];    //初始化ltv
	while(top2!=0)      //计算ltv
	{
		gettop=stack2[top2--];   //将拓扑序列出栈，后进先出
		for(e=GL-&gt;adjList[gettop].firstedge; e; e=e-&gt;next)
		{
			//求各顶点最迟发生时间ltv
			k=e-&gt;adjvex;
			if(ltv[k]-e-&gt;weight&lt;ltv[gettop])   //求各顶点事件最晚发生时间
				ltv[gettop]=ltv[k]-e-&gt;weight;
		}
	}
	for(j=0; j&lt;GL-&gt;numVertexes; j++)    //求ete,lte和关键活动
	{
		for(e=GL-adjList[j].firstedge; e; e=e&gt;next)
		{
			k=e-&gt;adjvex;        
			ete=etv[j];       //活动最早发生时间
			lte=ltv[k]-e-&gt;weight;   //活动最迟发生时间
			if(ete=lte)                //两者相等即在关键路径上
				printf(&quot;&lt;v%d,v%d&gt; length: %d , &quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);
		}
	}
}


</code></pre>
<p>上述代码所求etv和ltv如下所示+关键路径如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200201220607841.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200201220623475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
总结：<br>
etv通过拓扑排序算出最早发生的时间，每次找权值较大的<br>
ltv相当于从后向前算出最晚发生时间，每次找权值较小的<br>
ete=etv[j]表示当事件发生时，最早开工时间（当然必须事件发生，才开工）<br>
lte=ltv[k]-e-&gt;weight表示事件最晚发生的时间-要完成工作的时间（比如23点睡觉，写作业2h，可以23点才开始写但要睡觉所以最晚开工时间是21点，最晚21点开始写，就是这意思，有点牵强，理解即可）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第8章笔记（查找）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-8-zhang-bi-ji-cha-zhao/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-8-zhang-bi-ji-cha-zhao/">
        </link>
        <updated>2020-03-01T04:12:42.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump">8.1开场白+8.2查找概论</a><br>
<a href="#jump1">8.3顺序表查找</a><br>
      <a href="#jump2">8.3.1顺序查找算法</a><br>
      <a href="#jump3">8.3.2顺序表查找优化</a><br>
<a href="#jump4">8.4有序表查找</a><br>
      <a href="#jump5">8.4.1折半查找</a><br>
      <a href="#jump6">8.4.2插值查找</a><br>
      <a href="#jump7">8.4.7裴波那契查找</a><br>
<a href="#jump8">8.5线性索引查找</a><br>
      <a href="#jump9">8.5.1稠密索引</a><br>
      <a href="#jump10">8.5.2分块索引</a><br>
      <a href="#jump11">8.5.3倒排索引</a></p>
<p><a href="#jump12">8.6二叉排序树</a><br>
      <a href="#jump13">8.6.1二叉排序树查找操作</a><br>
      <a href="#jump14">8.6.2二叉排序数插入操作</a><br>
      <a href="#jump15">8.6.3二叉排序树删除操作</a><br>
      <a href="#jump16">8.6.4二叉排序树总结</a><br>
<a href="#jump17">8.7（平衡二叉树）AVL树</a><br>
      <a href="#jump18">8.7.1平衡二叉树实现原理</a><br>
      <a href="#jump19">8.7.2平衡二叉树实现算法</a><br>
<a href="#jump20">8.8多路查找树</a><br>
<a href="#jump21">8.9散列表查找（哈希表）概述</a><br>
<a href="#jump22">8.10散列函数的构造方法</a><br>
<a href="#jump23">8.11处理散列冲突的方法</a><br>
<a href="#jump24">8.12散列表查找实现</a><br>
      <a href="#jump25">8.12.1散列表查找算法实现</a><br>
      <a href="#jump26">8.12.2散列表查找性能分析</a></p>
<p><span id="jump">8.1开场白+8.2查找概论</span><br>
<strong>1.查找表</strong>：静态查找表+动态查找表<br>
a.静态查找表：查询某个特定的数据元素是否在查找表中+检索某个特定的数据元素和各种属性<br>
b.动态查找表：查找时插入元素，查找时删除元素<br>
<strong>2.静态查找</strong>----线性结构组织数据+顺序查找法+对于主关键字排序可以使用折半查找<br>
<strong>3.动态查找</strong>----二叉排序树的查找技术</p>
<p><span id="jump1">8.3顺序表查找</span></p>
<ul>
<li>顺序查找过程：从表中第一个开始，逐个进行记录的关键字和给定值比较，若某个记录关键字和给定值相同则查找成功，如果找到最后一个，其关键字和给定值都不同，则查找失败</li>
<li><span id="jump2">8.3.1顺序查找算法代码</span></li>
</ul>
<pre><code class="language-cpp">/*顺序查找，a为数组，n为要查找的数组长度，key为要查找的关键字*/
int Sequential_Search(int *a,int n, int key)
{
	int i;
	for(i=1;i&lt;=n;i++)
	{
		if(a[i]==key)
		{
			return i;
		}
	}
	return 0;
}
</code></pre>
<blockquote>
<p>由于上面的查找中每次都要i&lt;=n的判断，实际上设置一个哨兵即可，如下代码</p>
</blockquote>
<ul>
<li><span id="jump3">8.3.2顺序表查找优化</span></li>
</ul>
<pre><code class="language-cpp">/*有哨兵顺序查找*/
int Sequential_Search2(int *a,int n,int key)
{
	int i;
	a[0]=key;        //设置a[0]为关键字值，称为“哨兵”
	i=n;             //循环从数组尾部开始
	while(a[i]!=key)
	{
		i--;
	}
	return i;    //返回0则查找失败
}
</code></pre>
<blockquote>
<p>此代码从尾部开始查找，a[0]=key，如果在a[i]中有key则返回i值，查找成功。否则一定在最终的a[0]处等于key，此时返回0，说明查找失败</p>
</blockquote>
<p><span id="jump4">8.4有序表查找</span></p>
<ul>
<li><span id="jump5">8.4.1折半查找</span></li>
</ul>
<blockquote>
<p>思想：折半查找的前提是线性表中的记录必须是关键码有序（通常从小到大）。在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右边区继续查找。不断重复上述过程，直到查找成功，或查找区域无记录，查找失败</p>
</blockquote>
<p>参考代码：<strong>折半查找时间复杂度o(logn)</strong></p>
<pre><code class="language-cpp">/*折半查找*/
int Binary_Search(int *a,int n, int key)
{
	int low,high,mid;
	low=1;                  //定义最低下标为记录首位
	high=n;                  //定义最高下标为记录末位
	while(low&lt;=high)
	{
		mid=(low+high)/2;         //折半
		if(key&lt;a[mid])        //若查找值比中指小
			high=mid-1;
		else if(key&gt;a[mid])     //若查找值比中指大
			low=mid+1;         //最底下标调整到中位下标大一位
		else 
			return mid;         //若相等则说明mid即为查找到的位置
	}
	return 0;
}
</code></pre>
<p>查找过程如下：<br>
<img src="https://img-blog.csdnimg.cn/2020020322192170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200203221858846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
用二叉树示意如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200203221500884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><span id="jump6">8.4.2插值查找</span></li>
</ul>
<blockquote>
<p>插值查找时根据要找的关键字key与查找表中最大最小的关键字比较后的查找方法，其核心在于插值公式如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200204210604921.png" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<pre><code class="language-cpp">将折半查找的第8行代码改为：mid=low+(high-low)*(key-a[low])/(a[high]-a[low]); 
</code></pre>
<ul>
<li><span id="jump7">8.4.3裴波那契查找</span></li>
</ul>
<p>参考代码：</p>
<pre><code class="language-cpp">//裴波那契查找
int Fibonacci_Search(int *a,int n,int key)
{
	int low,high,mid,i,k;
	low=1;           //定义最低下标为记录首位
	high=n;            //定义最高下标为记录末位
	k=0;           
	while(n&gt;F[k]-1)     //计算n位于裴波那契数列的位置，F[k]就是裴波那契数列，a[n]就是要查找的数列
		k++;
	for(i=n; i&lt;F[k]-1; i++)    //将不满的数值补全
		a[i]=a[n];
	while(low&lt;=high)
	{
		mid=low+F[k-1]-1;       //计算当前分隔的下标
		if(key&lt;a[mid])         //若查找记录小于当前分隔记录
		{
			high=mid-1;          //最高下标调整到分隔下标mid-1处
			k=k-1;          //裴波那且数列下标减一位
		}
		else if(key&gt;a[mid])     //若查找记录大于当前分隔记录
		{
			low=mid+1;          //最低下标调整到分隔下标mid+1处
			k=k-2;         //裴波那契数列下标减2位
		}
		else 
		{
			if(mid&lt;=n)
				return mid;        //若相等则说明mid即为查找到的位置
			else 
				return n;       //若mid&gt;n说明是补全数值，返回n
		}
	}
	return 0;
}

</code></pre>
<p>代码过程如下图：<br>
<img src="https://img-blog.csdnimg.cn/2020020421202886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200204212039617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>时间复杂度为o(logn)，但就平均性能而言要优于折半查找</p>
</blockquote>
<p><span id="jump8">8.5线性表的索引查找</span></p>
<ul>
<li><span id="jump9">8.5.1稠密索引</span></li>
</ul>
<blockquote>
<p>1.稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，索引项一定是按照关键码的有序排列<br>
2.查找关键字可以用折半查找，插值，裴波那契...查找方法<br>
3.如果对于右边的表进行查找，只能进行顺序查找<br>
如下图所示</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200204214358391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<ul>
<li><span id="jump10">8.5.2分块索引</span></li>
</ul>
<blockquote>
<p>分块索引的条件：<br>
1.块内无序：<br>
2.块间有序：要求后一块中所记录的关键字都大于第一块中所有记录的关键字，并且无序排列（如下图）</p>
</blockquote>
<blockquote>
<p>分块索引的数据项：<br>
1.最大关键码：记录块间中的最大关键字<br>
2.存储块中记录的个数，便于循环使用<br>
3.用于指向块首数据元素的指针，便于进行遍历</p>
</blockquote>
<blockquote>
<p>分块索引的步骤：<br>
1.在块内进行折半查找，插值查找...比如找62， 57&lt;62&lt;96在第三个块中<br>
2.根据块首指针找到相应的块，然后只能进行顺序查获</p>
</blockquote>
<p>分块索引的平均查找长度是根号N+1，时间复杂度为o(n)<br>
<img src="https://img-blog.csdnimg.cn/20200204215835239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<ul>
<li><span id="jump11">8.5.3倒排序索引</span><br>
1.根据句子中单词，做一张单词表，然后在搜索框中，输入book，就能对应编号为1,2的文章地址，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200204220611135.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200204220624233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<blockquote>
<p>索引项的通用结构是：<br>
1.次关键码：英文单词，相当于属性<br>
2.记录号表：文章编号，相当于记录的地址<br>
根据属性来找地址，称为倒排</p>
</blockquote>
<ul>
<li><span id="jump12">8.6二叉排序树</span></li>
</ul>
<blockquote>
<p>1.查找时插入或删除的查找表称为动态查找表，用二叉排序树这样的数据结构进行存储</p>
</blockquote>
<p>比如下图中将58插入进去，对于线性表而言还要进行移位，但对于二叉树结构而言直接将58插入到62的左子树。这就是二叉排序树的方便之处。<br>
<img src="https://img-blog.csdnimg.cn/20200206215810741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.二叉树性质：<br>
    若他的左子树不空，则左子树上所有的结点的值小于它的根结构的值<br>
    若他的右子树不空，则右子树上所有的结点的值大于它的根结构的值<br>
3.对于数列{35,37,47,51,58,62,73,88,93,99}而言，具体的二叉排序树如下图所示</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200206220326298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">8.6.1二叉排序树查找操作</span></p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode              //结点结构
{
	int data;                         //结点数据
	struct BiTNode *lchild,*rchild;     //左右孩子指针
}
</code></pre>
<pre><code class="language-cpp">//递归查找二叉排序树T中是否存在key
//指针f指向T的双亲，其初始调用值为NULL
//若查找成功，则指针p指向该数据元素结点，并返回TRUE
//否则指针p指向查找路径上访问的最后一个结点并返回false
Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{	
	if(!T)    //查找不成功
	{
		*p=f;
		return FALSE;
	}
	else if(key==T-&gt;data)   //查找成功
	{
		*p=T;
		rerturn TRUE;
	}
	else if(key&lt;T-&gt;data)
		return SearchBST(T-lchild,key,T,p);   //在左子树继续查找
	else
		return SearchBST(T-&gt;rchild,key,T,p);    //在右子树继续查找
}

</code></pre>
<p>详细过程见下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200210205514299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210205524491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump14">8.6.2二叉排序数插入操作</span></p>
<pre><code class="language-cpp">//当前二叉排序树T中不存在关键字等于key的数据元素
//插入key并返回TRUE，否则返回FALSE
Status InsertBST(BiTree *T,int key)
{
	BiTree p,s;
	if(!SearchBST(*T,key,NULL,&amp;p))     //查找不成功
	{
		s=(BiTree)malloc(sizeof(BiTNode));
		s-&gt;data=key;
		s-&gt;lchild=s-&gt;rchild=NULL;
		if(!p)
			*T=s;          //插入s为新的根结点
		else if(key&lt;p-&gt;data)    //插入s为左孩子
			p-&gt;lchild=s;    
		else
			p-&gt;rchild=s;    //插入s为右孩子
		return TRUE;
	}
	else
		return FALSE;    //树中已有关键字相同的结点，不再插入
}
</code></pre>
<p>下面代码展示如何将数组a[10]={62,88,58,47,35,73,51,99,37,93}，插入到一颗二叉树中</p>
<pre><code class="language-cpp">int i;
int a[10]={62,88,58,47,35,73,51,99,37,93};
BiTree T=NULL;
for(i=0; i&lt;10; i++)
	InsertBST(&amp;T,a[i);

</code></pre>
<p>上述代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200210220504209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     <span id="jump15">8.6.3二叉排序树删除操作</span><br>
分为3 种情况：</p>
<ul>
<li>叶子结点：直接删除就行</li>
<li>仅有左或右子树的结点：<br>
删除结点后，将他的左子树或右子树整个移动到删除结点的位置即可，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200210215813523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210215741243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
<li>左右子树均有结点：<br>
找到需要删除结点p的直接前驱或者直接后继s，将s来替换结点p，然后在删除结点s，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200210215902234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/2020021021584512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<table><tr><td bgcolor=GreenYellow>下面代码这个算法是递归方式对二叉排序树T查找key，查找时删除</td></tr></table>
<pre><code class="language-cpp">//若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素的结点
//并返回TRUE，否则返回FALSE
Status DeleteBST(BiTree *T,int key)
{
	if(!*T)    //不存在关键字等于key的数据元素
		return FALSE;
	else
	{
		if(key==(*T)-&gt;data)    //找到关键字等于key的数据元素
			return FALSE;
		else if(key&lt;(*T)-&gt;data)   
			return DeleteBST(&amp;(*T)-&gt;lchild,key);
		else
			return DeleteBST(&amp;(*T)-&gt;rchild,key);
	}
}

</code></pre>
<table><tr><td bgcolor=GreenYellow>Delete代码</td></tr></table>
<pre><code class="language-cpp">//从二叉排序树中删除结点p，并重接他的左或者右子树
Status Delete(BiTree *p)
{
	BiTree q,s;
	//下if和else if只适合只有左或者右子树的结点
	if((*p)-&gt;rchild==NULL)        //右子树空则只需重接它的左子树
	{
		q=*p;
		*p=(*p)-&gt;lchild;
		free(q);
	}
	else if((*p)-&gt;lchild==NULL)  //只需连接他的右子树
	{
		q=*p;
		*p=(*p)-&gt;rchild;
		free(q);
	}
	else  //左右子树均不为空
	{
		q=*p;
		s=(*p)-&gt;lchild;   
		while(s-&gt;rchild)        //转左，然后向右到尽头（找到待删除结点的前驱）
		{
			q=s;
			s=s-&gt;rchild;
		}
		(*p)-&gt;data=s-&gt;data;       //s指向被删除结点的直接前驱
		if(q!=*p)
			q-&gt;rchild=s-&gt;lchild;   //重接q的右子树
		else
			q-&gt;lchild=s-&gt;lchild;     //重接q的左子树
	}
	return TRUE;
}

</code></pre>
<p>上述代码的详细过程，如下：<br>
<img src="https://img-blog.csdnimg.cn/20200210220324278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210220344448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021022035938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200210220420698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     <span id="jump16">8.6.4二叉排序树总结</span><br>
1.优点：插入时小的数字插入到结点左子树，大的数字插入到结点的右子树，操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。<br>
2.对于二叉树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。<br>
3.极端情况就是，最少为1次，即根结点就是要找到的结点，最多不会超过树的深度<br>
4.如下图中，左边的图查找99要2次，右边的图查找99要10次。左图的时间复杂度就是o(logn)，右图的时间复杂度为o(n)<br>
<img src="https://img-blog.csdnimg.cn/20200210215629904.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>     <span id="jump17">8.7平衡二叉树（AVL树）</span></p>
<blockquote>
<p>AVL树相关概念：<br>
·1.定义：平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1，也就是高度差的绝对值&lt;=1<br>
2.平衡因子（BF）：将二叉树的左子树深度---右子树深度的值称为平衡因子<br>
3.平衡二叉树上所有结点的平衡因子只可能是-1,0，1。只要二叉树上有一个结点的平衡因子的绝对值&gt;1，则该树就是不平衡的，<br>
4.平衡二叉树首先是一个二叉排序树（即小的值在左子树，大的值在右子树上）。详见下图中的几个例子：</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/2020021122325486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡子树，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200211223952222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>     <span id="jump18">8.7.1 平衡二叉树实现原理</span></p>
<blockquote>
<p>平衡二叉树构建的基本思想：每当插入一个结点时，先检查是够因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。（详细见下图）<br>
<img src="https://img-blog.csdnimg.cn/20200211225134137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200211225154389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021122520626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200211225217518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>     <span id="jump19">8.7.2 平衡二叉树实现算法</span><br>
1.首先是需要改进二叉排序树的结点结构，增加一个bf值，用来存储平衡因子，参考代码如下：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义
typedef struct BiTNode        //结点结构
{
	int data;            //结点数据
	int bf;					//结点的平衡因子
	struct BiTNode *lchild, *rchild;   //左右孩子指针
}BiTNode,*BiTree;

</code></pre>
<p>对于右旋转，代码如下：</p>
<pre><code class="language-cpp">/*
	对以p为根的二叉排序树做右旋处理，处理之后p指向新的树根结点，即旋转处理之前的右子树的根结点
*/
void R_Rotate(BiTree *p)
{
	BiTree L;
	L=(*p)-&gt;lchild;       //L指向p的左子树的根结点
	(*p)-&gt;lchild=L-&gt;rchild;   //L的右子树挂接为p的左子树
	L-&gt;rchild=(*p);
	*p=L;          //p指向新的根结点
}
//详见如下图:

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200211230510573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
左旋代码操作如下：</p>
<pre><code class="language-cpp">//对以p为根的二叉排序树做左旋处理，处理之后p指向新的树根结点，即旋转处理之前的右子树根结点
void L_Rotate(BiTree *P)
{
	BiTree R;
	R=(*P)-&gt;rchild;     //R指向p的右子树根结点
	(*P)-&gt;rchild=R-&gt;lchild;       //R的左子树挂接为p的右子树
	R-&gt;lchild=(*P); 
	*P=R;                       //P指向新的根结点
}
//详见下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200212204441135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
左平衡旋转处理的函数代码：</p>
<pre><code class="language-cpp">#define LH +1     //左高
#define EH 0         //等高
#define RH -1     //右高
//对以指针T所指结点为根的二叉树做左平衡旋转处理，本算法结束时，指针T指向新的根结点
void LeftBalance(BiTree *T)
{
	BiTree L,Lr;
	L=(*T)-&gt;lchild;    //L指向T的左子树根结点
	switch(L-&gt;bf)
	{
		//检查T的左子树的平衡度，并做相应的平衡处理
		case LH:          //新结点插入在T的左孩子的左子树上，要做单右旋转处理
			(*T)-&gt;bf=L-&gt;bf=EH;
			R_Rotate(T);
			break;
		case RH:          //新结点插入在T的左孩子的左子树上，要做单右旋处理
			Lr=L-&gt;rchild;    //Lr指向T的左孩子的右子树根
			switch(Lr-&gt;bf)        //修改T及其左孩子的平衡因子
			{
				case LH:   
					(*T)-&gt;bf=RH;
					L-&gt;bf=EH;
					break;
				case EH:
					(*T)-&gt;bf=L-&gt;bf=EH;
					break;
				case RH:
					(*T)-&gt;bf=EH;
					break;
			}
			Lr-&gt;bf=EH;
			L_Rotate(&amp;(*T)-&gt;lchild);       //对T的左子树做左旋平衡处理
			R_Rotate(T);          //对T做右旋平衡处理
	}
}   //详见代码如下图所示：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020021220570528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
对于先右旋后左旋的代码类似上面，过程如下图：<br>
<img src="https://img-blog.csdnimg.cn/2020021220590779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
主函数：</p>
<pre><code class="language-cpp">//若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个
//数据元素为e的新结点并返回1，否则返回0。若因插入而使二叉排序树失去平衡，则做平衡旋转处理，布尔变量taller反映T长高与否
Status InsertAVL(BiTree *T, int e, Status *taller)
{
	if(!*T)           //不存在与e有相同关键字的结点
	{
		*T=(BiTree)malloc(sizeof(BiTNode));   
		(*T)-&gt;data=e;
		(*T)-&gt;lchild=(*T)-&gt;rchild=NULL;
		(*T)-&gt;bf=EH;
		*taller=TRUE;
	}
	else
	{
		if(e==(*T)-&gt;data)
		{
			//树中已存在和e有相同关键字的结点则不再插入
			*taller=FALSE;
			return FALSE;
		}
		if(e&lt;(*T)-&gt;data)
		{
			//应继续在T的左子树中进行搜索
			if(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))    //未插入
				return FALSE;
			if(*taller)          //已插入到T的左子树中且左子树长高
			{
				switch((*T)-&gt;bf)   //检查T的平衡度
				{
					case LH:    //原本左子树比右子树高，需要做左平衡处理
						LeftBalance(T);
						*taller=FALSE;
						break;
					case EH:     //原本左右子树等高，现因左子树增高而树增高
						(*T)-&gt;bf=LH;
						*taller=TRUE;
						break;
					case RH:      //原本右子树比左子树高，现左右子树等高
						(*T)-&gt;bf=EH;
						*taller=FALSE;
						break;
				}
			}
		}
		else
		{     //应继续在T的右子树中进行搜索
			if(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller))   //未插入
				return FALSE;
			if(*taller)    //已插入到T的右子树且右子树“长高”
			{
				switch(((*T)-&gt;bf)   //检查T的平衡度
				{
					case LH:    //原本左子树比右子树高，现左右子树的等高
						(*T)-&gt;bf=EH;
						*taller=FALSE;
						break;
					case EH:        //原本左右子树等高，现因右子树增高而树增高
						(*T)-&gt;bf=RH;
						*taller=TRUE;
						break;
					case RH:     //原本右子树比左子树高，需要做右平衡处理
						RightBalance(T);
						*taller=FALSE;
						break;
				}

			}
			 
		}
	}
	return TRUE;
}//具体过程如下图：

</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/2020021221205438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>构建一个数组为a[10]={3,2,1,4,5,6,7,10,9,8}  代码如下：</p>
</blockquote>
<pre><code class="language-cpp">int i;
int a[10]={3,2,1,4,5,6,7,10,9,8};
BiTree T=NULL;
Status taller;
for(i=0; i&lt;10; i++)
	InsertAVL(&amp;T,a[i],&amp;taller);

</code></pre>
<table><tr><td bgcolor=GreenYellow>如果二叉排序树是平衡二叉排序树，查找+插入+删除 时间复杂度为o(logn)</td></tr></table>
<p><span id="jump20">8.8多路查找树</span></p>
<blockquote>
<p>1.多路查找树出现的原因：我们之前谈的树，都是一个结点可以有很多孩子，但是它自身只存储一个元素。二叉树限制更多，结点最多只能有两个孩子。一个结点只能存储一个元素，在元素非常多的时候，就使得要么树的度（结点拥有子树的个数最大值）非常大，要么树的度非常高，甚至两者都必须足够大才行。这就使得内存存取次数非常多，这显然成立时间效率上的瓶颈，这迫使我们要打破每一个结点只存储一个元素的限制</p>
</blockquote>
<p>2.多路查找树的定义：<br>
<img src="https://img-blog.csdnimg.cn/20200214212049283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.2-3树定义，插入，查找：<br>
<img src="https://img-blog.csdnimg.cn/20200214212354645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212427427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002142124465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212507804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212521593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212543599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212601599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4 2-3-4树<br>
<img src="https://img-blog.csdnimg.cn/20200214212808329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214212740345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.B树的定义+属性+最坏的查找次数：<br>
<img src="https://img-blog.csdnimg.cn/20200214213101512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214213126322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.B+树的引用+定义+m阶B+树和B树的差异+B+树的优点：<br>
<img src="https://img-blog.csdnimg.cn/20200214213652902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
、<img src="https://img-blog.csdnimg.cn/20200214213701920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump21">8.9散列表查找（哈希表）概述</span><br>
1.散列表查找定义+查找步骤+散列技术适用于什么+散列表缺点+冲突：<br>
<img src="https://img-blog.csdnimg.cn/20200214215354439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214215411824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214215437361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump">8.10散列函数的构造方法</span><br>
1.构造散列函数的原则：<br>
<img src="https://img-blog.csdnimg.cn/20200214221453690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214221513780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.直接定址法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221543178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.数字分析法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221601823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.平方取中法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221622361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.折叠法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221639252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.除留余数法：<br>
<img src="https://img-blog.csdnimg.cn/20200214221656696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214221716657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.随机数法：<br>
<img src="https://img-blog.csdnimg.cn/2020021422173735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
8.采用不同散列函数考虑的因素：<br>
<img src="https://img-blog.csdnimg.cn/20200214221754125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump23">8.11处理散列冲突的方法</span><br>
1.开放地址法+二次探测法+随机探测法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225545630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225603825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200214225631821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>2.再散列函数法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225831308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.链地址法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225846786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225902904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.公共溢出区法：<br>
<img src="https://img-blog.csdnimg.cn/20200214225920224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200214225934127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
除留<br>
<span id="jump24">8.12 散列表查找实现</span><br>
     <span id="jump25">8.12.1 散列表查找算法实现</span><br>
                1.散列表结构和一些相关常数。其中HashTable是散列表结构，结构中的elem为一个动态数组</p>
<pre><code class="language-cpp">#define SUCCESS 1
#define UNSUCCESS 0
#define HASHSIZE 12       //定义散列表长为数组长度
#define NULLKEY -32768
typedef struct 
{
	int *elem;           //数据元素存储基址，动态分配数组，就是数组的初始地址
	int count;			//当前数据元素的个数
}HashTable;
int m=0;              //散列表表长，全局变量

</code></pre>
<p>对散列表进行初始化</p>
<pre><code class="language-cpp">Status InitHashTable(HashTable *H)
{
	int i;
	m=HASHSIZE;
	H-&gt;count=m;
	H-&gt;elem=(int *)malloc(m*sizeof(int));
	for(i=0; i&lt;m; i++)
		H-&gt;elem[i]=NULLKEY;
	return OK;
}

</code></pre>
<p>散列函数：</p>
<pre><code class="language-cpp">int Hash(int key)
{
	return key%m;       //除留余数法
}

</code></pre>
<p>对散列表的插入操作</p>
<pre><code class="language-cpp">//插入关键字进散列表
void InsertHash(HashTable *H, int key)
{
	int addr=Hash(key);   //求散列地址
	while(H-&gt;elem[addr]!=NULLKEY)   //如果不为空，则冲突
		addr=(addr+1)%m;       //开放地址法的线性探测
	H-&gt;elem[addr]=key;             //直到有空位后插入关键字
}

</code></pre>
<p>对散列表的查找记录的操作</p>
<pre><code class="language-cpp">//散列表查找关键字
Status SearchHash(HashTable H, int key, int *addr)
{
	*addr=Hash(key);    //求关键字的散列地址
	while(H.elem[*addr]!=key)    //如果不为key，则继续循环查找
	{
		*addr=(*addr+1)%m;            //开放地址法线性探测
		if(H.elem[*addr]==NULLKEY || *addr=Hash(key))     //前面表示压根数组中就没有要查找的key，或者循环找了一圈，又回到起点
			return UNSUCCESS;                 
	}
	return SUCCESS;
}

</code></pre>
<p>     <span id="jump26">8.12.2 散列表查找性能分析</span><br>
            1.时间复杂度是O(1)<br>
            2.散列查找的平均查找长度取决于哪些因素？<br>
                  1.散列函数是否均匀：散列函数的好坏直接影响出现冲突的频繁程度<br>
                  2.处理冲突的方法：相同的关键字，相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生堆积，显然就没有二次探测法好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能<br>
                  3.散列表的装填因子：装填因子α=填入表中的记录个数/散列表长度。α标志着散列表的装满程度，当然α越大表示装满程度越高，也就是产生冲突的可能性越大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。不管记录个数n有多大，总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围，此时散列表的复杂度为O(1)，通常将散列表的空间设置得比查找集合大，虽然浪费空间，但效率提升。</p>
<p>​</p>
]]></content>
    </entry>
</feed>