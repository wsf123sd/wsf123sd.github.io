<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wsf123sd.github.io/</id>
    <title>Gridea</title>
    <updated>2020-03-16T12:23:42.436Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wsf123sd.github.io/"/>
    <link rel="self" href="https://wsf123sd.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://wsf123sd.github.io/images/avatar.png</logo>
    <icon>https://wsf123sd.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://wsf123sd.github.io/post/markdown-yu-fa/</id>
        <link href="https://wsf123sd.github.io/post/markdown-yu-fa/">
        </link>
        <updated>2020-03-01T15:28:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一级标题ctrl1">一级标题（Ctrl+1）</h1>
<p>快速生成目录（[toc]+回车）</p>
<p>[toc]</p>
<h2 id="二级标题ctrl2">二级标题（Ctrl+2）</h2>
<h3 id="三级标题ctrl3">三级标题（Ctrl+3）</h3>
<p><u>这是下划线（Ctrl+u）</u></p>
<p><s>这是删除线(alt+shift+5)</s></p>
<p><strong>字体加粗（ctrl+b）</strong></p>
<p><em>字体倾斜（Ctrl+i）</em></p>
<ul>
<li>牛奶（先输入-再输入空格就是无序列表）</li>
<li>面包</li>
<li>蛋糕
<ul>
<li>包子（再输入-和空格都是无序列表的嵌套）</li>
<li>鸡蛋</li>
</ul>
</li>
</ul>
<ol>
<li>你好（数字+.+空格）</li>
<li>我好</li>
<li>他也好
<ol>
<li>电脑（再输入数字+.+空格就是有序列表嵌套）</li>
<li>鼠标</li>
</ol>
</li>
</ol>
<blockquote>
<p>引用（&gt;+空格）</p>
</blockquote>
<p><a href="https://wsf123sad.github.io/">这是链接</a></p>
<p>直接粘贴复制</p>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200228122119497.png" alt="image-20200228122119497" loading="lazy"></figure>
<pre><code class="language-c++">//ctrl+shift+k(代码块)
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a,int b;
}
</code></pre>
<p>home family 沙墟（ctrl+d选中英文单词或者中文）</p>
<p>asdkjklj(ctrl+l按行选中)</p>
<p>快速搜索（ctrl+f）</p>
<p>替换（ctrl+h）</p>
<p>快速生成表格（ctrl+t）</p>
<table>
<thead>
<tr>
<th style="text-align:center">asd</th>
<th style="text-align:center">ds</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">sdfasd</td>
<td style="text-align:center">sdaf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>快速打开文件（ctrl+p）</p>
<p><code>关键字</code>爱神的箭（ctrl+shift+tab键上面的反引号）</p>
<p>表情符号：（在微软的输入法下，ctrl+shift+b）</p>
<p>😍❤</p>
<p>ctrl+n创建新文件，ctrl+w关闭文件</p>
<p>ctrl+shift+l显示和隐藏侧边栏</p>
<p>f11全屏</p>
<p>三个---+回车是分割线</p>
<hr>
<p><mark>高亮</mark> (俩个=+文字+俩个=)</p>
<p>爱是考虑到（ctrl+0段落标签）</p>
<p>脚注：</p>
<p>Jobs<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>先输入Jobs+[]+中括号内写^1,然后回车后有自动提示</p>
<p>文件导出：文件-&gt;导出（选择格式）</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>苹果公司的创始人 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第一，二章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-yi-er-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:27:07.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">1.开始介绍c++</a></p>
<p><a href="#jump2">2.各种云算符</a></p>
<p><a href="#jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</a></p>
<p><a href="#jump4">4.swith结构</a></p>
<p><a href="#jump5">5.打印水仙花的两种算法</a></p>
<p><span id="jump1">1.开始介绍c++</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       头文件   

using namespace std;        std名称空间



int main(int argc, char** argv)

{

  int a=5;

  char b='N';

  float c=3.14;

  double d=56.789;

  

  bool e;  //布尔值 

  

  e=true;

  cout &lt;&lt; e &lt;&lt; endl;

  e=false;

  cout &lt;&lt; e &lt;&lt; endl;

  

  /*

  cout &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt; '\n' &lt;&lt; endl;

  cout &lt;&lt; b &lt;&lt; endl;

  cout &lt;&lt; c &lt;&lt; endl;

  cout &lt;&lt; d &lt;&lt; endl; 

  */



  return 0;

} 

</code></pre>
<p><span id="jump2">2.各种运算符</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;       

#include&lt;iomanip&gt;   

using namespace std;        



int main(int argc, char** argv)

{

  //赋值运算符 从右至左

  int a=10;

  a=98; 

  //算术运算符

  //+ - * / % (双目运算符)  ++ -- (单目运算符) 

  //关系运算符

  //&gt; &lt; &lt;= &gt;= == != (双目运算符) 

  //逻辑运算符

  //&amp;&amp;(左右都为真，则为真) //(有一个为真，就为真) !

  //位运算符 

  //&lt;&lt;(将数字变为2进制，左移右补0) &gt;&gt; &amp; / ^ (将数字转变为2进制计算) 

  //&amp;:两个结果都为1，则值为1  

  // /:有一个为1，则为1

  // ^:两个相同则为0，不同为1 

  //三目运算符

  //?:

  //  1&gt;2? 5:6 

  //逗号运算符  2+3,9  这个表示一个式子，结果是最后一个值 

  //求字节运算符:sizeof()

  

  

  //逗号运算符：整个逗号表达式的值为系列中最后一个表达式的值。 





  int i,j;

  

  j=10;

  i=(j++,j+100,999+j);   //j自增1，完了j加上100变为111， 最后j再加上999， 结果为1010 

  

  cout &lt;&lt; i;

 

  return 0;

} 

</code></pre>
<p><span id="jump3">3.cout的输出（位数的控制的输出，数字输出的位置，数字输出的填充...）</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include &lt;iomanip&gt;      //使用setprecision的头文件 

using namespace std;



int main(int argc, char** argv)

{

  double a=356.1415926535897932;    //默认为保存6位 

  double b=25.2222365; 

  //cout &lt;&lt; setprecision(6) &lt;&lt; a &lt;&lt; endl;   //  setprecision(保存的位数) 设置整体的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl; // 只设置小数点后的位数 

  //cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right)&lt;&lt;setw(10)&lt;&lt;a&lt;&lt;endl;   //设置数字向右靠，一共设置10位 

  

  /* 在第14行设置好，下面a，b输出都按照要求输出，主要若将setw(10)写在第14行，只有a的是保留10位靠右输出 

​    cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right);

  cout &lt;&lt;setw(10) &lt;&lt; setfill('0') &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  */

  

  //使用字符&amp;来补充，setfill(要填充的内容) 

  cout &lt;&lt; setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;setiosflags(ios::right) &lt;&lt; setfill('&amp;') ;

  cout &lt;&lt;setw(10) &lt;&lt; a &lt;&lt; endl;

  cout &lt;&lt;setw(10) &lt;&lt; b &lt;&lt; endl;

  

  return 0;

}

</code></pre>
<p>‘A’65</p>
<p>‘Z’90</p>
<p>'0'48</p>
<p><span id="jump4">4.swith结构</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main(int argc, char** argv)

{

​    int a;

​    cin &gt;&gt; a;

​    switch(a)

​    {

​        case 1:

​        case 2:

​        case 3: cout &lt;&lt; &quot;spring&quot; &lt;&lt; endl;break;

​        case 4:

​        case 5:

​        case 6: cout &lt;&lt; &quot;summer&quot; &lt;&lt; endl;break;

​        case 7:

​        case 8:

​        case 9: cout &lt;&lt; &quot;autumn&quot; &lt;&lt; endl;break;

​        case 10:

​        case 11:

​        case 12: cout &lt;&lt; &quot;winter&quot; &lt;&lt; endl;break;

​        default:cout &lt;&lt; &quot;others&quot; &lt;&lt; endl;break;



​    }

​    return 0;

}

</code></pre>
<p><span id="jump5">5.打印水仙花数的两种算法</span></p>
<pre><code class="language-cpp">
#include&lt;iostream&gt;

#include&lt;iomanip&gt;

using namespace std;

int main()

{

​    /*

​    int i=100;

​    int a,b,c;

​     while(i&lt;1000)

​     {

​         a=i/100;

​         b=i%100/10;

​         c=i%10;

​         if(a*a*a+b*b*b+c*c*c==i)

​            cout &lt;&lt; i &lt;&lt; endl;

​         i++;

​     }

​     return 0;

​     */

/*

​    下面的三次循环效率比上面高，因为while循环内部运算次数远远大于下面，上面每次都要计算出a,b,c的值，而下没有一步是要算出确切的值

*/     

​     

​     int a=1,b=1,c=1;

​     for(a=1; a&lt;10; a++)

​     {

​         for(b=0; b&lt;10; b++)

​         {

​             for(c=0; c&lt;10; c++)

​             {

​                 if(a*a*a+b*b*b+c*c*c == a*100+b*10+c)

​                        cout &lt;&lt; a*100+b*10+c &lt;&lt; endl;

​             }

​         }

​     }

​     return 0;

}





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第三章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-san-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:26:37.000Z</updated>
        <content type="html"><![CDATA[<p>函数定义：返回abc中最大值</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;
int fun(int a, int b, int c);
/*
   函数定义：返回值类型 函数名 形参表
   函数定义顺序：函数声明-&gt;主函数-&gt;函数定义
   函数的思想：低耦合，高为聚（函数之间耦合度要低，高维聚表示函数的功能尽可能集中）
*/
int main()
{
    int a,b,c;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    cout &lt;&lt; fun(a,b,c);
    return 0;
}
int fun(int a, int b, int c)
{
   return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;
}

</code></pre>
<p>函数重载</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
//函数重载:一物多用

/*
    1.保证函数名形同，形参的个数或类型不同,函数的类型也可以不同
    2.对于调用时，若两个数就使用第2个判断，若3个数就使用第一个判断
*/

int fun(int a,int b,int c);
int fun(int a, int b);
double fun(double a, double b, double c);
int main()
{
    cout &lt;&lt; fun(5.0,1.0,11.11) &lt;&lt; endl;
    return 0;
}

int fun(int a,int b)
{
    return a&gt;b?a:b;
}

int fun(int a, int b, int c)
{
    if(b&gt;a)
        a=b;
    if(c&gt;a)
        a=c;
    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;
    return a;
}

double fun(double a,double b, double c)
{
    if(b&gt;a)
        a=b;
    if(c&gt;a)
        a=c;
    cout &lt;&lt; &quot;double&quot; &lt;&lt; endl;
    return a;
}

</code></pre>
<p>带默认参数函数和一个函数不能即是带默认参数函数又是函数重载：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    带默认参数的函数使用
    1.在函数声明的过程中，就放上参数，而在函数定义和函数调用过程的过程中不要放参数
    这样最后的结果就是参数的函数值
    2.如果函数调用中，传部分值也可以
    3.给函数申明赋初值时，优先从右至左
    4.函数调用时将实参赋值给形参的顺序是从左至右
    5.有实参用实参没实参用形参
    6.特别注意一个函数不能即做函数重载又做带默认值函数
*/
int fun(int a=1, int b=1, int c=2);
int fun(int a,int b);  //6.函数调用时是用上面还是用下面？
int main()
{
    cout &lt;&lt; fun(5,2) &lt;&lt; endl;
    return 0;
}

int fun(int a, int b, int c)
{
    if(b&gt;a)
        a=b;
    if(c&gt;a)
        a=c;
    cout &lt;&lt; &quot;int&quot; &lt;&lt; endl;
    return a;
}


</code></pre>
<p>变量的使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;
int a=15;     //全局变量,函数外部，作用范围： 全局变量的生命周期是整个程序
/*

*/
int fun()
{
    int a;
    a=20;
}
int main()
{
    auto int b;   //auto动态存储类别，不写也可以就是平时用的
    static int a;  //静态类型，只初始化一次
    int a;      //局部变量，就在它自身的函数内可用,如果全局变量和局部变量重名时，以函数内的局部变量为准
    a=10;          //当函数运行完，局部变量生命周期就结束
    cout &lt;&lt; a &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>register和static</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;

int fun()
{
   static int a=10;  //只初始化一次，第2次调用此函数值为12不是11
   register int a=10;   //把变量设置为register可以高效的读取该变量,建议性的动作，每次调用函数后都会重新设置a=10，即两次调用的结果都为11
   extern 
   for(a=10; a&lt;1000; a++)
   {
       
   }
    a++;
    cout &lt;&lt; a &lt;&lt; endl;
    return 0;
}


int main()
{
    fun();
    fun();
    return 0;
}

</code></pre>
<p>关键字extern：扩大作用域的范围</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第四章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-si-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:25:40.000Z</updated>
        <content type="html"><![CDATA[<p>1.二维数组</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;iomanip&gt;
using namespace std;


int main()
{
    int b[3][4]={1,2,3,4,5};  //二维数组用双层for循环
    
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;4; j++)
            cout &lt;&lt; b[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p>2.字符串的strlen（长度），strcmp（比较），strcpy（复制），strcat（拼接）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;  //一定是cstring不是string
#include&lt;iomanip&gt;
using namespace std;

int main ()
{
    //strcmp
    //strlen
    //strcpy
    //strcat
    char a[100]=&quot;hello&quot;;
    char b[100]=&quot;helleajsdkl&quot;;
    /*
        字符串比较，如果相同返回0‘如果第一个大，返回1,；如果第2个大，返回负值。
        从左到右比较时第一个不同比较完就完
    */
    cout &lt;&lt; strcmp(a,b) &lt;&lt; endl;
    cout &lt;&lt; strlen(a) &lt;&lt; endl;  //字符串实际长度

    /*
        要想重新给字符数组赋值，只能一个一个赋，别无他法，如下代码
    */
    a[0]='w';
    a[1]='o';
    a[2]='r';
    a[3]='l';
    a[4]='d';

    /*
        或者也可以这样,如下代码
    */
    strcpy(a,&quot;fuck you&quot;);
    cout &lt;&lt; a &lt;&lt; endl;

    //字符串连接
    strcat(a,b);
    cout &lt;&lt; a;
   
    return 0;
}

</code></pre>
<p>3.string类的字符串翻转</p>
<pre><code class="language-cpp">#include &lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int main()
{
    string str = &quot;song&quot;;
    reverse(str.begin(), str.end());
    cout &lt;&lt; str;
    return 0;
}

</code></pre>
<p>字符串使用：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a=&quot;fuck you&quot;,b;  //string是一个类，不用考虑开辟多少存储空间
    a=&quot;asdfkasdkl&quot;;   //string的赋值使用
    b=&quot;world&quot;;
    /*
        字符串的比较
    
    if(a==b)
        cout &lt;&lt; &quot;==&quot;;
    else
        cout &lt;&lt; &quot;!=&quot;;*/
        
    /*拼接字符a与b
    a=a+b;   
    cout &lt;&lt; a;
    */
    return 0;
}

//****************string的小用法********************
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string user;
    string passwd;

    cin &gt;&gt; user;  //string使用空格和回车结束
    cin &gt;&gt; passwd;

    if(user==&quot;admin&quot; &amp;&amp; passwd==&quot;dotcpp&quot;)
    {
        cout &lt;&lt; &quot;yes&quot;;
    }
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}


</code></pre>
<p>指针的使用：<br>
1.指针基本使用<br>
2.数组的指针的使用<br>
3.指针作为函数参数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int swap(int *a, int *b)
{
    /*当函数结束，不会交换值
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;*/
    
    int temp;
    temp=*a;
    *a=*b;
    *b=temp;
    return 0;

}
int main()
{
    /*指针基本使用
    int a;
    int *p;
    p=&amp;a;   //&amp;取地址运算符,p存放a的地址或p指向a
    *p=99;   //相当于对a进行赋值
    cout &lt;&lt; *p &lt;&lt; endl;*/

    /*数组的指针的使用
    int a[10]={1,2,3,4,5,6,7,8,9,0};
    int *p;
    p=&amp;a[0];
    for(int i=0; i&lt;10; i++)
        cout &lt;&lt; *(p+i) &lt;&lt; endl;  //*(p+i) == a[i] */

    int a=10,b=20;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    swap(&amp;a,&amp;b);
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;

    return 0;
}

</code></pre>
<p>输出字符数组的三种写法+二维数组的指针使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int main()
{
    /*输出字符数组的三种写法
    char str[100]=&quot;www.dotcpp.com&quot;;
    char *p;
    p=str; //相当于p=&amp;str[0];
    for(int i=0; i&lt;strlen(str); i++)
    {
        //cout &lt;&lt; *(p+i) &lt;&lt; endl; 第一种写法

        第二种写法
        cout &lt;&lt; *p &lt;&lt; endl;
        p++;

        cout &lt;&lt; p[i] &lt;&lt; endl;    //基址+偏移  第三种写法
    }*/

    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同
    p=str;         //相当于将str[0]行赋给p

    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(str[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);  //p+i就是向下走行，后面+j表示走列
        cout &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p>二维数组指针作为函数参数的使用</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int fun(char (*p)[100])
{
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;strlen(p[i]); j++)
            cout &lt;&lt; *(*(p+i)+j);
        cout &lt;&lt; endl;
    }
    return 0;
}
int main()
{
    int i;
    char str[5][100]={&quot;www.dotcpp.com&quot;,&quot;Nice to meet you&quot;,&quot;How old you&quot;};
    char (*p)[100];         //数组指针，指向一行数组， 列要相同

    fun(str);
    return 0;
}

</code></pre>
<p>引用+引用作为参数进行数字交换</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int fun(int &amp;a, int &amp;b)     //使用引用来传递参数
{
    int temp;
    temp=a;
    a=b;
    b=temp;
    return 0;
}
int main()
{
    /*
    int a;
    int &amp;b=a;  //引用用法，a与b共用一个存储单元，必须初始化
    a=10;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
    a=99;
    cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;*/
    int a=20;
    int b=30;
    fun(a,b);         //直接调用时输出a,b
    cout &lt;&lt; a &lt;&lt; b;
    return 0;
}




</code></pre>
<p>new和delete分配和释放空间</p>
<pre><code class="language-cpp">1.普通变量的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    //栈空间
    //int a;
    //char b[100];

    //堆空间
    int *p;
    //p=new int;  //申请一个四个字节空间来存整数，并返回四个字节空间首地址
    p=new int(50);  //申请空间时，直接赋值
    //*p=90;
    cout &lt;&lt; *p &lt;&lt; endl;

    delete p;     //一定要释放空间，释放掉指针，new和delete成双成对出现

    return 0;
}

2.数组的使用
#include&lt;iostream&gt;
using namespace std;
int main()
{
    int *p2;
    //p2=new int[100](); //给数组初始化为0
    
    p2=new int[100]{8,7,3,4,5};  //给数组赋不同的值
    
    cout &lt;&lt; p2[0] &lt;&lt; &quot; &quot; &lt;&lt; p2[1];
    
    delete []p2;  //释放定义数组的空间，注意【】不能少
    
    return 0;
}


3.结构的使用
#include&lt;iostream&gt;
using namespace std;
struct stu
{
    string name;
    int num;
    char sex;
};
int main()
{
    stu *p3;
    p3=new stu;
    //p3=new stu{&quot;zhangsan&quot;,1001,'W'}; 不推荐这样赋值，需要c11标准

    p3-&gt;name=&quot;zhangsan&quot;;
    p3-&gt;num=1001;
    p3-&gt;sex='w';

    cout &lt;&lt; p3-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p3-&gt;sex;

    delete p3;
    return 0;
}

</code></pre>
<p>结构使用：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{
    //struct student A;   //struct student是一个类型，相当于int
    
    student A={1001,&quot;zhangxiaosan&quot;,'W'};     //C++允许这样定义,赋值的时候要和定义时的相同

    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex &lt;&lt; endl;

    /*赋值的一种方式*/
    A.name=&quot;wangxiaoer&quot;;
    A.num=1001;
    A.sex='M';
    
    cout &lt;&lt; A.name &lt;&lt; &quot; &quot; &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.sex;
    return 0;
}

2.结构指针的使用
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A={1001,&quot;zhangxiaosan&quot;,'W'};
    student *p;
    p=&amp;A;
    
    //以下是指针的两种使用方式
    cout &lt;&lt; (*p).num &lt;&lt; &quot; &quot; &lt;&lt; (*p).name &lt;&lt; &quot; &quot; &lt;&lt; (*p).sex &lt;&lt; endl;
    cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex;
    return 0;
}

3.结构数组的使用
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;    //占位宽setw函数
using namespace std;
//结构体
struct student
{
    int num;
    string name;
    char sex;
};

int main()
{

    student A[100]={{1000,&quot;zhangxiaosan&quot;,'W'},{1001,&quot;zhangsan&quot;,'M'},{1002,&quot;lisi&quot;,'W'},{1003,&quot;wangwu&quot;,'W'},{1004,&quot;xiapliu&quot;,'W'}};
    student *p;
    p=A;
    for(int i=0; i&lt;5; i++)
    {
        //cout &lt;&lt; A[i].num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; A[i].name &lt;&lt; &quot; &quot; &lt;&lt; A[i].sex &lt;&lt; endl;
        
        /*使用指针来输出
         cout &lt;&lt; p-&gt;num &lt;&lt; &quot; &quot; &lt;&lt; setw(15) &lt;&lt; p-&gt;name &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;sex &lt;&lt; endl;
         p++;   //p每次走一个结构体  */
    }
    return 0;
}


</code></pre>
<p>4.共用体</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
//共用体:num和s共用一个4个字节内存
union stu
{
    int num;
    char s;
};
int main()
{
    stu A;
    A.num=10;
    cout &lt;&lt; A.num &lt;&lt; endl;   //00000000 00000000 00000000 00001010
    A.s='B';             //66 00000000 00000000 00000000 01000010
    cout &lt;&lt; A.s &lt;&lt; endl;
    cout &lt;&lt; A.num &lt;&lt; &quot; &quot; &lt;&lt; A.s;  //最后输出的时候01000010会替换00001010，则前面的sum该为66，后面输出字符
    return 0;
}


</code></pre>
<p>5.枚举类型</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

//枚举类型:默认从0开始，但也可以赋值
enum week
{
    Sun=30,Mon,Tue,Wed,Thu,Fri,Sat
} ;

int main()
{
    week W;
    W=Tue;
    W=Sat;
    cout &lt;&lt; W;
    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c语言网第五章笔记]]></title>
        <id>https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/</id>
        <link href="https://wsf123sd.github.io/post/c-yu-yan-wang-di-wu-zhang-bi-ji/">
        </link>
        <updated>2020-03-01T15:24:37.000Z</updated>
        <content type="html"><![CDATA[<p>1.sort和reverse函数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//STL(标准模板库):容器（链表，堆，栈....），迭代器（类似于指针），算法
//sort
//reverse
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    
    //sort排序中要放两个指针，第一个是起始地址，第二个是结束地址，但是要给数组最后一个元素的下一个地址,sort默认为升序排列
    sort(&amp;a[0],&amp;a[5]);     
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;

    //reverse用法：sort+reverse可以降序排列
    reverse(&amp;a[0],&amp;a[5]);
    for(int i=0; i&lt;=4; i++)
        cout &lt;&lt; a[i] &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>2.accumulate函数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;numeric&gt;

using namespace std;
//accumulate

int main()
{
    int a[5]={1,3,5,4,2};
    /*
        1.accumulate里面有三个值：第一个还是数组的第一个地址，第二个是最后一个元素的下一个地址，第三个如果累加和就写0
        2.accumulate是以参数的形式返回
        3.要加头文件numeric
    */
    int i=accumulate(&amp;a[0],&amp;a[4],0);

    cout &lt;&lt; i;
    return 0;
}

</code></pre>
<p>3.find函数</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;

using namespace std;
//find

int main()
{
    int *i;
    int a[5]={1,3,5,4,2};
    /*
        1.find中有三个值：第一个数组的地址，第二个是数组中最后一个元素的下一个地址，第三个是要查找的数字
        2.如果数组中有要找的数字，则返回该数字的地址；如果没有则返回数组中最后一个元素的下一个地址
        3.头文件algorithm
    */
    i=find(&amp;a[0],&amp;a[5],1);
    if(i==&amp;a[5])
        cout &lt;&lt; &quot;can't find!&quot;;
    else
        cout &lt;&lt; &quot;success!&quot;;
    return 0;
}

</code></pre>
<p>4.vector用法+push_back()输入+迭代器输出</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v; //自动调整数组的大小
    vector&lt;int&gt;::iterator it;      //迭代器，指向vector的int类型的指针
    for(int i=0; i&lt;5; i++)
    {
        cin &gt;&gt; a;
        v.push_back(a);      //用v.push_back()对vector进行输入
    }
    
    sort(v.begin(),v.end());     //使用vector和sort结合使用其中v.end()表示最后一个元素的下一个地址
    
    //使用迭代器的方式进行数组访问
    for(it=v.begin(); it!=v.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; endl;
    }

    
    return 0;
}

</code></pre>
<p>5.vector中v.front()返回首元素和v.back()返回尾元素</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    /*
        1.v.front()返回首元素
        2.v.back()返回尾元素
    */
    cout &lt;&lt; v.front() &lt;&lt; endl;
    cout &lt;&lt; v.back() &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>6.vector中v.empty()函数（判断vector是否为空）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;

    if(v.empty()==true)
        cout &lt;&lt; &quot;yes&quot;;
    else
        cout &lt;&lt; &quot;no&quot;;
    return 0;
}

</code></pre>
<p>7.v.size()+删除某个元素v.erase()+清空整个vector：v.clear()+删除最后一个元素v.pop_back()<br>
注意事项：<br>
1.v.erase()删除某个指定元素后再读取此位置的数字则是下一个位置的数字;<br>
如果要删除其他位置元素：<br>
1.使用迭代器    vector<int>::iterator it<br>
2.it=v.begin()+1; 表示删除v[1]这个元素<br>
3.it=v.begin()+2; 表示删除v[2]这个元素<br>
2.v.pop_back()删除最后一个元素，但是读取的话仍能读取，但是vector的长度会变小</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int a;
    vector&lt;int&gt; v;
    vector&lt;int&gt;::iterator it;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);

    cout &lt;&lt; v.size(); //判断vector的大小

    it=v.begin();
    v.erase(it);    //删除指定的元素
    cout &lt;&lt; *v.begin();

    v.pop_back();    //删除最后一个元素

    v.clear();    //清空vector数组
    cout &lt;&lt; v.size();
    return 0;
}

</code></pre>
<p>1033<br>
解题思路：<br>
1.字符串bad，should<br>
2.以should为主循环遍历，如果bad字符串中含有should中的字符就跳过；如果should中的字符是大写，并且有上档键则跳过<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    string bad,should;
    getline(cin,bad);
    getline(cin,should);
    for(int i=0; i&lt;should.length(); i++)
    {
        if(bad.find(toupper(should[i]))!=string::npos)
            continue;
        if(isupper(should[i])&amp;&amp;bad.find('+')!=string::npos)
            continue;
        cout &lt;&lt; should[i];
    }
    return 0;
}


</code></pre>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string a,b;
bool isTrue(char c)
{
    for(int i=0; i&lt;a.length(); i++)
    {
        /*如果a中有上档键且字符是大写则不输出*/
        if(a[i]=='+')
            if('A'&lt;=c &amp;&amp; c&lt;='Z')
                return false;
        /*a[i]==c包含两种情况，一种数数字字符+一种是大写字符*/
        if(a[i]==c || (a[i]-'A'==c-'a'))
            return false;
    }
    return true;
}
int main()
{
    cin &gt;&gt; a &gt;&gt; b;
    for(int i=0; i&lt;b.length(); i++)
    {
        if(isTrue(b[i]))
            cout &lt;&lt; b[i];
    }
    return 0;
}


/*
    解题思路：
    1.设置一个函数里面包含上档键坏掉，返回false和坏掉的键返回false
*/

</code></pre>
<p>注意事项：<br>
1.在输入字符串时可能会有空格，所以用getline<br>
2.如果改掉字符串的输入方式，我的代码只能得到17分，剩下的3分看不出来</p>
<p>知识总结：<br>
1.getline()与cin的区别：<br>
cin在输入字符串时，遇到空格、制表符或换行符就结束<br>
getline()可以输入时敲入空格，回车，制表符<br>
2.isupper(k)含义：<br>
判断字符k是否为大写字母，是返回1，否则返回0<br>
3.string中find含义：<br>
bad.find('+')表示在字符串bad中找是否含有+这个字符，有，返会+所在的字符串下标，否则，返回npos</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pat乙级]]></title>
        <id>https://wsf123sd.github.io/post/pat-yi-ji/</id>
        <link href="https://wsf123sd.github.io/post/pat-yi-ji/">
        </link>
        <updated>2020-03-01T15:20:42.000Z</updated>
        <content type="html"><![CDATA[<p>1001解题思路：<br>
1.用while+if-else来控制循环次数（砍得的次数）和判断奇数偶数</p>
<p>我的代码如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; 
using namespace std;

int main()
{
	int n,step=0;
	cin &gt;&gt; n;
	while(n!=1)
	{ 
		if(n%2==0)
			n/=2;
		else
			n=(3*n+1)/2;
		step++;
	} 
	cout &lt;&lt; step;
	return 0;
}
</code></pre>
<p>别人的代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int main() {
 int n, count = 0;
 cin &gt;&gt; n;
 while (n != 1)
  {
	 if (n % 2 != 0)      //这个循环就是判断奇数的，n为奇数*3+1完了，在下一句除2 这样就省掉了加括号的麻烦 抓住了不管奇数还是偶数                         
//都有除2的特点 如果n为偶数不执行此语句，直接再下面除2
		 n = 3 * n + 1;   
	 n = n / 2;
	 count++;
 }
 cout &lt;&lt; count;
 return 0; }
</code></pre>
<p>1002解题思路：<br>
1.用string类来存储数据，不然的话double，long long类型的长度不够</p>
<ol start="2">
<li>用for循环来计算各位数字之和</li>
<li>用string类定义一个数组，其中成员是数字的拼音</li>
<li>将数字和变量改为字符串类型，方便调用每个位数字，不用对数字除或求余</li>
<li>通过循环从数字和的字符串中对应找到string类的数字拼音</li>
</ol>
<p>my code:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
	string s;
	cin &gt;&gt; s;
	int i,sum=0;
	for(i=0; i&lt;s.length(); i++)     //s.length()计算字符串长度 
	{
		sum+=s[i]-'0';
	}
	string name[10]={&quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot;};  //字符串用双引号括起来，字符用单引号括起来 
	
	string a = to_string(sum);
	
	for(i=0; i&lt;a.length(); i++)
	{
		cout &lt;&lt; name[a[i]-'0'];   //将数字转变为字符去存储方便调用每个位置上的数字，不用再除或求余啥的 
		if (i != a.length()-1)
			cout &lt;&lt; ' ';
	}
	

	return 0;
}
</code></pre>
<p>other's</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() 
{
	 string s;
	 cin &gt;&gt; s;
	 int sum = 0;
	 string str[10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;,&quot;ba&quot;, &quot;jiu&quot;};   //
	 for (int i = 0; i &lt; s.length(); i++)
	 	sum += (s[i] - '0');
	 	
	 string num = to_string(sum);
	 
	 for (int i = 0; i &lt; num.length(); i++)
	 {
		 if (i != 0)        //题目要求最后一个拼音不能有空格，所以是先输出拼音，后输出空格，提前加一个if判断，当输入完最后一个拼音，循环都已经结束了
		 	cout &lt;&lt; &quot; &quot;;
		 cout &lt;&lt; str[num[i] - '0'];
	 }
	 
	 return 0; 
 }
</code></pre>
<p>1003解题思路：<br>
1.本题难点在于找规律，首先明确一点不是AAA...AAPAA...AATAA...AA这么简单的规律。<br>
2.突破点在于aPbTc正确和aPbATca正确，显然第二个在P与A之间多加了一个A，后面多了一个a，而a又是第一个的P之前的部分，其实这里a,b,c均是狗（宇哥替换）。观察例子：AAPATAA与AAPAATAAAA，这里a相当于AA，b相当于A，c相当于AA。在第二个中P,T之间多加了A，则后面多加AA。所以规律是在P,T之间多加一个A，则原来字符串T后面多 补充 原来字符串P之前的部分。比如对于AAPAATAAAA而言，AAPAAATAAAAAA也是对的，AAPAAATAAAAAAAA也是对的。<br>
3.如果P之前没有A，则无论在P,T之间加多少的A，T之后也不会有A,所以形如PAAA...AAAT都对<br>
4.xPATx这种形式告诉我们，AAA...AAAPATAAA...AAA是可以的，只要PAT前和后的AAA对称。二一个当x为空格是PAT也是正确。<br>
5.通过例子可知有且仅有P,A,T三种字符，其中P,T的个数只能为1，而A的个数不能0，P,T之间至少一个A，对于APAAATAA我们可知可以由APAATA得来，但是例子表示APAAATAA是错误，所以APAATA也是错误<br>
6.总之，就是P之前A的个数*P与T之间A的个数等于T之后A的个数 （这规律我估计也不是他想出来的，或者就是偶然想到的）</p>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
using namespace std;

int main()
{
	int n,i,j,p,t;
	cin &gt;&gt; n;
	string s;
	for(i=0; i&lt;n; i++)
	{
		cin &gt;&gt; s;
		map&lt;char, int &gt; m;
		for(j=0; j&lt;s.length(); j++)
		{
			m[s[j]]++;
			if(s[j]=='P')
				p=j;
			if(s[j]=='T')
				t=j;
		}
		if(m['P']==1 &amp;&amp; m['A']!=0 &amp;&amp; m['T']==1 &amp;&amp; m.size()==3 &amp;&amp; t-p!=1 &amp;&amp; p*(t-p-1)==s.length()-t-1)
			cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
		else
			cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
<p>1004解题思路：<br>
1.首先根本不用存储每次输入的学生的信息，重点是要知道成绩最值的学生的姓名和学号，所以用变量来存储这些信息。“铁打的营盘流水的兵”恰如其分描述铁打的营盘类似成绩最值的姓名和学号，而流水类似不断敲入的学生成绩，姓名和学号</p>
<p>1005解题思路：<br>
1.设置一个数组arr[]其中表示对输入数字进行c式处理后对应下标为1<br>
比如：输入5 ，第一次c式处理后为8，则将arr[8]的值为1<br>
先判断arr值是否为1，是则退出循环，输入下一个值判断，不是另其值为1<br>
2.注意arr数组的空间大小为10000否则只是部分正确<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int arr[10000];
bool cmp(int a, int b)
{
    return a&gt;b;
}

int main()
{
    int k,n,flag=0;
    cin &gt;&gt; k;
    vector&lt;int&gt; v(k);//定义一个数组
    //for中嵌套while，外面一共循环k次，里面就是对数字处理并且标记对应arr数组中的值为1
    //如果在while中判断数字有1则直接输入下一个数
    for(int i=0; i&lt;k; i++)
    {
        cin &gt;&gt; n;
        v[i]=n;   //数组存放对应的数字
        while(n!=1)
        {
            if(n%2!=0)
                n=3*n+1;
            n/=2;
            /*?*/
            if(arr[n]==1)
                break;
            arr[n]=1;
        }
    }
    sort(v.begin(), v.end(), cmp); //将数组按照从大到小的顺序排列
    for(int i=0; i&lt; v.size(); i++)
    {
        if(arr[v[i]]==0) //表示
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; v[i];
            flag=1;

        }
    }
    return 0;
}

</code></pre>
<p>1006<br>
解题思路：就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    思路就是取百位然后循环输出B，求出十位循环输出S，求出个位循环输出1--n
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i=1; i&lt;=n/100; i++)
        cout &lt;&lt; 'B';
    for(int j=1; j&lt;=n%100/10; j++)
            cout &lt;&lt; 'S';
    for(int k=1; k&lt;=n%10; k++)
            cout &lt;&lt; k;
    return 0;
}

</code></pre>
<p>1007<br>
解题思路：ans表示有多少对数字<br>
遍历从0--n相邻且相差2的数字，然后判断是否为素数</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
  解题思路：ans表示有多少对数字
        遍历从0--n相邻且相差2的数字，然后判断是否为素数
*/
int f(int n)
{
    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
            return 0;
    return 1;
}
int main()
{
    int n,ans=0;
    cin &gt;&gt; n;
    for(int i=2; i&lt;=n-2; i++)
    {
        if(f(i) &amp;&amp; f(i+2))
            ans++;
    }
    cout &lt;&lt; ans;
    return 0;
}

</code></pre>
<ol start="1008">
<li></li>
</ol>
<p>解题思路：<br>
先把数组倒叙，再把前m为倒叙，再把后面的倒叙即可。（客观规律，记住即可）<br>
之前的思路是向后移数组，在把超出部分放到前面，但这样部分正确。我分析是：使用太多的数组，因为题目要求程序移动的次数竟可能少</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;  //reverse()使用此头件
#include&lt;vector&gt;  //vector使用此头文件
using namespace std;
int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;int &gt; a(n);
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    m%=n;
    if(m!=0)
    {
        reverse(a.begin(),a.end());  //a.begin()是指针，指向数组第一个元素；a.end()也是指针，指向a[6]
        reverse(a.begin(),begin(a)+m);  //reverse中不会将第2部分的值也倒转，而是把他之前的值倒转
        reverse(begin(a)+m,a.end());  //从上一位置开始
    }
    for(int i=0; i&lt;n-1; i++)
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; a[n-1];
    return 0;
}

</code></pre>
<p>1009<br>
解题思路：<br>
利用栈先进后出的思想来倒叙输出字符串<br>
首先，将字符串压入栈，访问栈顶元素，弹出当前栈顶元素。<br>
由于题目要求，字符串之间有空格并且最后一个字符串没有空格，下面就循环先输出空格再输出字符串然后弹出<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;stack&gt;
using namespace std;

int main()
{
    stack&lt;string&gt; v;
    string s;
    while(cin &gt;&gt; s)
        v.push(s);
    cout &lt;&lt; v.top();
    v.pop();
    while(!v.empty())
    {
        cout &lt;&lt; &quot; &quot; &lt;&lt; v.top();
        v.pop();
    }
    return 0;
}

</code></pre>
<p>1010<br>
解题思路：<br>
1.每次输入两个变量，不用存放到数组中，规律是每次输出第一个变量*第二个变量；第二个变量-1<br>
2.对于上面规律使用前提是第二个变量不为0，若为0，不执行语句，进入下一次循环，看，在这里并不是<br>
3. 使用continue，而是循环中嵌套一个if，这样当条件不满足时，自动不执行if中的语句，直接进入下一次循环<br>
4.对于先输出数值，后输出空格，但在最后不能有空格的套路是用flag标记（你懂的）<br>
5.对于零项多项式和全部都是常数项而言，当整个循环结束后还是用flag==0判断，并输出0 0</p>
<p>注意事项：<br>
1 . 0项多项式表示前面没有式子，这样在循环到最后一个式子时输出 0 0<br>
2.对于前面有式子最后一个是0项多项式，这根本不叫0项多项式<br>
3.对于目前这个程序而言根本无法测试出输出&quot;0 0&quot;这个式子因为循环一直不结束，之所以能输出想要的结果那是因为在循环内部就给出值了</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int flag=0;
    int a,b;
    while(cin &gt;&gt; a &gt;&gt; b)
    {
        if(b!=0)
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a*b &lt;&lt; &quot; &quot; &lt;&lt; b-1;
            flag=1;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;0 0&quot;;
}

</code></pre>
<p>1012<br>
解题思路：<br>
1.将输入的数字存放到对5求余对应下标的二维数组中<br>
2.计算A1--A5<br>
1.A2：就是下标为偶数的加 - 下标为奇数的和<br>
3.输出，用printf简单<br>
注意事项：<br>
1.==不是=<br>
2.对于某个点一直过不去，重新敲一遍</p>
<pre><code class="language-cpp">/*
    解题思路：
    1.将输入的数字存放到对5求余对应下标的二维数组中
    2.计算A1--A5
            1.A2：就是下标为偶数的加 - 下标为奇数的和
    3.输出，用printf简单
*/
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,digit,A1=0,A2=0,A3=0,A5=-1;   //对应的变量注意设置出来
    double A4=0.0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a[5];

    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; digit;
        a[digit%5].push_back(digit);      //这里使用push_back就是将数字压入，自动生成一个二维数组
                                        //注意写法：数组[下标].push_back(要填入的数字);
    }

    for(int i=0; i&lt;5; i++)
        for(int j=0; j&lt;a[i].size(); j++)
        {
            if(i==0 &amp;&amp; a[i][j]%2==0)
                A1+=a[i][j];
            if(i==1 &amp;&amp; j%2==0)
                A2+=a[i][j];
            if(i==1 &amp;&amp; j%2!=0)
                A2-=a[i][j];
            if(i==2)
                A3++;
            if(i==3)
                A4+=a[i][j];
            if(i==4 &amp;&amp; a[i][j]&gt;A5)     //一定要是大于A5
                A5=a[i][j];
        }
    for(int i=0; i&lt;5; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        if(i==0 &amp;&amp; A1==0 || i!=0 &amp;&amp; a[i].size()==0)
        {
            cout &lt;&lt; &quot;N&quot;;
            continue;
        }
        if(i==0)
            printf(&quot;%d&quot;,A1);
        if(i==1)
            printf(&quot;%d&quot;, A2);  //计算出结果为何不直接输出值？因为每一次输出都有条件限制，对于不存在的数输出N，
                            //为了保证思路的理解，就设置成循环，如果不满足条件就输出N，否则按照对应的值输出
        if(i==2)
            printf(&quot;%d&quot;,A3);
        if(i==3)
            printf(&quot;%.1f&quot;,A4/a[i].size());
        if(i==4)
            printf(&quot;%d&quot;,A5);
    }
    return 0;
}

</code></pre>
<p>1013<br>
解题思路：<br>
将从第M个素数到第N个素数放到数组中</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

bool isprime(int a)
{
    for(int i=2; i*i&lt;=a; i++)
        if(a%i == 0)
            return false;
    return true;
}

int main()
{
    int M,N,num=2,cnt=0;
    cin &gt;&gt; M &gt;&gt; N;
    vector&lt;int&gt; v;
    /*
        1.从素数列中找到第m个到第n个放到数组中
        2.用while循环，含义是循环至少执行N次，也就是M=5，N=27，循环至少执行27次，表示
          从第一素数到第27个素数，而且cnt必须从0开始，因为num初值为2，进入到isprime函数中，
          cnt++表示1与2为第一个素数相对应
        3.num++与循环的判断条件无关，循环的判断条件是第几个素数，其中cnt为N-1就表示第N个素数
          因为cnt从0开始
    */
    while(cnt &lt; N)       //cnt的值从0开始，自然要小于N
    {
        if(isprime(num))
        {
            cnt++;
            if(cnt &gt;= M)
                v.push_back(num);
        }
        num++;
    }
    cnt=0;
    /*
        对于每次先输出数字再输出空格，且最后一个不为空格，且每行10个的思想:
        1.将输出空格代码放前面，用if的一个条件判断（避开第一次输出空格），
          然后紧接着输出数字，依次循环
        2.对于每次换行，都希望能与1中的if语句相关联。这样保证每次换行时不会先输出一个空格，
          再输出数值，对于每次输出10个，那么每行的第一个就是1,11，21,31.....求余为1
          这样在if中可以设置%10!=1输出空格，当然在最后要有如果求余10就输出换行
    */
    for(int i=0; i&lt;v.size(); i++)
    {
        cnt++;
        if(cnt%10 != 1)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
        if(cnt%10 == 0)
            cout &lt;&lt; endl;
    }
}


/**********我的代码但是超时**********/
/*
    解题思路：
    1.素数公式判断
    2.从第m个素数到第n个素数
    主要是找到第一个
        1.用while，条件是k==n;k=0
*/
#include&lt;iostream&gt;
using namespace std;
bool f(int n)
{

    for(int i=2; i*i&lt;=n; i++)
        if(n%i==0)
           return false;
    return true;
}

int s(int n)  //找到第n个素数
{
    int k=1,i=3;
    if(n==1)
    {
        return 2;
    }
    while(k!=n)
    {
        if(f(i))
            k++;
        i+=2;
    }
    return i-=2;
}

int main()
{

    int m,n,now=0,flag=0;
    cin &gt;&gt; m &gt;&gt; n;
    for(int i=s(m); i&lt;=s(n); i++)
    {
        if(f(i))
        {
            if(flag==1)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; i;
            flag=1;
            now++;
    /*
        之前是换行后，先输出空格然后再输出值，我改为每次换行后，将flag的值修改，这样进入
        下次循环时，就不会输出空格，并且按照最后一个不为空格的方式输出
    */
            if(now%10==0)
            {
                cout &lt;&lt; endl;
                flag=0;
            }
        }

    }


    return 0;
}

</code></pre>
<p>1014<br>
解题思路：<br>
1.用两次while分别找出a,b字符串中第一个和第二个相同字符<br>
2.同样也用while遍历循环c，d两个字符串<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用两次while分别找出a,b字符串中第一个和第二个相同字符
    2.同样也用while遍历循环c，d两个字符串
*/
int main()
{
    string a,b,c,d;
    char t[2];
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    int i=0,j=0,e=0;
    //找到第一个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i] &amp;&amp; ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='G'))
        {
            t[0]=a[i];
            break;
        }
        i++;
    }
    i++;

    //找到第二个相同的字符
    while(i&lt;a.length() &amp;&amp; i&lt;b.length())
    {
        if(a[i]==b[i])
        {
            if(isdigit(a[i]) || ('A'&lt;=a[i] &amp;&amp; a[i]&lt;='N'))  //isdigit(a[i])判断a[i]是否为数字字符
            {
                t[1]=a[i];
                break;
            }
        }
        i++;
    }

    //找到第三个字符
    while(j&lt;c.length() &amp;&amp; j&lt;d.length())
    {
        if(c[j]==d[j] &amp;&amp; isalpha(c[j]))          //isalpha(c[j])判断c[j]是否为字母
        {
            e=j;
            break;
        }
        j++;
    }


    char sa[7][5]={&quot;MON &quot;,&quot;TUE &quot;,&quot;WED &quot;,&quot;THU &quot;,&quot;FRI &quot;,&quot;SAT &quot;,&quot;SUN &quot;};
    cout &lt;&lt; sa[t[0]-'A'];
    int m=isdigit(t[1])? t[1]-'0': t[1]- 'A' + 10;    //切记这里用一个整形变量m来接受条件判断的结果，最后在输出
    printf(&quot;%02d:%02d&quot;,m,j);       //采用c的方式输出，是为了当数字为1位时，前面有0补充；否则直接输出2位数

    return 0;
}


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">isdigit(A)   //判断A是否为数字字符
isalpha(A)   //判断A是否为字母
</code></pre>
<p>1015德才论<br>
解题思路：<br>
1.用一个结构stu来存放数据信息<br>
2.设置一个排序函数，总分不同按照从大到小排列，总分相同，按照按照德分从大到小排列；德分相同，按照<br>
学号从小到大输出<br>
3.设置1个结构数组，一个临时变量结构用来存放每次的输入；循环中嵌套if判断，将对应的结构压入栈中，也就形成了二维数组<br>
4.最后压栈进行排序后并输出<br>
注意事项：<br>
在输入时，用scanf格式控制字符来输入，不会超时<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
/*
    解题思路：

*/
struct node
{
    int num,de,cai;
};

int cmp(struct node a, struct node b)
{
    if((a.de+a.cai)!=(b.de+b.cai))
        return (a.de+a.cai) &gt; (b.de+b.cai);   //如果总分数不同，就按照最大到小的顺序排列
    else if(a.de!=b.de)                    //如果总分数相同，但德分不同，按照德分从大到小排列
        return a.de&gt;b.de;         //从大到小
    else
        return a.num&lt;b.num;            //从小到大
}


int main()
{
    int low,high,n;
    cin &gt;&gt; n &gt;&gt; low &gt;&gt; high;
    node temp;
    vector&lt;node&gt; v[4];
    int total=n;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d&quot;, &amp;temp.num,&amp;temp.de, &amp;temp.cai);
        if(temp.de &lt; low || temp.cai &lt; low)
            total--;
        else if(temp.de &gt;= high &amp;&amp; temp.cai &gt;= high)
            v[0].push_back(temp);
        else if(temp.de &gt;= high &amp;&amp; temp.cai &lt; high)
            v[1].push_back(temp);
        else if(temp.de &lt; high &amp;&amp; temp.cai &lt; high &amp;&amp; temp.de &gt;= temp.cai)
            v[2].push_back(temp);
        else
            v[3].push_back(temp);

    }
    cout &lt;&lt; total &lt;&lt; endl;
    for(int i=0; i&lt;4; i++)
    {
        sort(v[i].begin(),v[i].end(),cmp);
        for(int j=0; j&lt;v[i].size(); j++)
            cout &lt;&lt; v[i][j].num &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].de &lt;&lt; &quot; &quot; &lt;&lt; v[i][j].cai &lt;&lt;endl;
    }
    return 0;

}

</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">自定义排序：
struct stu
{
	int mark,num;
};
bool cmp(stu a, stu b)
{
	if(a.mark != b.mark)
		return a.mark &gt; b.mark  //降序排列
	else
		return a.num&lt;b.num      //mark相同按照num的升序排列
}
vector&lt;stu&gt; v[4];   //结构数组
sort(v[i].begin(),v[i].end(),cmp);  //对数组进行相应的排序
</code></pre>
<p>1016<br>
解题思路：<br>
1.用string存放要输入的字符串数组，用int来存放其他类型<br>
2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来<br>
3.两次循环记录相同数字的个数<br>
4.根据相同数字个数是否为0，否就再循环算出对应的值<br>
参考代码</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用string存放要输入的字符串数组，用int来存放其他类型
    2.判断是否有相同的字符，并且记录个数，最后通过循环来累加起来
*/
int main()
{
    string a,b;
    int a1,b1,num1=0,num2=0,suma=0,sumb=0;    //a1,b1表示要找的数字,num1,num2表示个数，suma,sumb表示和
    cin &gt;&gt; a &gt;&gt; a1 &gt;&gt; b &gt;&gt; b1;
    for(int i=0; i&lt;a.size(); i++)      //记录相同数字的个数
    {
        if(a1 == a[i]-'0')
            num1++;
    }
    for(int i=0; i&lt;b.size(); i++)        //记录相同数字的个数
    {
        if(b1 == b[i]-'0')
            num2++;
    }

    if(num1!=0)  
        suma=a1;   
    if(num2!=0)
        sumb=b1;
    for(int i=1; i&lt;num1; i++)
        suma=suma*10+a1;
    for(int i=1; i&lt;num2; i++)
        sumb=sumb*10+b1;
    cout &lt;&lt; suma+sumb;
    return 0;
}


</code></pre>
<p>1017<br>
解题思路：<br>
1.模拟手动求余的过程<br>
2.对于1000位的数字，用string；对于输出商，不用变量存储，直接输出<br>
参考代码：</p>
<pre><code class="language-cpp">int main()
{
    string s;
    int a,t=0,temp=0;
    cin &gt;&gt; s &gt;&gt; a;
    t=(s[0]-'0')/a;    //t就是商
    /*
        1.对于只有一位的数，直接输出商t
        2.对于2位及2位以上，如17 ，93 这种情况，前者就不输出，后者输出1
    */
    if((t != 0 &amp;&amp; s.length() &gt; 1) || s.length() == 1)
        cout &lt;&lt; t;
    temp = (s[0]-'0')%a;    //保存余数
    /*
        i从1开始，先计算下一位数的数，输出商，保存余数
    */
    for(int i=1; i&lt;s.length(); i++)   
    {
        t=(temp*10+s[i]-'0')/a;       
        cout &lt;&lt; t;
        temp=(temp*10+s[i]-'0')%a;
    }
    cout &lt;&lt; &quot; &quot; &lt;&lt; temp;
    return 0;
}
</code></pre>
<p>1018<br>
解题思路：<br>
1.统计甲赢的次数，乙赢的次数。甲输的次数就是赢的次数，同理，乙也是如此。平的次数就是总数-甲赢的次数-乙赢的次数<br>
2.如何确定赢次数最多的手势？<br>
答：将BCJ默认为012，在统计赢的次数时，记录甲乙赢的时候，对应手势所对应的下标的数组++，最后选出最大的个数，并且记住<br>
下标，最后定义一个字符数组&quot;BCJ&quot;这样刚才统计的下标就可以字符数组相对应<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.jiawin  yiwin 分别记录甲赢的次数和已赢的次数
    2.a[]  b[]两个数组分别统计B,J,C赢的次数，默认为012
    3.最后对数组元素比较得出最大的数组下标，同时设计一个变量，也是BJC这样就输出了对应的值
*/
int main()
{
    int jiawin=0,yiwin=0;
    int jia[3]={0};
    int yi[3]={0};
    char s,t;
    int n;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; s &gt;&gt; t;
        if(s=='B' &amp;&amp; t=='C')
        {
            jiawin++;
            jia[0]++;
        }
        else if(s=='C' &amp;&amp; t=='J')
        {
            jiawin++;
            jia[1]++;
        }
        else if(s=='J' &amp;&amp; t=='B')
        {
            jiawin++;
            jia[2]++;
        }
        else if(s=='C' &amp;&amp; t=='B')
        {
            yiwin++;
            yi[0]++;
        }
        else if(s=='J' &amp;&amp; t=='C')
        {
            yiwin++;
            yi[1]++;
        }
        else if(s=='B' &amp;&amp; t=='J')
        {
            yiwin++;
            yi[2]++;
        }
    }
    cout &lt;&lt; jiawin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; yiwin &lt;&lt; endl &lt;&lt; yiwin &lt;&lt; &quot; &quot; &lt;&lt; n-jiawin-yiwin &lt;&lt; &quot; &quot; &lt;&lt; jiawin &lt;&lt; endl;
    int maxjia=jia[0]&gt;=jia[1]?0:1;    //设计大于等于的目的是：首先字母已经从字母序从小到大排列，当a[0]==a[1]时，结果max1还是0，不然最后max1就指向j
    maxjia=jia[maxjia]&gt;=jia[2]?maxjia:2;

    int maxyi=yi[0]&gt;=yi[1]?0:1;
    maxyi=yi[maxyi]&gt;=yi[2]?maxyi:2;
    char k[4]={&quot;BCJ&quot;};
    cout &lt;&lt; k[maxjia] &lt;&lt; &quot; &quot; &lt;&lt; k[maxyi];
    return 0;
}
</code></pre>
<p>注意：BCJ对应012</p>
<p>1019<br>
解题思路：<br>
1.还是用string类来存放输入的数字<br>
2.自定义函数降序排列+结合sort升序排列+字符串转化为数字函数stoi()+数字转化为字符串函数to_string()+对不足四位的数补充0的相关函数s.insert(i,j,k)（题目要求四位输出）+do-while（当先输入0000时，还可以输出）<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
bool cmp(char a, char b)
{
    return a&gt;b;
}
int main()
{
    string s;
    cin &gt;&gt; s;
    s.insert(0,4-s.length(),'0');    //输入的数字不满足4位，则前补充0
    do          //先输入do-while是为了，当输入6174时还能执行一次循环
    {
        string a=s,b=s;
        sort(a.begin(),a.end(),cmp);  //数字以从大到小排列
        sort(b.begin(),b.end());      //默认为从小到大
        int result=stoi(a)-stoi(b);    //stoi将字符串转化为整数
        s=to_string(result);            //将数字转化为字符
        s.insert(0,4-s.length(),'0');
        cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; s &lt;&lt; endl;
    }while(s!=&quot;6174&quot; &amp;&amp; s!=&quot;0000&quot;);
    return 0;
}


/*
    知识总结：
    1.对字符串第i个位置开始，插入j个k
        s.insert(i,k,j);
    2.对字符串进行排序
        sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列
        sort(s.begin(),s.end());         //默认为从小到大排列
    3.stoi(str)   //将字符串转化为整数
    4.to_string(a)          //将数字转化为字符串
*/


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">​```cpp
    1.对字符串第i个位置开始，插入j个k
        s.insert(i,k,j);
    2.对字符串进行排序
        sort(s.begin(),s.end(),cmp);   //按照cmp的顺序排列
        sort(s.begin(),s.end());         //默认为从小到大排列
    3.stoi(str)   //将字符串转化为整数
    4.to_string(a)          //将数字转化为字符串
</code></pre>
<pre><code>  
1020
解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
   参考代码：
   

​```cpp
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.构建一个结点里面有3个结构成员，分别是mount种类库存，price种类总价，unit种类单价
    2.自定义cmp，按照单价的降序排列
    3.设置循环，先紧着单价最高的使，然后用单价次一级的....这样最后利润一定是最高的
*/

struct mooncake
{
    float mount,price,unit;
};
int cmp(mooncake a, mooncake b)
{
    return a.unit &gt; b.unit;
}
int main()
{
    int n,need;
    cin &gt;&gt; n &gt;&gt; need;
    vector&lt;mooncake&gt; a(n); //且记要定义数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].mount);  //切记，float类型的scanf是%f
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%f&quot;,&amp;a[i].price);
    for(int i=0; i&lt;n; i++)
        a[i].unit=a[i].price/a[i].mount;

    sort(a.begin(),a.end(),cmp);

    float result=0.0;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i].mount &lt;= need)
            result = result+a[i].price;
        else
        {
            result=result+a[i].unit*need;
            break;
        }
        need=need-a[i].mount;
    }
    printf(&quot;%.2f&quot;,result);
    return 0;
}

</code></pre>
<p>知识总结：<br>
对于vector定义的数组连续for输入需要指明数组长度</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main()
{
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);  //不定以数组长度大小，否则不能连续for输入
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; b[i];
    return 0;
}


</code></pre>
<p>1021<br>
解题思路：<br>
用string存储整数，for遍历循环，定义9个长度的数组，对应的值++，最后按顺序输出数组元素不为0的</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.
*/
int main()
{
    string s;
    int a[10]={0};
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
        a[s[i]-'0']++;
    for(int i=0; i&lt;10; i++)
    {
        if(a[i]!=0)
            cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; a[i] &lt;&lt; endl;
    }
    return 0;
}


</code></pre>
<p>注意事项：<br>
有时候，用vector发生错误，就直接用普通数组定义法</p>
<p>1022<br>
解题思路：<br>
1.将余数存入数组，while的判断条件sum!=0<br>
2.将数组倒叙输出，j=i-1，<br>
3.不要忘记sum的0，输出0，return 0<br>
4.不要用VEctor压栈<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.将余数存入数组，while的判断条件sum!=0
    2.将数组倒叙输出，j=i-1，
    3.不要忘记sum的0，输出0，return 0
    4.不要用VEctor压栈
*/

int main()
{
    int sum,A,B,D,i=0;
    cin &gt;&gt; A &gt;&gt; B &gt;&gt; D;
    int a[100];
    sum=A+B;
    if(sum==0)
    {
        cout &lt;&lt; 0;
        return 0;
    }
    while(sum!=0)
    {
        a[i++]=sum%D;
        sum/=D;
    }
    for(int j=i-1; j&gt;=0; j--)
        cout &lt;&lt; a[j];
    return 0;
}



</code></pre>
<p>1023<br>
解题思路：<br>
1.没理解题意，切记数组是存放数字的个数<br>
2.先找出第一个不为0的数，并输出<br>
3.将所有0输出<br>
4.再输出所有第一个不为0的数<br>
5.双层for循环输出剩下的所有数，第一层for表示要输出的数字，第二层for表示要输出的个数<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    int a[10];
    int t;
    for(int i=0; i&lt;10; i++)
        cin &gt;&gt; a[i];
    for(int i=1; i&lt;10; i++)
    {
        if(a[i]!=0)
        {
            cout &lt;&lt; i;
            t=i;           //t存放第一个不为0的数
            break;
        }
    }

    for(int i=0; i&lt;a[0]; i++)   //输出所有的0
        cout &lt;&lt; 0;
    for(int i=0; i&lt;a[t]-1; i++)   //输出所有第一个不为0的数，因为之前输出了一个，所以这里就少输出1个
        cout &lt;&lt; t;
    for(int i=t+1; i&lt;10; i++)
        for(int j=0; j&lt;a[i]; j++)
            cout &lt;&lt; i;
    return 0;

}

</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.将余数压栈，sum&gt;D
*/

int main()
{
    vector&lt;int&gt; a(5);      //用vector定义数组长度就是后面加（n）n表示数组长度
    for(int i=0; i&lt;a.size(); i++)    //遍历数组时，i&lt;a.size()而不是a.end()
        cout &lt;&lt; a[i];
    int k=333;
    string s=to_string(k);      //将数字转化为字符串时用to_string切记是小写的to_string
    cout &lt;&lt; s;
    return 0;
}

</code></pre>
<p>1024<br>
解题思路：<br>
1.从E将字符串一分为2，但第一个字符串不包括符号位<br>
2.将后面的字符串转化为整数放到n<br>
3.根据n 的正负，选择输出不同的情况<br>
4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    /*
        解题思路：
        1.从E将字符串一分为2，但第一个字符串不包括符号位
        2.将后面的字符串转化为整数放到n
        3.根据n 的正负，选择输出不同的情况
        4.切记，当n为正数时，还要知道.和E之间的数字个数与n之间的关系，它们也是不同的输出
    */
    string s;
    cin &gt;&gt; s;
    int i=0;

    while(s[i]!='E')     //此时i表示E所在的位
        i++;

    string t=s.substr(1,i-1);     //t保存E之前的字符串，不包括符号位

    int n=stoi(s.substr(i+1));     //将E之后下一位开始到字符串结束的转化为数字

    if(s[0]=='-')
        cout &lt;&lt; &quot;-&quot;;

    cout &lt;&lt; n &lt;&lt; endl;
    if(n&lt;0)
    {
        cout &lt;&lt; &quot;0.&quot;;

        for(int j=0; j&lt;abs(n)-1; j++)  //输出0
            cout &lt;&lt; '0';

        for(int j=0; j&lt;t.length(); j++)   //遇到.就不输出
            if(t[j] != '.')
                cout &lt;&lt; t[j];
    }
    else
    {
        cout &lt;&lt; t[0];
        int cnt,j;

        for(j=2, cnt=0; j&lt;t.length() &amp;&amp; cnt&lt;n; j++,cnt++)  //若.和E之间的数字个数大于n，则只输出n个数字来
            cout &lt;&lt; t[j];

        /*
            根据上面for结束的情况，一种是j==t.length()表示.和E之间的数字个数小于n，后面直接输出（n-cnt）个0;
            另一种是cnt==n,表示.和E之间的数字个数大于或等于n，就得先输出. 然后从i=j开始一直到字符完输出
        */
        if(j==t.length())
        {
            for(int k=0; k&lt;n-cnt; k++)
                cout &lt;&lt; '0';
        }
        else
        {
            cout &lt;&lt; '.';
            for(int k=j; k&lt;t.length(); k++)
                cout &lt;&lt; t[k];
        }
    }
    return 0;
}

/*


</code></pre>
<p>知识总结：</p>
<pre><code class="language-cpp">知识总结：
1.s.substr() 截取字符串中的子串
    s.substr(4)  //表示从4开始到下标结束
    s.substr(5,3)   //表示从5开始3个字符*/

</code></pre>
<p>我的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.用string存放输入，判断E之后是+还是-
    2.若为-，
        先输出0. + （后面的值-符号和.之间有几位）*输出0  + 输出s[1]  + 输出s[3]--&gt;s[E所在的前一位]
      若为+，
        先输出s[1] + （输出第3位开始到E之前的所有数字) + （后面的值-小数点和E之间的数字个数）*输出0
    3.若第一个字符为-，必须先输出-

*/

int main()
{
    string s,s1;
    cin &gt;&gt; s;
    int t,m,k;
    int sum=0;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='E')
        {
            t=i;
            break;
        }
    }
    //计算E之后符号后的数值
    for(int i=t+2; i&lt;s.length(); i++)
    {
        sum+=s[i]-'0';
        sum*=10;
    }
    sum/=10;
    if(s[0]=='-')
        cout &lt;&lt; '-';
    if(s[t+1]=='-')
    {
        cout &lt;&lt; 0 &lt;&lt; '.';
        for(int i=1; i&lt;=sum-1; i++)
            cout &lt;&lt; 0;
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
    }
    else
    {
        cout &lt;&lt; s[1];
        for(int i=3; i&lt;t; i++)
            cout &lt;&lt; s[i];
        for(int i=1; i&lt;=sum-(t-3); i++)
            cout &lt;&lt; 0;
    }
    return 0;
}



</code></pre>
<p>1027<br>
解题思路：<br>
1.i表示从中间一行向外扩展的层数，比如样例中i为2<br>
2.3+5+7+...+2<em>i+1=i(i+2)这是上半部分字符的个数，一共有2</em>i*(i+2)+1个字符。当2<em>i</em>(i+2)+1&gt;N时，令row=i-1表示向外扩大的<br>
最大层数<br>
3.通过3个for嵌套循环输出字符：第一for控制打印的层数；第二个for控制打印空格(row-i)；第三for控制打印字符(2<em>i+1)（注意在每一行的最后面<br>
不需要打印空格，直接换行就能形成样例的效果）<br>
4.打印最中间一行<br>
5.打印最后下半部分<br>
6.输出剩余个数N-（2</em>i*(i+2)+1）</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

int main()
{
    int N,row=0;   //对row初始化否则超时
    char c;
    cin &gt;&gt; N &gt;&gt; c;
    for(int i=1; i&lt;N; i++)
    {
        if((2*i*(i+2)+1)&gt;N)
        {
            row=i-1;
            break;
        }
    }
    for(int i=row; i&gt;=1; i--)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    for(int i=0; i&lt;row; i++)
        cout &lt;&lt; ' ';
    cout &lt;&lt; c &lt;&lt; endl;
    for(int i=1; i&lt;=row; i++)
    {
        for(int k=row-i; k&gt;=1; k--)
            cout &lt;&lt; ' ';
        for(int j=2*i+1; j&gt;=1; j--)
            cout &lt;&lt; c;
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; N-(2*row*(row+2)+1);
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.对row要赋初值，否则运行超时</p>
<p>1028<br>
解题思路：<br>
1.用字符串来存储，还是用铁打的营盘流水兵的思想<br>
2.maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;都是string类的,string的比较从左至右；对于输入判断&quot;1814/09/06&quot;&lt;=tempbirth&lt;=&quot;2014/09/06&quot;<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
   
*/
int main()
{
    int n,cnt=0;
    cin &gt;&gt; n;
    string name,birth,maxbirth=&quot;1814/09/06&quot;,minbirth=&quot;2014/09/06&quot;,maxname,minname;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; name &gt;&gt; birth;
        if(&quot;1814/09/06&quot;&lt;=birth &amp;&amp; birth&lt;=&quot;2014/09/06&quot;)
        {
            cnt++;
            if(birth&gt;maxbirth)
            {
                maxbirth=birth;
                minname=name;
            }
            if(birth&lt;minbirth)
            {
                minbirth=birth;
                maxname=name;
            }
        }
    }
    cout &lt;&lt; cnt;
    if(cnt!=0)
        cout &lt;&lt; &quot; &quot; &lt;&lt; maxname &lt;&lt; &quot; &quot; &lt;&lt; minname;
}


</code></pre>
<p>知识总结：<br>
对于string字符串的比较是从左至右，按照ascii码比较</p>
<p>1029<br>
解题思路：<br>
1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;<br>
并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的<br>
2.最后输出ans<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
/*
    解题思路：
    1.以第一个字符串为准使用for循环，然后用a.find(b)来判断a中是否含有b，如果没有find返回string::npos;
    并且用ans来表示第一个字符串和第二个字符串中不相同的且不相同的字符转化为大写也是不同的
    2.最后输出ans
    3.ans表示s1与s2中不相同的字符的字符串
*/
int main()
{
    string s1,s2,ans;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)
            ans+=toupper(s1[i]);
    }
    cout &lt;&lt; ans;
    return 0;
}


</code></pre>
<p>知识总结：<br>
1.toupper（）将小写字母转化成大写字母</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    /*
        1.toupper函数返回值为整数，在前面加个强制转化即可
    */
    char a='d';
    cout &lt;&lt; (char)toupper(a);
}


</code></pre>
<p>2.a.find(b)查找a字符串中是否含有b</p>
<pre><code class="language-cpp">/*
        1.a.find(b)如果字符串a中包含字符串b则值不等于string::npos，否则相同。a，b可以是字符串也可以是字符
        2.npos是一个常数，用来表示不存在的位置
        3.a字符串中如果包含b，则返回0；否则返回4294967295也就是npos
*/
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
    string a,b;
    cin &gt;&gt; a &gt;&gt; b;
    cout &lt;&lt; a.find(b) &lt;&lt; endl;
    cout &lt;&lt; string::npos;
    return 0;
}


</code></pre>
<p>1030<br>
解题思路：<br>
1.先对数组进行排序，从小到大<br>
2.通过两个for+if-else来找到满足题意的个数，外层for控制遍历整个数列，每次把v[i]当成最小的数，里面的for<br>
就是判断当前v[i]是最小值时，所对应的满足题意的最多的个数。这里j=i+result与if(v[j]&lt;=v[i]*p)用来表示：比如<br>
上次循环后result=3，此时一开始就判断从当前i开始往后第3个数是否满足条件，满足就修改result的值，不满足result<br>
值不变<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int n,temp,result=0;
    long long p;
    cin &gt;&gt; n &gt;&gt; p;
    vector&lt;int&gt;a(n);     //用vector定义有长度的数组时，数组名后用圆括号()中写数组长度
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        for(int j=i+result; j&lt;n; j++)
        {
            if(a[j]&lt;=a[i]*p)
            {
                temp=j-i+1;
                if(temp&gt;result)
                    result=temp;
            }
            else
                break;
        }
    }
    cout &lt;&lt; result;
    return 0;
}
</code></pre>
<p>知识总结：<br>
1.int：32位  0--2^32-1   long long： 64位 0--2^64-1<br>
2.用vector定义有长度的数组时，数组名后用圆括号()中写数组长度</p>
<p>1031<br>
解题思路：<br>
1.定义一个函数isTrue判断字符串是否满足题意<br>
2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag<br>
3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum<br>
4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与检验数组中的值对应</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.定义一个函数isTrue判断字符串是否满足题意
    2.对于全部满足输出&quot;All passed&quot;和不满足时输出字符串，可以使用flag
    3.对于isTrue函数中通过for循环如果有不是数字的字符返回false，并且求出加权和sum
    4.对于末尾数组中有x对应数组中10，设置一个临时变量tem，如果s[17]=='x',将tem=10，然后在判断是否与
    检验数组中的值对应
*/


bool isTrue(string s)
{
    int a[17]={7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2};
    int b[11]={1,0,10,9,8,7,6,5,4,3,2};
    int sum=0;
    for(int i=0; i&lt;17; i++)
    {
        if(s[i]&lt;'0' || s[i]&gt;'9')
           return false;
        sum+=(s[i]-'0')*a[i];
    }
    int temp=(s[17]=='X')?10:(s[17]-'0');
    return b[sum%11]==temp;           //如果最后一位检验相同，就返回True；否则返回false；也可以用if-else来写

}
int main()
{
    int n,flag=0;
    string s;
    cin &gt;&gt; n;
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; s;
        if(!isTrue(s))
        {
            flag=1;
            cout &lt;&lt; s &lt;&lt; endl;
        }
    }
    if(flag==0)
        cout &lt;&lt; &quot;All passed&quot;;
    return 0;
}

</code></pre>
<p>1032<br>
解题思路：<br>
1.将成绩放到学校编号对应的下标数组中，数组表示成绩之和<br>
2.将max表示最大成绩的下标，由于题中，学校编号是从1开始，所以max初值为1，最后直接输出max1，和a[max1]。<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.学校编号school，成绩和数组a[]={0},
    2.
*/
int main()
{
    int n,tem,max1=1,school;
    cin &gt;&gt; n;
    int a[n+1]={0};
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; school &gt;&gt; tem;
        a[school]+=tem;
    }
    for(int i=2; i&lt;=n; i++)
    {
        if(a[i]&gt;a[max1])
            max1=i;
    }
    cout &lt;&lt; max1 &lt;&lt; &quot; &quot; &lt;&lt; a[max1];
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.定义数组a的长度时是n+1并且初值为0，因为题中含义是n个学生，所以学校的编号最大是n，查找最大值时的那个循环要能遍历到n，如果定义数组a的长度为n，那么最后成绩之和最大的是a[n]（未赋初值的数组元素值是任意数），而最大值下标是n。<br>
2.假设max1=1，也就是假设第一个学校的总分最大</p>
<ol start="1034">
<li></li>
</ol>
<p>解题思路：<br>
解题思路：<br>
1.三个函数：gcd求出最大公约数；func对分数进行化简，main输入a b c d<br>
2.gcd用辗转相除求最大约数，<br>
if(t2<mark>0)<br>
return t1;<br>
else<br>
gcd(t2,t1%t2);<br>
3.gcd函数<br>
1.如果m*n</mark>0,分为2种情况：分母为0或分母为0，输出时加上判断分子是否为0<br>
2.用flag表示异号为1，同号为0<br>
3.对m,n都取绝对值，并向除<br>
4.func函数：<br>
1.解决Inf与分子为0的问题<br>
2.定义flag，对m，n取整，x分子与分母的商<br>
3.解决对于分数可能添加(-的问题<br>
4.不论分子与分母是整除还是不整除，都先要输出x<br>
5.如果对于整除的情况，根据flag看输不输出),并最后退出此函数<br>
6.如果对于不是整除的情况，就要加上一个空格，以便让假分数的整数部分与分数分开<br>
7.输出真分数的问题<br>
1.先计算假分数去除整数部分的分子<br>
2.然后调用gcd函数算出此时分母与分子的最大公约数<br>
3.然后算出最简形式<br>
4.按照分数的格式输出，注意最后还要根据flag看输出输出）。<br>
5.main：<br>
1.输入四个值a b c d<br>
2.对于加法：通分手动算出分子分母然后将其作为参数代入func函数中求最简形式<br>
3.对于减法，类似只是相减<br>
4.对于乘法，类似根据手动的策略<br>
5.对于除法，类似手动求倒数然后代入</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
long long a, b, c, d;       //为啥要是long long类型？答：必须范围足够大
/*

*/


//辗转相除求最大约数
long long gcd(long long t1, long long t2) {
   if(t2==0)
    return t1;
  else
    gcd(t2,t1%t2);
}

//对分数进行化简
void func(long long m, long long n)
{
 if (m * n == 0)
 {
     printf(&quot;%s&quot;, n==0?&quot;Inf&quot;:&quot;0&quot;);
     return ;
 }

 //异号是1，同号0
 bool flag=((m&lt;0 &amp;&amp; n&gt;0) || (m&gt;0 &amp;&amp; n&lt;0));
 m=abs(m); n= abs(n);
 long long x = m/n;

 printf(&quot;%s&quot;, flag?&quot;(-&quot;:&quot;&quot;);

 if (x!=0)
    printf(&quot;%lld&quot;,x);    //注意这里的格式化输出格式是小写的LLL 不是 11111111

 if (m%n==0)
 {
        printf(&quot;%s&quot;,flag?&quot;)&quot;:&quot;&quot;);
    return ;
 }

 if (x!=0)
    printf(&quot; &quot;);
 m=m-x*n;
 long long t = gcd(m,n);
 m=m/t; n=n/t;
 printf(&quot;%lld/%lld%s&quot;,m,n,flag?&quot;)&quot;:&quot;&quot;);
}

int main()
{
 scanf(&quot;%lld/%lld %lld/%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d);
 func(a,b); printf(&quot; + &quot;); func(c,d); printf(&quot; = &quot;); func(a*d+b*c,b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; - &quot;); func(c,d); printf(&quot; = &quot;); func(a*d-b*c,b*d); printf(&quot;\n&quot;);
 func(a,b); printf(&quot; * &quot;); func(c,d); printf(&quot; = &quot;); func(a*c, b*d);printf(&quot;\n&quot;);
 func(a,b); printf(&quot; / &quot;); func(c,d); printf(&quot; = &quot;); func(a*d, b*c);
 return 0;
}

</code></pre>
<p>易错点：</p>
<pre><code class="language-cpp">    if(m*n==0)
    {
        printf(&quot;%s&quot;,n==0?&quot;Inf&quot;:&quot;0&quot;);   
        return ;            // 易错：如果分子为0，或者分母为0，输出完Inf和0之后就应该退出程序；否则扣分
    }


    bool flag=((m&lt;0 &amp;&amp; n&gt;0)||(m&gt;0 &amp;&amp; n&lt;0));   //易错：flag设置为bool类型
</code></pre>
<ol start="1035">
<li></li>
</ol>
<p>解题思路：<br>
插入排序：<br>
i是数列b中第一个前一个数大于后一个数的位置<br>
j相当于从i开始一直到b数列结束a数列与b数列完全匹配<br>
对于插值排序：前面肯定是排好序的，也就是满足升序的序列，如果碰到前一位大于后一位则说明从此位的<br>
后一位开始一直到数组结束都是乱序的，所以刚好用j从此位的后一位开始一直到数组结束，判断j是否为n，<br>
如果是则为插序排列，然后对数组a进行sort排序（从头开始到i的下一位在排一次），表示他的下一次的插入排序，</p>
<pre><code>归并排序：
1.k初值为1，每次给自己乘2，
2.由于b是排序过程中的某一此序列，所以用a数列循环和b数列进行比较，flag是一个标记，初值为1，若在循环中
a[j]!=b[j]则令flag为1（意思是还要进行循环）本来模拟一次就行，但是测试点要求模拟整个过程。
3.理解while的思路：
    1.首先要明确，测试点要求整个的算法是模拟归并排序的整个过程，但输出时是要通过此算法得出下一次归并
    排序的结果。
    2.首先设置flag为1进入循环，将flag默认为0，下来的for用于判断初始数列和b数列是否相同，若相同则为0，
    否则为1
    3.k自乘2，然后for循环+sort(a+i*k,a+(i+1)*2)排序，最后还要有sort(a+n/k*k,a+n);
</code></pre>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    int n,i,j;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
    for(int j=0; j&lt;n; j++)
        cin &gt;&gt; b[j];

    for(i=0; i&lt;n-1 &amp;&amp; b[i]&lt;=b[i+1]; i++)
        ;
    for(j=i+1; j&lt;n &amp;&amp; a[j]==b[j]; j++)
        ;
    if(j==n)
    {
        cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl;
        sort(a,a+i+2);
    }
    else
    {
        cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl;
        int k=1,flag=1;
        while(flag)
        {
            flag=0;
            for(int i=0; i&lt;n; i++)
                if(a[i]!=b[i])
                    flag=1;
            k=k*2;
            for(int i=0; i&lt;n/k; i++)
                sort(a+i*k,a+(i+1)*k);
            sort(a+n/k*k,a+n);
        }
    }

    for(int i=0; i&lt;n; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; a[i];
    }
    return 0;
}

</code></pre>
<p>1036<br>
解题思路；无<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/
int main()
{
    int n;
    char c;
    cin &gt;&gt; n &gt;&gt; c;
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    cout &lt;&lt; endl;
    for(int j=0; j&lt;(n/2+n%2-2); j++)
    {
        cout &lt;&lt; c;
        for(int k=0; k&lt;(n-2); k++)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c &lt;&lt; endl;
    }
    for(int i=0; i&lt;n; i++)
        cout &lt;&lt; c;
    return 0;
}

</code></pre>
<p>易错点：</p>
<blockquote>
<p>对于50%的四舍五入是：n/2+n%2。比如17而言，结果为9<br>
但是如果只有n/2，结果为8；并非四舍五入的结果</p>
</blockquote>
<p>1037<br>
解题思路1：<br>
1.scanf输入<br>
2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。<br>
解题思路2：<br>
1.通过诸位比较，得出：实际付的钱小于应该付的钱时，要交换顺序，保证后面减的时候，是大的减小的；并且输出<br>
负号<br>
2.用实际付得钱mnt-应该付的钱abc,模拟手动减</p>
<p>参考代码1：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
/*
    解题思路：
    1.scanf输入
    2.将数字通过题中所给的进制转化，然后化为一个整数，然后计算。
*/
int main()
{
    int a,b,c,a1,b1,c1;
    scanf(&quot;%d.%d.%d&quot;,&amp;a,&amp;b,&amp;c);
    scanf(&quot;%d.%d.%d&quot;,&amp;a1,&amp;b1,&amp;c1);
    int P,A;
    P=c+b*29+a*17*29;
    A=c1+b1*29+a1*17*29;
    int k=A-P;
    if(k&lt;0)
    {
        cout &lt;&lt; '-';
        k=abs(k);
    }
    cout &lt;&lt; k/(17*29) &lt;&lt; '.' &lt;&lt; (k%(17*29))/29 &lt;&lt; '.' &lt;&lt; (k%(17*29))%29;
    return 0;
}


</code></pre>
<p>参考代码2；</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int a,b,c,m,n,t,x,y,z;
    scanf(&quot;%d.%d.%d %d.%d.%d&quot;,&amp;a,&amp;b,&amp;c,&amp;m,&amp;n,&amp;t);
    if(a&gt;m || (a==m &amp;&amp; b&gt;n) || (a==m &amp;&amp; b==n &amp;&amp; c&gt;t))
    {
        swap(a,m);
        swap(b,n);
        swap(c,t);
        cout &lt;&lt; &quot;-&quot;;
    }
    z=c&gt;t?29+t-c:t-c;
    n=c&gt;t?n-1:n;
    y=b&gt;n?17+n-b:n-b;
    x=b&gt;n?m-1-a:m-a;
    printf(&quot;%d.%d.%d&quot;,x,y,z);
    return 0;
}


</code></pre>
<p>注意事项：<br>
1.abc表示应该付款值，mnt表示实际付款值，如果实际付款值小于应该付款值，则交换位置，并输出符号，因为最后都是用大的减去小的也就是用mnt-abc模拟手动减法</p>
<p>1038<br>
解题思路1：<br>
1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中<br>
2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出</p>
<p>参考代码1：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.先输入一堆数字放到数组中，然后再输入k，随后把要查找的数放到数组中
    2.然后在循环查找原来数据中要查找数字的个数，并放入数组中，最后循环输出
*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int a[n];
    
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; a[i];
        
    int k;
    cin &gt;&gt; k;
    int b[k],c[k]={0};
    
    for(int j=0; j&lt;k; j++)
        cin &gt;&gt; b[j];
    
    for(int s=0; s&lt;k; s++)
        for(int l=0; l&lt;n; l++)
        {
            if(a[l]==b[s])
                c[s]++;
        }
        
    for(int i=0; i&lt;k; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; c[i];
    }
    return 0;
}


</code></pre>
<p>解题思路2：<br>
1.将成绩作为下标，然后对应的元素值++<br>
2.最后直接根据输入的值，循环输出</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    int n,temp;
    cin &gt;&gt; n;
    vector&lt;int&gt;b(101);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; temp;
        b[temp]++;
    }
    int m;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        scanf(&quot;%d&quot;, &amp;temp);//这里要用scanf否则超时
        if(i!=0)
            printf(&quot; &quot;);
         printf(&quot;%d&quot;, b[temp]);
    }
    return 0;
}


</code></pre>
<p>注意事项：<br>
对于for循环中有输入+输出，其实在输入时，只有敲回车，才会输出要输出的值，如果用空格将输入分开，则结果直接根据根据循环次数输出对应的值：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    vector&lt;int&gt;b(101);
    int m=4;
    int temp;
     for (int i = 0; i &lt; m; i++)
    {
         scanf(&quot;%d&quot;, &amp;temp);
         if (i != 0)
            printf(&quot; &quot;);
         printf(&quot;0&quot;);
     }
     return 0;
 }


</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200211132105418.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021113212868.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>1039<br>
解题思路1：<br>
1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠<br>
2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#<br>
3.算出s1中不为#的字符个数，算出s2中为#的字符个数，<br>
4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果<br>
s2中#的个数不等于s2的字符长度，则输出剩余的字符个数</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用字符串s1，s2分别存储摊主的串珠和小红想做的串珠
    2.以s2为基准，for循环，再嵌套for循环s1，如果字符相同则将s1，s2字符都改成#
    3.算出s1中不为#的字符个数，算出s2中为#的字符个数，
    4.if判断如果s2中#的个数等于s2的字符长度，则输出yes和s1中不为#的字符个数；如果
    s2中#的个数不等于s2的字符长度，则输出剩余的字符个数
*/
int main()
{
    string s1,s2;
    cin &gt;&gt; s1 &gt;&gt; s2;
    for(int i=0; i&lt;s2.length(); i++)
    {
        for(int j=0; j&lt;s1.length(); j++)
        {
            if(s2[i]==s1[j])
            {
                s1[j]='#';
                s2[i]='#';
            }
        }
    }
    int num2=0,num1=0;
    for(int i=0; i&lt;s1.length(); i++)
    {
        if(s1[i]!='#')
            num1++;
    }

    for(int i=0; i&lt;s2.length(); i++)
    {
        if(s2[i]=='#')
            num2++;
    }
    if(num2==s2.length())
        cout &lt;&lt; &quot;Yes &quot; &lt;&lt; num1;
    else
        cout &lt;&lt; &quot;No &quot; &lt;&lt; s2.length()-num2;
    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.将字符串中的字符转化成ascii码，存储到数组book中<br>
2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示<br>
相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++<br>
3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
int book[150];   //book默认值全为0
int main() 
{
/*
    解题思路：
    1.将字符串中的字符转化成ascii码，存储到数组book中
    2.设置result为0。for循环b字符串，如果根据字符对应book中的数字，如果大于0则book--，表示
    相同的字符碰掉，如果不大于0，就说原来的字符中就没有或者是用光了，则result++
    3.根据result判断，如果不为0，则输出no，输出result；如果为0，则输出yes，输出原来字符串-现在字符串
*/

     string a, b;
     cin &gt;&gt; a &gt;&gt; b;
     for (int i=0; i&lt;a.length(); i++)
        book[a[i]]++;
     int result = 0;
     for (int i=0; i&lt;b.length(); i++) 
     {
         if (book[b[i]] &gt; 0)
            book[b[i]]--;
         else
            result++;
     }
     if(result!=0)
        printf(&quot;No %d&quot;, result);
     else
        printf(&quot;Yes %d&quot;, a.length()-b.length());
     return 0; 
}
</code></pre>
<p>1040<br>
解题思路1：<br>
1.先找第一个p，然后依次找A，最后找T，然后构建起来</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    int a=1000000007,num=0,o,p;
    string s;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
        {
            o=i;
            for(int j=i+1; j&lt;s.length(); j++)
            {
                if(s[j]=='A')
                {
                    p=j;
                    for(int k=j+1; k&lt;s.length(); k++)
                    {
                        if(s[k]=='T')
                            num++;
                    }
                }
            }
        }
    }
    cout &lt;&lt; num%a;
    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.要知道PAT的个数等于对于每一个A，A前P的个数<em>A后T的个数累加起来即为PAT的个数<br>
2.先循环遍历T的个数<br>
3.for循环，若遇到P，则countp++，如果遇到A,则直接用countP</em>coutT累加到result，如果遇到T，则countT--，<br>
4.最后不要忘记对1000000007求余</p>
<p>参考代码2：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
/*
    解题思路：
    1.要知道PAT的个数等于对于每一个A，A前P的个数*A后T的个数累加起来即为PAT的个数
    2.先循环遍历T的个数
    3.for循环，若遇到P，则countp++，如果遇到A,则直接用countP*coutT累加到result，如果遇到T，则countT--，
    4.最后不要忘记对1000000007求余
*/
int main()
{
     string s;
     cin &gt;&gt; s;
     int len=s.length(), result=0, countp=0, countt=0;
     for(int i=0; i&lt;len; i++)
     {
         if (s[i]=='T')
         countt++;
     }
     for (int i=0; i&lt;len; i++)
     {
         if (s[i]=='P')
            countp++;
         if (s[i] == 'T')
            countt--;
         if (s[i] == 'A')
            result=(result+(countp * countt))%1000000007;
     }
     cout &lt;&lt; result;
     return 0;
 }


</code></pre>
<p>1041<br>
解题思路1：<br>
1.string存储一个二维数组，设置两个字符串变量s1，s2<br>
2.输入数据，保存在数组中<br>
3.输入整数，根据整数来对应数组中的值进行输出<br>
参考代码1：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.string存储一个二维数组，设置两个字符串变量s1，s2
    2.输入数据，保存在数组中
    3.输入整数，根据整数来对应数组中的值进行输出
*/
int main()
{
     string stu[1005][2], s1, s2;  //切记数组中的行标要超过1000
     int n, m, t;
     cin &gt;&gt; n;
     for(int i=0; i&lt;n; i++) 
     {
         cin &gt;&gt; s1 &gt;&gt; t &gt;&gt; s2;
         stu[t][0] = s1;
         stu[t][1] = s2;
     }
     cin &gt;&gt; m;
     for(int i=0; i&lt;m; i++) 
     {
         cin &gt;&gt; t;
         cout &lt;&lt; stu[t][0] &lt;&lt; &quot; &quot; &lt;&lt; stu[t][1] &lt;&lt; endl;
     }
     return 0;
 }


</code></pre>
<p>解题思路2：<br>
1.用结构类型来存储，然后循环找对应的输出即可<br>
参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.用结构类型来存储，然后循环找对应的输出即可
*/
struct stu
{
    long long a;
    int b;
    int c;
};
int main()
{
    int n;
    cin &gt;&gt; n;
    stu s[n];
    for(int i=0; i&lt;n; i++)
        cin &gt;&gt; s[i].a &gt;&gt; s[i].b &gt;&gt; s[i].c;
    int m,tem;
    cin &gt;&gt; m;
    for(int i=0; i&lt;m; i++)
    {
        cin &gt;&gt; tem;
        for(int i=0; i&lt;n; i++)
        {
            if(s[i].b==tem)
                cout &lt;&lt; s[i].a &lt;&lt; &quot; &quot; &lt;&lt; s[i].c &lt;&lt; endl;
        }
    }
    return 0;
}

</code></pre>
<p>1042<br>
解题思路：<br>
1.通过getline输入一个字符串<br>
2.定义一个数组a<br>
3.将字符串中所有字符改成小写<br>
4.如果是小写字符，就按照字符的ascii码，输入到数组a中<br>
5.假设a[0]是最大值，通过循环找出，最大值，以及对应的字符</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
int main()
{
    string s;
    int a[26]={0};
    getline(cin,s);
    for(int i=0; i&lt;s.length(); i++)
        s[i]=tolower(s[i]);
    for(int i=0; i&lt;s.length(); i++)
        if(islower(s[i]))
            a[s[i]-'a']++;
    int max=a[0],t=0;
    for(int i=1; i&lt;26; i++)
    {
        if(a[i]&gt;max)
        {
            max=a[i];
            t=i;
        }
    }
    printf(&quot;%c %d&quot;,'a'+t,max);
    return 0;
}

</code></pre>
<p>知识总结：</p>
<blockquote>
<p>tolower ，toupper， isalpha， isalnum， islower，isupper<br>
用法</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;cctype&gt;
using namespace std;
int main()
{

    /*tolower将字符改成小写
    string str=&quot;THIS IS A&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=tolower(str[i]);
    cout &lt;&lt; str;*/

    /*toupper将字符改成大写
    string str=&quot;this is a&quot;;
    for(int i=0; i&lt;str.length(); i++)
        str[i]=toupper(str[i]);
    cout &lt;&lt; str;*/

    /*isalpha()判断一个字符是否为子母，如果是字符返回非0，否则返会0
    cout &lt;&lt; isalpha('2');  //返回0
    cout &lt;&lt; isalpha('A');   返回非0
    */

    /*isalnum用来判断是否为数字或者子母，
    cout &lt;&lt; isalnum('A'); 输出非0
    cout &lt;&lt; isalnum('2');  输出非0
    cout &lt;&lt; isalnum('.');  输出0
    */

    /*islower判断是否为小写字母，是，返回非0；不是，返回0
    cout &lt;&lt; islower('a');
    cout &lt;&lt; islower('A');
    */

    /*isupper判断是否为大写字母，是，返回非0，不是返回0
    cout &lt;&lt; isupper('A');
    cout &lt;&lt; isupper('a');
    */
}

</code></pre>
<p>1043<br>
解题思路1：<br>
1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......<br>
2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为<br>
0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：
    1.首先输入字符串，将字符串中PATest对应的个数分别存放到a数组中，默认a[0]对应字符P,a[1]对应字符A......
    2.用do-while循环，按照PATest的顺序输出字符，每输出一个字符个数减少1，然后循环判断是只要a数组中的数据元素一个不为
    0，就循环，只到所有字符按顺序输出完，这样数组a全是0，然后就结束循环
*/
int main()
{
    string s;
    int a[6]={0};
    char c;
    int j=0;
    cin &gt;&gt; s;
    for(int i=0; i&lt;s.length(); i++)
    {
        if(s[i]=='P')
            a[0]++;
        if(s[i]=='A')
            a[1]++;
        if(s[i]=='T')
            a[2]++;
        if(s[i]=='e')
            a[3]++;
        if(s[i]=='s')
            a[4]++;
        if(s[i]=='t')
            a[5]++;
    }
  do
  {
    if(a[0]!=0)
    {
        cout &lt;&lt; 'P';
        a[0]--;
    }

    if(a[1]!=0)
    {
        cout &lt;&lt; 'A';
        a[1]--;
    }
    if(a[2]!=0)
    {
       cout &lt;&lt; 'T';
       a[2]--;
    }
    if(a[3]!=0)
    {
        cout &lt;&lt; 'e';
        a[3]--;
    }
    if(a[4]!=0)
    {
        cout &lt;&lt; 's';
        a[4]--;
    }
    if(a[5]!=0)
    {
        cout &lt;&lt; 't';
        a[5]--;
    }

  }while(a[0]!=0 || a[1]!=0 || a[2]!=0 || a[3]!=0 || a[4]!=0 || a[5]!=0);

    return 0;
}

</code></pre>
<p>解题思路2：<br>
1.用cin.get()将字符串中的字符保存到其ASCII码下标的数组中<br>
2.用while+if进行循环</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
     int map[128]={0},c;
     while ((c = cin.get()) != EOF)   //表示没有到文件的结尾，判题的时候输入一个样例，就是到文件的结尾了
        map[c]++;
     while (map['P'] &gt; 0 || map['A'] &gt; 0 || map['T'] &gt; 0 || map['e'] &gt; 0 ||map['s'] &gt; 0 || map['t'] &gt; 0)
     {
         if (map['P']-- &gt;0)     //对于map['P']-- &gt;0是先比较后自减，对于--map['P'] &gt;0 是先自减后比较
            cout &lt;&lt; 'P';
         if (map['A']-- &gt;0)
           cout &lt;&lt; 'A';
         if (map['T']-- &gt;0)
           cout &lt;&lt; 'T';
         if (map['e']-- &gt;0)
           cout &lt;&lt; 'e';
         if (map['s']-- &gt;0)
           cout &lt;&lt; 's';
         if (map['t']-- &gt;0)
           cout &lt;&lt; 't';
     }
     return 0;
 }


</code></pre>
<p>1044<br>
解题思路：<br>
1.还是用字符串数组保存参数<br>
2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字<br>
3.对于func1而言：<br>
1.对于t/13的除数放到b数组中查找<br>
2.如t/13和t%13均不为0，则输出“ ”<br>
3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找<br>
4.对于func2而言：<br>
1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来<br>
2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]<br>
3.对于s1再在b数组中找，返回t1*13+t2;</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
/*
    1.还是用字符串数组保存参数
    2.设置void func1和void func2函数分别表示将数字转换为火星文，将火星文转化为数字
    3.对于func1而言：
        1.对于t/13的除数放到b数组中查找
        2.如t/13和t%13均不为0，则输出“ ”
        3.对于t%13的数在a数组中查找，同时也要对t为0时，是在a数组中找
    4.对于func2而言：
        1.将str中0--2中的字符串赋值出来，如果字符串长度大于4，则将4--6字符串复制出来
        2.for循环从1开始对于13以内的数字则s1==a[j]或者大于13则s2=a[j]
        3.对于s1再在b数组中找，返回t1*13+t2;
*/
string a[13] = {&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;,&quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;};
string b[13] = {&quot;####&quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;,&quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;};
//将字符串和长度len设置为全局变量，这样方便调用函数时，不用传入过多的参数
string s;       
int len;

void func1(int t)
{
 if (t/13)
    cout &lt;&lt; b[t/13];
 if ((t/13) &amp;&amp; (t%13))
    cout &lt;&lt; &quot; &quot;;
 if (t%13 || t==0)
    cout &lt;&lt; a[t%13];
}

void func2()
{
     int t1=0, t2=0;
     string s1=s.substr(0,3),s2;   //substr复制字符串的函数
     if (len&gt;4)
        s2 = s.substr(4,3);
     for (int j = 1; j &lt;= 12; j++)
     {
         if (s1==a[j] || s2==a[j])    //为啥要填入s1=a[j]? 答：对于13进制以内的数有用，如feb=5;
            t2=j;
         if (s1==b[j])
            t1=j;
     }
     cout &lt;&lt; t1*13+t2;
 }

int main()
{
     int n;
     cin &gt;&gt; n;
     getchar();         //清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符
     for (int i = 0; i &lt; n; i++)
     {
         getline(cin, s);
         len=s.length();
         if (s[0]&gt;='0' &amp;&amp; s[0]&lt;='9')
            func1(stoi(s));
         else
            func2();
         cout &lt;&lt; endl;
     }
     return 0;
 }

</code></pre>
<p>注意事项：<br>
1.清除缓冲区的回车字符，注意以后在循环外和内中都要输入时，不要忘记加上getchar()消除缓冲区的字符<br>
2.注意格式，在主函数中每次循环一次输出endl，但在自身的输入时不要加endl</p>
<p>知识总结：<br>
stoi（将数字字符串改为整数）+ s.substr(pos,n)（将字符串中的字符复制到另一个字符串中）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{/*
    string str=&quot;abcdef&quot;;
    string a=str.substr(0,11);
    cout &lt;&lt; a;

0. 用途：一种构造string的方法

1. 形式：s.substr(pos, n)

2. 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）

3. 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾*/

/*字符串转化整数函数
    string s=&quot;123&quot;;
    cout &lt;&lt; stoi(s);
    */
}

</code></pre>
<p>1045<br>
解题思路1：<br>
解题思路：<br>
1.设置三个数组：abv分别表示原始数组，sort排列后的数组，主元元素数组<br>
2.核心思路，找a与b数组中相同的数字，并且该数字大于前的最大值，因为如果a与b的某个数字相同，说明后面的元素<br>
都比该元素大，故只用说明该数字大于之前的最大值即可<br>
3.输出数组v<br>
注意事项：<br>
1.输出主元元素的个数时，要换行<br>
2.最后整个数组输出完后，加换行</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int v[1000000];
int main()
{
    int n,max=-1,cnt=0;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n),b(n);
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }
    sort(a.begin(),a.end());
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i] &amp;&amp; b[i]&gt;max)
        {
            v[cnt++]=b[i];
        }

        if(b[i]&gt;max)
            max=b[i];
    }
    cout &lt;&lt; cnt &lt;&lt; endl;
    for(int i=0; i&lt;cnt; i++)
    {
        if(i!=0)
            cout &lt;&lt; &quot; &quot;;
        cout &lt;&lt; v[i];
    }
    cout &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>解题思路2；<br>
1.主元的判断条件：左边元素都比其小，右边的元素都比其大，或者换句话说，如果左边的某个数比其大或者右边的某个数比其小，则<br>
不是主元<br>
2.可以将合适的数组放到数组中，最后排序输出</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
/*

*/
int main()
{
    int n,num=0;
    cin &gt;&gt; n;
    int a[n],b[n];
    for(int i=0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
        b[i]=a[i];
    }

    sort(a,&amp;a[n]);
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
            num++;
    }
    cout &lt;&lt; num &lt;&lt; endl;
    for(int i=0; i&lt;n; i++)
    {
        if(a[i]==b[i])
        {
            if(i!=0)
                cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a[i];
        }
    }
    return 0;
}


</code></pre>
<p>1046<br>
解题思路：<br>
1.设置四个，jiahan，jiahua，yihan，yihua, jiahe,yihe<br>
2.逻辑如下</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/
int main()
{
    int n;
    cin &gt;&gt; n;
    int jiahan,jiahua,yihan,yihua,jiahe=0,yihe=0;
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d %d %d %d&quot;,&amp;jiahan,&amp;jiahua,&amp;yihan,&amp;yihua);
        if(jiahua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            yihe++;
        if(yihua==jiahan+yihan &amp;&amp; jiahua!=yihua)
            jiahe++;


    }
        cout &lt;&lt; jiahe &lt;&lt; &quot; &quot; &lt;&lt; yihe &lt;&lt; endl;
    return 0;
}

</code></pre>
<p>1047<br>
解题思路：<br>
1.必然有使用scanf输入<br>
2.完全可以将最后成绩保存在队伍编号的数组中</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*

*/

int main()
{
    int n,duiwu,duiyuan,chengji,maxduiwu=0;
    cin &gt;&gt; n;
    int a[1001]={0};
    for(int i=0; i&lt;n; i++)
    {
        scanf(&quot;%d-%d %d&quot;,&amp;duiwu,&amp;duiyuan,&amp;chengji);
        a[duiwu]+=chengji;
    }
    for(int i=0; i&lt;1001; i++)
    {
        if(a[i]&gt;a[maxduiwu])
            maxduiwu=i;
    }
    cout &lt;&lt; maxduiwu &lt;&lt; &quot; &quot; &lt;&lt; a[maxduiwu];
    return 0;
}

</code></pre>
<p>1048<br>
解题思路：<br>
1.将a，b字符串倒转过来<br>
2.根据比较字符串长度，给较短位补0<br>
3.设置str保存0,1..J,Q,K<br>
4.对于原来的数位而言，从个位开始就是奇数位，下一位就是偶数位，如果倒转过来，第一位虽然是偶数位，但是<br>
还是执行的是原来奇数位的操作。<br>
5.每次循环时将计算结果累加到字符串c中，最后倒叙输出</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
    string a,b,c;
    string str=&quot;0123456789JQK&quot;;
    cin &gt;&gt; a &gt;&gt; b;
    reverse(a.begin(),a.end());
    reverse(b.begin(),b.end());

    if(a.length()&gt;b.length())
        b.append(a.length()-b.length(),'0');
    else
        a.append(b.length()-a.length(),'0');

    for(int i=0; i&lt;b.length(); i++)
    {
        if(i%2==0)
            c+=str[(b[i]-'0'+a[i]-'0')%13];
        else
        {
            int tem=b[i]-a[i];
            if(tem&lt;0)
                tem+=10;
            c+=str[tem];       //由于对应的数字位相减，所以最大差值为9，而c是字符串，所以也可以直接用str[tem]来连接
        }
    }
    for(int i=c.length()-1; i&gt;=0; i--)
        cout &lt;&lt; c[i];
    return 0;
}

</code></pre>
<p>知识总结：<br>
1.a.append(n,c)表示对字符串a的尾部添加n个字符c<br>
2.reverse(a.begin(),a.end()) 对字符串a进行倒转</p>
<p>1049<br>
解题思路：<br>
1.通过找规律，其实就是每个数字出现i*(n-i+1)次，<br>
2.规律如下图：</p>
<p>参考代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
/*
    解题思路：

*/
int main()
{
    int n;
    cin &gt;&gt; n;
    double sum=0.0,tem;
    for(int i=1; i&lt;=n; i++)
    {
        cin &gt;&gt; tem;
        sum+=tem*i*(n-i+1);
    }
    printf(&quot;%.2f&quot;,sum);
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200220134238258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第九章笔记（排序）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-jiu-zhang-bi-ji-pai-xu/">
        </link>
        <updated>2020-03-01T04:22:20.000Z</updated>
        <content type="html"><![CDATA[<p><a href="#jump1">9.1开场白</a><br>
<a href="#jump2">9.2排序的基本概念和分类</a><br>
      <a href="#jump3">9.2.1排序的稳定性</a><br>
      <a href="#jump4">9.2.2内排序与外排序</a><br>
      <a href="#jump5">9.2.3排序用到的结构与函数</a><br>
<a href="#jump6">9.3冒泡排序</a><br>
      <a href="#jump7">9.3.1最简单排序实现</a><br>
      <a href="#jump8">9.3.2冒泡排序算法</a><br>
      <a href="#jump9">9.3.3冒泡排序优化</a><br>
      <a href="#jump10">9.3.4冒泡排序复杂度分析</a></p>
<p><a href="#jump11">9.4简单选择排序</a><br>
      <a href="#jump12">9.4.1简单选择排序算法</a><br>
      <a href="#jump13">9.4.2简单选择排序复杂度分析</a></p>
<p><a href="#jump14">9.5直接插入排序</a><br>
      <a href="#jump15">9.5.1直接插入排序算法</a><br>
      <a href="#jump16">9.5.2直接插入排序复杂度分析</a></p>
<p><a href="#jump17">9.6直接插入排序</a><br>
      <a href="#jump18">9.6.1希尔排序原理</a><br>
      <a href="#jump19">9.6.2希尔排序算法</a><br>
      <a href="#jump20">9.6.3希尔排序复杂度分析</a></p>
<p><a href="#jump21">9.8 归并排序</a><br>
      <a href="#jump22">9.8.1归并排序算法</a><br>
      <a href="#jump23">9.8.2归并排序复杂度分析</a><br>
      <a href="#jump24">9.8.3非递归实现归并排序</a></p>
<p><a href="#jump25">9.7堆排序</a><br>
      <a href="#jump26">9.7.1堆排序算法</a><br>
      <a href="#jump27">9.7.2堆排序复杂度分析</a></p>
<p><a href="#jump28">9.9快速排序</a><br>
      <a href="#jump29">9.9.1快速排序算法</a><br>
      <a href="#jump30">9.9.2快速排序复杂度分析</a><br>
      <a href="#jump31">9.9.3快速排序优化</a></p>
<p><span id="jump2">9.2排序的基本概念和分类</span><br>
1.排序就是将无序的数据集合，按照某一定顺序进行排列<br>
2.对于有很多关键字的排序，可以将多个关键字的排序转化成单个关键字的排序，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200216211522213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020021621153480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump3">9.2.1排序的稳定性</span><br>
如图：<br>
<img src="https://img-blog.csdnimg.cn/20200216211947313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump4">9.2.2内排序与外排序</span><br>
     1.什么叫内排序，外排序：（如下图）</p>
<p><img src="https://img-blog.csdnimg.cn/20200216212209422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
     2.排序算法的性能主要是受3个方面影响：</p>
<p>            1.时间性能：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/20200216212512766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            2.辅助空间：（如下图）<br>
<img src="https://img-blog.csdnimg.cn/2020021621252762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
            3.算法的复杂性：（如下图） <img src="https://img-blog.csdnimg.cn/20200216212540588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p><span id="jump5">9.2.3排序用到的结构与函数</span><br>
1.排序用到的顺序表结构：</p>
<pre><code class="language-cpp">#define MAXSIZE 10     //用于要排序数组个数最大值，可根据需要修改
typedef struct         
{
	int r[MAXSIZE+1];     //用于存储要排序的数组，r[0]用作哨兵或临时变量
	int length;           //用于记录顺序表长度
}SqList;    
</code></pre>
<p>2.排序所用到的交换函数</p>
<pre><code class="language-cpp">//交换L中数组r的下标为i和j的值
void swap(SqList *L,int i,int j)
{
	int temp=L-&gt;r[i];
	L-&gt;r[i]=L-&gt;r[j];
	L-&gt;r[j]=temp;
}
</code></pre>
<p><span id="jump6">9.3冒泡排序</span><br>
      <span id="jump7">9.3.1最简单的排序实现</span></p>
<blockquote>
<p>冒泡排序一种交换排序，它的基本思想：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做交换排序（冒泡排序初级版）
void BubbleSort0(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=i+1; j&lt;=L-&gt;length; j++)
		{
			if(L-&gt;r[i]&gt;L-&gt;r[j])
			{
				swap(L,i,j);    //交换L-&gt;r[i]与L-&gt;r[j]的值
			}
		}
	}
}//详见代码如下图
</code></pre>
<blockquote>
<p>上述代码的思路：让每一关键字，都和它后面的每一个关键字比较，如果前面的大于后面的，则交换，这样第一位置的关键字在一次循环后一定是最小的<br>
上述代码缺陷：每次只能一个一个去排列，这样对其余关键字没有任何帮助<br>
<img src="https://img-blog.csdnimg.cn/20200218214434373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</blockquote>
<p>      <span id="jump8">9.3.2冒泡排序算法</span></p>
<blockquote>
<p>此冒泡排序的思想：i从第一个位置开始，然后j从最后向前冒泡，不断地将小的值放到前面，这样不断的循环下去，便于将一部分小的数值移动一些位置</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做冒泡排序
void BubbleSort(SqList *L)
{
	int i,j;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		for(j=L-&gt;length-1; j&gt;=i; j--)     //注意j是从后往前循环
		{
			if(L-&gt;r[j]&gt;L-&gt;r[j+1])   //若前者大于后者
			{
				swap(L,j,j+1);   //交换L-&gt;r[j]与L-&gt;r[j+1]的值
			}
		}
	}
}//详见代码如下图：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200218214549665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200218214604810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump9">9.3.3冒泡排序优化</span></p>
<blockquote>
<p>为什么要有冒泡排序的优化？如下图中，如果不优化，还要不断地进行比较，浪费时间</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200218215111503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-cpp">//对顺序表L做改进冒泡算法
void BubbleSort2(SqList *L)
{
	int i,j;
	Status flag=TRUE;     //flag用来作为标记
	for(i=1; i&lt;L-&gt;length &amp;&amp; flag; i++)    //若flag为false则循环结束
	{
		flag=FALSE;    //初始为false
		for(j=L-&gt;length-1; j&gt;=i; j--)
		{
			if(L-&gt;r[j] &gt; L-&gt;[j+1])
			{
				swap(L,j,j+1);    //交换L-&gt;r[j]与L-&gt;r[j+1]的值
				flag=TRUE;       //如果有数据交换，则flag改true
			}
		}
	}
}//详见如下图：
</code></pre>
<blockquote>
<p>此代码的思想是：加入一个flag判断，flag初始值为TRUE，进入循环后如果后面循环中一但有交换则改flag值为TRUE，再次循环；如果循环中已经是升序排列，不会有前面的值大于后面的值，则flag为false，循环结束</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200218215911799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump10">9.3.4冒泡排序复杂度分析</span><br>
最好情况是o(n)<br>
最坏情况是o(n^2)</p>
<p><span id="jump11">9.4简单选择排序</span></p>
<p>      <span id="jump12">9.4.1简单选择排序算法</span></p>
<blockquote>
<p>简单选择排序的思想：从第一个位置开始，循环找到后面的最小值，然后与第一个位置的值进行交换，如此进行下去，则就是简单选择排序</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L做简单选择排序
void SelectSort(SqList *L)
{
	int i,j,min;
	for(i=1; i&lt;L-&gt;length; i++)
	{
		min=i;       //将当前下标定义为最小值下标
		for(j=i+1; j&lt;=L-&gt;length; j++)   //循环之后的数据
		{	
			if(L-&gt;r[min]&gt;L-&gt;r[j])   //如果有小于当前最小值的关键字
				min=j;         //将此关键字的下标赋值给min
		}
		if(i!=min)                     //若min不等于i，说明找到最小值了，交换
			swap(L,i,min);    //交换L-&gt;r[i]与L-&gt;r[min]的值
	}
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200218221732154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump13">9.4.2简单选择排序复杂度分析</span></p>
<blockquote>
<p>1.对上面代码中第二层的for（就是找最小值下标）的那个代码而言，对第一个值其比较次数为n-1，对于第2个值而言，其比较次数为n-2，则一共的比较次数为n(n-1)/2，后面中就是交换次序的代码，最坏情况需要交换n-1次，则一共的时间复杂度为o(n^2)</p>
</blockquote>
<p><span id="jump14">9.5直接插入排序</span><br>
      <span id="jump15">9.5.1 直接插入排序算法</span></p>
<blockquote>
<p>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增1的有序表</p>
</blockquote>
<pre><code class="language-cpp">//对顺序表L作直接插入操作
void InsertSort(SqList *L)
{
	int i,j;
	for(i=2; i&lt;=L-&gt;length; i++)
	{
		if(L-&gt;r[i]&lt;L-&gt;r[i-1])          //需将L-&gt;r[i]插入有序子表
		{
			L-&gt;r[0]=L-&gt;r[i];            //设置哨兵
			for(j=i-1; L-&gt;r[j]&gt;L-&gt;r[0]; j--)
				L-&gt;r[j+1]=L-&gt;r[j];              //记录后移
			L-&gt;r[j+1]=L-&gt;r[0];            //插入到正确位置
		}
	}
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200220223032274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022022305317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump16">9.5.2直接插入排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/20200220224148149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200220224207118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<span id="jump17">9.6希尔排序</span></p>
<p>      <span id="jump18">9.6.1希尔排序原理</span></p>
<blockquote>
<p>1.希尔排序就是为了突破O(n^2)的时间复杂度，思想就是每次循环一次后都将原来的数组排序成基本有序（P.S.基本有序就是大的数字基本在后面，小的数字基本在前面，不大不小的基本在中间）<br>
2.采用的是跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在自序列内分别进行直接插入排序后得到的结果时基本有序而不是局部有序</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200223211404857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump19">9.6.2 希尔排序算法</span></p>
<pre><code class="language-cpp">//对顺序表L做希尔排序
void ShellSort(SqList *L)
{
	int i,j;
	int increment=L-&gt;length;
	do
	{
		increment=increment/3+1;    //增量序列
		for(i=increment+1; i&lt;=L-&gt;length; i++)
		{
			if(L-&gt;r[i]&lt;L-&gt;r[i-increment])
			{//需将L-&gt;r[i]插入有序增量子表中
				L-&gt;r[0]=L-&gt;r[i];          //暂存到L-&gt;r[0]
				for(j=i-increment; j&gt;0 &amp;&amp; L-&gt;r[0]&lt;L-&gt;r[j]; j-=increment)
					L-&gt;r[j+increment]=L-&gt;r[j];        //记录向后移，查找插入位置
				L-&gt;r[j+increment]=L-&gt;r[0];          //插入
			}
		}
	}while(increment&gt;1);
}//详见如下图
</code></pre>
<p>1.待排数组<br>
<img src="https://img-blog.csdnimg.cn/20200223212218854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212236540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212256717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200223212313899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022321294273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump20">9.6.3希尔排序时间复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度为O(n^3/2)，要直接好于O(n的平方)<br>
2.增量序列的最后一个增量值必须等于1才行</p>
</blockquote>
<p><span id="jump21">9.8归并排序</span></p>
<blockquote>
<p>说白了就是对数组进行两两合并，详见下图</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224212407189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
      <span id="jump22">9.8.1归并排序算法</span></p>
<blockquote>
<p>归并排序的原理，见下图：</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/2020022421255582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>总的归并排序代码：</p>
<pre><code class="language-cpp">//对顺序表L做归并排序
void MergeSort(SqList *L)
{
	MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);
}

</code></pre>
<blockquote>
<p>上述代码，为了和前面的排序算法统一，用了同样的参数定义SqList *L，MSort的代码实现如下：</p>
</blockquote>
<p>递归拆分代码：</p>
<pre><code class="language-cpp">void MSort(int SR[], int TR1[], int s, int t)  //SR[]数组相当于原始数组，TR1[]相当于排好序的数组
{
	int m;
	int TR2[MAXSIZE+1];
	if(s==t)
		TR1[s]=SR[s];    
	else
	{
		m=(s+t)/2;     //相当于从中间开始分
		MSort(SR,TR2,s,m);    //将原始数组SR[]的前半部分递归到TR2[]中
		MSort(SR,TR2,m+1,t);     //将原始数组SR的后半部分放到TR2[]中
		Merge(TR2,TR1,s,m,t);   //将TR2[]递归到已排好序的数组TR1[]中
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224213548144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224213607291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022421364571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Merge函数如何实现（归并算法）：</p>
<pre><code class="language-cpp">//将数组直接归并为有序的
void Merge(int SR[], int TR[], int i,int m,int n)
{
	int j,k,l;
	for(j=m+1,k=i; i&lt;=m &amp;&amp; j&lt;=n; k++)   //将SR中记录有小到大归并入TR中
	{
		if(SR[i]&lt;SR[j])
			TR[k]=SR[i++];
		else
			TR[k]=SR[j++];
	}
	if(i&lt;=m)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=m-i; l++)
			TR[K+l]=SR[i+1];
	}
	if(j&lt;=n)                                 //将剩余的归并到TR中
	{
		for(l=0; l&lt;=n-j; l++)
			TR[k+l]=SR[j+l];
	}
} //详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224214436361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224214448493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>      <span id="jump23">9.8.2 归并排序复杂度分析</span></p>
<blockquote>
<p>1.时间复杂度分析：<br>
对于上面那个merge函数中，将原始数列SR[]放入到TR1[]中，由于要遍历循环所有的记录所以时间复杂度为O(n)，而由完全二叉树的深度可知，整个总的归并排序需要进行log2n次，总的时间复杂度为O(nlogn)<br>
2.空间复杂度分析：<br>
由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果，所以空间复杂度为o(n)。同时还有递归时深度为log2n的栈空间，因此空间复杂度为O(n+logn)<br>
3.Merge函数中有if(SR[i]&lt;SR[j])语句，这就说明他需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法</p>
</blockquote>
<p>      <span id="jump24">9.8.3 非递归实现归并排序</span></p>
<p>直接进行归并排序代码如下：</p>
<pre><code class="language-cpp">//对顺序表L作归并非递归排序
void MergeSort2(SqList *L)
{
	int* TR=(int *) malloc (L-&gt;length*sizeof(int));    //申请额外空间
	int k=1;
	while(k&lt;L-&gt;length)
	{
		MergePass(L-&gt;r,TR,k,L-&gt;length);
		k=2*k;                           //子序列长度加倍
		MergePass(TR,L-&gt;r,k,L-&gt;length);
	    k=2*k;                    	//子序列长度加倍
	}
} //详见代码如下图：

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200224215853578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<table><tr><td bgcolor=GreenYellow>非递归算法和递归算法的区别</td></tr></table>
<blockquote>
<p>1.非递归算法：对数组直接归并<br>
2.递归算法： 先递归拆分数组然后再归并退出递归</p>
</blockquote>
<p>上面的MergePass（归并排序）代码如下：</p>
<pre><code class="language-cpp">void MergePass(int SR[],int TR[],int s,int n)
{
	int i=1;
	int j;
	while(i&lt;=n-2*s+1)
	{
		Merge(SR,TR,i,i+s-1,i+2*s-1);       //两两归并
		i=i+2*s;
	}
	if(i&lt;n-s+1)         //归并最后两个序列
		Merge(SR,TR,i,i+s-1,n);
	else
		for(j=i; j&lt;=n; j++)
			TR[j]=SR[j];
}//详见如下图：

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224220712223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224220724375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>非递归归并排序的时间复杂度如下图：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200224220803431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump25">9.7堆排序算法</span></p>
<blockquote>
<p>大顶堆+小顶堆如下图：</p>
</blockquote>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/202002242213116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<blockquote>
<p>如果按照层序遍历的方式给结点从1开始编号，有如下关系：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224221455607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224221554850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>将大顶堆和小顶堆用层序遍历存入数组，如下图：</p>
</blockquote>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20200224221707148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump26">9.7.1堆排序算法</span></p>
<blockquote>
<p>堆排序的基本思想如下：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020022422185751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020022422191275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
堆排序的整体代码：</p>
<pre><code class="language-cpp">//对顺序表L进行堆排序
void HeapSort(SqList *L)
{
	int i;
	for(i=L-&gt;length/2; i&gt;0; i--)         //将原来的数组构建为一个大顶堆
		HeapAdjust(L,i,L-&gt;length);
	
	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224222615378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224222629819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
上述代码中HeapAdjust函数如何实现：</p>
<pre><code class="language-cpp">void HeapAdjust(SqList *L,int s,int m)
{
	int temp,j;
	temp=L-&gt;r[s];
	for(j=2*s; j&lt;=m; j*=2)   //沿关键字较大的孩子结点向下筛选
	{
		if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+1])
			++j;            //j为关键字中较大的记录的下标
		if(temp&gt;L-&gt;r[j])
			break;
		L-&gt;r[s]=L-&gt;r[j];
		s=j;
	}
	L-&gt;r[s]=temp;   //插入
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200224223320292.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223337424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223348267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224223402125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
接下来就是HeapSort函数中正式的排序过程</p>
<pre><code class="language-cpp">	for(i=L-&gt;length; i&gt;1; i--)
	{
		swap(L,1,i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换
		HeapAdjust(L,1,i-1);       //将其重新调整为大顶堆
	}//详见如下图：

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20200224223738871.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>      <span id="jump27">9.7.2堆排序复杂度分析</span></p>
<blockquote>
<p>1.在第一次构建堆的过程中，时间复杂度如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200224224117512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200224224130379.png" alt="在这里插入图片描述" loading="lazy"></p>
<blockquote>
<p>2.在正式排序的过程中，时间复杂度如下：</p>
</blockquote>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20200224224223924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p><span id="jump28">9.9快速排序</span></p>
<blockquote>
<p>1.希尔排序相当于直接插入排序的升级，他们都属于插入排序类<br>
2.堆排序相当于简单选择排序的升级，他们都属于选择排序类<br>
3.快速排序就是冒泡排序的升级，他们都属于交换排序类</p>
</blockquote>
<p>       <span id="jump29">9.9.1快速排序算法</span></p>
<blockquote>
<p>快速思想的思想，如下图：</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200225113932704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
快速排序的代码：</p>
<pre><code class="language-cpp">void QuickSort(SqList *L)
{
	QSort(L,1,L-&gt;length);
}

</code></pre>
<p>QSort函数的代码：</p>
<pre><code class="language-cpp">//对顺序表L中的子序列做快速排序
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if(low&lt;high)
	{
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20200225114522383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>上述代码中Partition函数（将原始数组一分为2的数组）如下：</p>
<pre><code class="language-cpp">//交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置
//此时在他之前的记录均不大于他，在后面的记录均不小于他
int Partition(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		swap(L,low,high);                 //将比枢轴记录小的记录交换到低端
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		swap(L,low,high);                      //将比枢轴记录大的记录交换到高端
	}
	return low;              //返回枢轴所在位置
}//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200225115335261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115345893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115359275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump30">9.9.2快速排序复杂度分析</span><br>
<img src="https://img-blog.csdnimg.cn/202002251156198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225115918926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/202002251159399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>       <span id="jump31">9.9.3快速排序优化</span><br>
               1.优化选取枢轴<br>
                         1.为啥要优化选取枢轴？<br>
<img src="https://img-blog.csdnimg.cn/20200225120248306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200225120308181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>                         2.三数取中法：</p>
<p><img src="https://img-blog.csdnimg.cn/20200225120455867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在Partition函数中的第3行与第4行之间加上如下代码：</p>
<pre><code class="language-csharp">3 int Pivotkey;
	int m=low+(high-low)/2;           //计算数组中间的元素的下标
	if(L-&gt;r[low]&gt;L-&gt;r[high])
		swap(L,low,high);        //交换左端与右端，保证左端较小
	if(L-&gt;r[m]&gt;L-&gt;r[high])
		swap(L,high,m);             //交换中间与右端数据，保证中间较小
	if(L-&gt;r[m]&gt;L-&gt;r[low])
		swap(L,m,low);               //交换中间与左端数据，保证左端较小
	//此时L.r[low]已经是整个序列做左中右三个关键字的中间值
4 pivotkey=L-&gt;r[low];          //还是用子表的第一个记录做枢轴记录
//详见如下图

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020022512114547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
                         3.优化不必要的交换：<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225121325776.png" alt="在这里插入图片描述" loading="lazy"><br>
2.详细代码：</p>
<pre><code class="language-cpp">//快速排序优化算法
int Partition1(SqList *L,int low,int high)
{
	int pivotkey;                          //用子表的第一个记录做枢轴记录
	//这里省略三数取中的代码
	pivotkey=L-&gt;r[low];					//从表的两端交替向中间扫描
	L-r[0]=L-&gt;r[high];              //增加1：叫枢轴关键字备份到L-&gt;r[0]
	while(low&lt;high)
	{
		while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey)
			high--;
		L-&gt;r[low]=L-&gt;r[high];              //增加2：采用的是替换而不是交换
		while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey)
			low++;
		L-&gt;r[high]=L-&gt;r[low];        //增加3：采用的是替换而不是交换
	}
	L-&gt;r[low]=L-&gt;r[0];              //增加4：将枢轴数值替换回L.r[low]
	return low;              //返回枢轴所在位置

</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20200225122008154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         4.优化小数组的排序方案<br>
1.原因如下：<br>
<img src="https://img-blog.csdnimg.cn/20200225122148402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.详见代码：</p>
<pre><code class="language-cpp">#define MAX_LENGTH_INSERT_SORT 7            //数组长度阈值
void QSort(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
		QSort(L,low,pivot-1);             //对低字表递归排序
		QSort(L,pivot+1,high);            //对高子表递归排序
	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20200225122542336.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p>                         5.优化递归的操作<br>
1.原因如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200225122706361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
于是对QSort进行尾递归操作：</p>
<pre><code class="language-cpp">void QSort1(SqList *L,int low,int high)
{
	int pivot;
	if((high-low)&gt;MAX_LENGTH_INSERT_SORT)
	{//当high-low大于常数时用快速排序
		while(low&lt;high)
		{
			pivot=Partition(L,low,high);        //将原来数组一分为2，算出枢轴pivot
			QSort1(L,low,pivot-1);             //对低字表递归排序
			low=pivot+1;              //尾递归			
		}

	}
	else
		InsertSort(L);       //当high-low小于等于常数时用直接插入排序
}//详见如下图

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20200225123002786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第五章笔记（串）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-wu-zhang-bi-ji-chuan/">
        </link>
        <updated>2020-03-01T04:20:53.000Z</updated>
        <content type="html"><![CDATA[<p>5.2<br>
1.串是由零个或多个字符组成的有限序列，又名叫字符串。<br>
2.串中的字符数目n称为串的长度。<br>
3.零个字符的串称为空串，它的长度为0，也可以直接用双引号&quot;&quot;直接括起来。<br>
4.空格串，是包含空格的串。空格串是有长度的，而且可以不止一个空格。<br>
5.子串与主串，串中任意个数的连续字符组成的子序列称为该串的子串，包含子串的串称为主串。<br>
6.子串在主串中的位置就是子串的第一个字符在主串中的序号</p>
<p>5.3串的比较：<br>
1.将两个字符串都从左至右对齐，然后开始比较，字符串的数量可以不同，比较字符串时一一对应，按照ascii码的方式，字母在前的小，到第一个不同字母比较完之后就完。</p>
<p>5.4串的数据结构：</p>
<pre><code class="language-cpp">ADT 串（string）
Data 
	串中元素仅有一个字符组成，相邻的元素具有前驱和后继关系
Operation
	StrAssign (T,*chars): 生成一个其值等于字符串的常量chars的串T
	StrCopy (T,S):串S存在，由串S复制得到串
	ClearString(S): 串s存在，将串清空
	StringEmpty(S):若串S为空，返回true，否则返回false
	StrLength(S):返回串中的元素个数，即串的长度
	StrCompare(S,T):若S&gt;T,返回值&gt;0,若S=T，返回0，若S&lt;T,返回值&lt;0
	Concat(T,S1,S2):用T返回又S1和S2链接而成的新串
	SubString (Sub,S,pos,len):  串s存在，1&lt;=pos&lt;=StrLength(S),且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符起长度为len的子串
	Index (S,T,pos): 串S和T存在，T是非空串, 1&lt;=pos&lt;=StrLength(S)
					若主串S中存在和串T值相同的子串，则返回它在主串S中
					 第pos个字符之后第一次出现的位置，否则返回0
	Replace(S,T,V):  串S,T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重复的子串
	StrInsert(S,pos,T):  串S和T存在，1&lt;=pos&lt;=Strlength(S)+1
						在串S的第pos个字符之前插入串T
	Strlength(S,pos,len): 串S存在，1&lt;=pos&lt;=Strlength(S)-len+1
						`  从串S中删除第pos个字符起长度为len的子串
endADT
</code></pre>
<p>5.4.1index的操作（取主串中，与子串相同的字符串的第一个字符的位置）</p>
<pre><code class="language-cpp">/*T为非空串。若主串s中第pos个字符之后存在于T相等的子串*/
/*则返回第一个这样的子串在S中的位置，否则返回0*/
int Index(String S, String T, int pos)
{
	int n,m,i;
	String sub;
	if(pos&gt;0)
	{
		n=StrLength(S);
		m=Strlength(T);
		i=pos;           //刚开始这个pos不是要所要的位置，不知道也不必说
		while(i &lt;= n-m+1)   //见下图有这代码的解释
		{
			SubString(sub,S,i,m);     //取主串第i个位置
										//长度与T相等子串给sub
			if(StrCompare(sub, T) !=0 )   //如果两个串不相等
				++i;
			else                  //如果两串相等
				return i;  			//则返回i值
		}
		
	}
	return 0;    //若无子串与T相等，返回0
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227210942916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的顺序存储结构：<br>
<img src="https://img-blog.csdnimg.cn/20191227211456716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
串的链式存储结构：没有占满的位置，可以用其他非字符替代<br>
<img src="https://img-blog.csdnimg.cn/20191227211514657.png" alt="在这里插入图片描述" loading="lazy"><br>
、<br>
5.6朴素的模式匹配法：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
//T非空，1&lt;=pos&lt;=Strlength(S)
int Index(String S, String T, int pos)
{
	int i=pos;        //i主要用于主串s中当前位置的下标，若pos不为1
						//则从pos位置开始匹配
	int	j=1;					 //j用于子串T中当前位置下标值
	while(i &lt;= S[0] &amp;&amp; j &lt;= T[0])    //若i小于s长度且j小于T的长度时循环
	{
		if(S[i] == T[j])      //两个字母相等则继续
		{
			++i;
			++j;
		}
		else        //指针后退重新开始匹配
		{
			i=i-j+2;    //i退回到上次匹配首位的下一位,详细看下图1处
			j=1;     //j退回到子串T的首位
		}
	}
	if(j&gt;T[0])   //上面的while结束有两种情况，i&gt;S[0] 或者  j&gt;T[0] 当i&gt;S[0]一定没有对应的字符串匹配，当j&gt;T[0]时，表示走完了字串，找到了相对应的
		return i-T[0];      //详细看下图2处
	else
		return 0;
}
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20191227220444240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
朴素算法的时间复杂度：<br>
<img src="https://img-blog.csdnimg.cn/20191229233628356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20191229233657400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>5.7KMP模式匹配法<br>
1.kmp算法的普遍理解：如下图，kmp算法的使用前提是T串中的首字符a与后面的均不相等，由于a到e子串T与主串S都对应相同，所以下一次直接比较a与f即可，这便是kmp的引入<br>
<img src="https://img-blog.csdnimg.cn/20191230202900263.png" alt="在这里插入图片描述" loading="lazy"><br>
2.实际上，j的回溯位置的变化与主串S没有什么关系，主要是看子串T中是否有相同的字符，如下图中不用在比较a,b,<br>
j从6回溯到j=3<br>
<img src="https://img-blog.csdnimg.cn/20191230203551303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关于j的回溯的数组next的原理：如下图<br>
<img src="https://img-blog.csdnimg.cn/20191230203909316.png" alt="在这里插入图片描述" loading="lazy"><br>
这里对于5这个位置下要看前4个字符，第一个a与最后一个a相同，相同字母只有一个，所以5下就写2<br>
这里对于6这个位置下要看前5个字符，前两个字符ab与最后两个字符ab完全相同，所以6下就写3<br>
如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191230204256407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
j回溯位置下标的数组：</p>
<pre><code class="language-cpp">//通过计算返回子串T的next数组
void get_next (String T, int *next)
{
	int i,j;
	i=1;             
	j=0;               
	next[1]=0;
	while(i&lt;T[0])        //此处T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])
		{
			++i;
			++j;
			next[i]=j;       //将j回溯的位置保存到next中
		}
		else
			j=next[j];          //j回溯到对应位置
	}
}
</code></pre>
<p>下面是KMP的整体代码：</p>
<pre><code class="language-cpp">//返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0
int Index_KMP(String S, String T, int pos)
{
	int i=pos;       //i就是那里的代码值不同就从哪里开始，如图5-7-3 i为6就从6开始
	int j=1;       //j用于当前位置中下标值
	int next[255];    //定义一next数组
	get_next(T,next);   //对串做分析，得到next数组
	while(i &lt;= s[0] &amp;&amp; j &lt;= T[0])   //若i小于s的长度且j小于且小于T的长度时，循环继续
	{
		if(j==0 || s[i]==T[j])    //两个字母相等则继续，相对于朴素算法增加了j=0判断
		{
			++i;
			++j;
		}
		else
		{
			j=next[j];    //如果字母不相同，则j的值回溯
		}
	}
	
//后面两行代码和朴素算法相同
	if(j&gt;T[0])    
		return i-T[0];
	else
		return 0;
	
}
</code></pre>
<p>kmp算法的时间复杂度分析：<br>
在这里，创建next数组时间复杂度为o(m)，后面的时间复杂度为o(n)，则整体的时间复杂度为o(m+n)<br>
kmp的核心思路：如果子串中一前一后有相同的字符，后面的字符不管与主串中是相同还是不同，对于前面的字符在往后走时不用在与之前</p>
<p>5.7.4kmp模式匹配算法的改进</p>
<pre><code class="language-cpp">//求模式串T的next函数修正值并存入数组nextval，整个nextval还是以计算next的方法来构建，区别在于数值不同，目的就是减少j的回溯次数，以减少复杂度
void get_nextval(String T, int *nextval)
{
	int i,j;
	i=1;
	j=0;
	nextval[1]=0;
	while(i&lt;T[0])           //T[0]表示串的长度
	{
		if(j==0 || T[i]==T[j])       //T[i]表示后缀的单个字符，T[j]表示前缀的单个字符
		{
			++i;
			++j;
/* 这里的代码是改进后不同于之前的next算法
			if(T[i]!=T[j])   //若当前字符与前缀字符不同
				nextval[i]=j;		//就将next中的值给nextval
			else
				nextval[i]=nextval[j];  //字符相同,nextval与之前相同字符所对应的nextval值相同
*/
		}
		else
			j=nextval[j];      //相当于计算next数组中的值，只是改了个名，就这样理解
	}
}
</code></pre>
<p>5.7.4 kmp算法的改进<br>
1.相对于之前的kmp算法j的回溯位置变化太多，而改进后，j回溯的变化位置不多，这里应该是T中有太多连续字符相同的情况下<br>
next数组中，数字不同的程度与j回溯到不同位置的次数成正比，数字越复杂，回溯的次数越多，时间复杂度越大。<br>
2.nextval[]数组变化是：第一数组值为0，往后每一个数组值，如果串中的字符与next数组中对应位置的字符相同，则nextval中的值也与对应位置的nextval相同，如果不同则nextval值就是next值<br>
<img src="https://img-blog.csdnimg.cn/20191230223215549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第六章笔记（树）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-liu-zhang-bi-ji-shu/">
        </link>
        <updated>2020-03-01T04:20:04.000Z</updated>
        <content type="html"><![CDATA[<p>6.2树的定义：<br>
1.树是n个结点的有限集，n=0时称为空树<br>
2.有且仅有一个特定的根<br>
3.子树的个数没有限制，但他们一定是不相交，如下图，就不是子树<br>
<img src="https://img-blog.csdnimg.cn/20191231202354754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.结点拥有的子树数称为结点的度。度为0的结点称为叶节点；度不为0的结点称为分支结点。除根节点之外，分支节点也称内部结点；树的度是树内各结点的度的最大值，如下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203344509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.3结点间的关系：<br>
1.结点的祖先是从根到该结点所经分支上的所有结点 对于H而言ABD都为他的祖先。其他各种关系见下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203245223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.树的相关概念，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203808831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.树与线性表之间的差别，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203824606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.3树的抽象数据类型，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231204652847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4树的存储结构=== 双亲表示法<br>
1.除了根节点啊外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲<br>
2.以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置，结构如下：</p>
<pre><code class="language-bash">data parent  //data是数据域，存储结点的数据信息。parent是指针域，存储该结点的双亲在数组中的下标
</code></pre>
<p>双亲表示法的结点结构定义代码：</p>
<pre><code class="language-cpp">//树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定位整型
typedef struct PTNode   //结点结构
{
	TElemType data;   //结点数据
	int parent;        //双亲位置
}PTNode;
typedef struct       //树的结构
{
	PTNode nodes[MAX_TREE_SIZE];   //结点数组
	int r,n;         //根的位置和结点数
}
</code></pre>
<p>上面的代码对应下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231210350239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进1：在结点中加入左孩子：<br>
<img src="https://img-blog.csdnimg.cn/20191231210401533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进2：在结点中加入有兄弟：<br>
<img src="https://img-blog.csdnimg.cn/20191231210410793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.2孩子表示法：由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表法：如下图，有两种方案：<br>
方案一：<br>
指针域的个数就是树的度，树的度是树中各个结点度的最大值，结构如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213303600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
方案2：<br>
每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213251681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
重点是如下：<br>
孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个维数组中，如图</p>
<pre><code class="language-cpp">//树的孩子表示法结构定义：
#define MAX_TREE_SIZE 100
typedef struct CTNode   //孩子结点
{
	int chile;  //数据域：用来存储某个结点在表头数组中的下标
	struct CTNode *next;  //指针域：存储指向某结点另一个孩子结点的指针
}*ChildPtr;
typedef struct 
{
	TElemType data;  //存储某结点的数据信息
	ChildPtr firstchild; //存储该结点的孩子链表的头指针
}CTBox;
typedef struct     //树结构
{
	CTBox nodes[MAX_TREE_SIZE];  //结点数组
	int r,n;        //根的位置和结点数
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2019123121443736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
双亲表示法和孩子表示法综合，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231214837104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.3孩子兄弟表示法：<br>
结点结构如下图：<br>
firstchild 为指针域，存储该结点的第一个孩子存储地址<br>
<img src="https://img-blog.csdnimg.cn/2019123121564494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
结构定义代码如下：</p>
<pre><code class="language-cpp">//树的孩子兄弟表示法结构定义：
typedef struct CSNode
{
	TElemType data;
	struct CSNode *fitstchild, *rightsib;
}CSNode, *CSTree;
</code></pre>
<p>上面代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231215849928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.5二叉树<br>
1.如图便是二叉树，不能有3个结点：<br>
<img src="https://img-blog.csdnimg.cn/20191231220217170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">6.5.1二叉树特点：<br>
1.每个结点最多有两颗子树<br>
2.左子树与右子树是有顺序的，次序不能任意颠倒<br>
3.即使树中某结点只有一颗树，也要区分它是左子书还是右子树</p>
<p>二叉树的五种基本形态：<br>
1.空二叉树<br>
2.只有一个根节点<br>
3.根结点只有左子树<br>
4.根结点只有右子树<br>
5.根结点既有左子树又有右子树</p>
<p>6.5.2特殊二叉树<br>
1.斜树，满二叉树，完全二叉树 以及 满二叉树的特点和完全二叉树的特点，：如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101205140586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101205158141.png" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205220907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树与满二叉树的关系：<br>
<img src="https://img-blog.csdnimg.cn/20200101205227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200101205248318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
满二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205312212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.6二叉树的性质：<br>
1.某一层上最多有多少个结点<br>
<img src="https://img-blog.csdnimg.cn/20200101210138616.png" alt="在这里插入图片描述" loading="lazy"><br>
2.深度为k的二叉树最多有几个结点：<br>
<img src="https://img-blog.csdnimg.cn/20200101210128770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.n0表示度为0的结点个数，n1表示度为1的结点的个数，n2表示度为2的结点的个数<br>
<img src="https://img-blog.csdnimg.cn/20200101210056806.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210115437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.完全二叉树的深度<br>
<img src="https://img-blog.csdnimg.cn/20200101210030592.png" alt="在这里插入图片描述" loading="lazy"><br>
5.对于根结点，左孩子，右孩子的判定方法：<br>
<img src="https://img-blog.csdnimg.cn/20200101210019979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.7.1二叉树的顺序存储结构：<br>
用数组存放，没有就像倒V表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101210629187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210615923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.7.2二叉链表：<br>
用链式存储结构来存放二叉树，设计一个数据域，两个指针分别指向左孩子和右孩子，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101211952142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>二叉链表的结点结构定义：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode        //结点结构
{
	TElemType data;       //结点数据
	struct BiTNode *lchild, *rchild;    //左右孩子指针
}BiTNode, *BiTree;
</code></pre>
<p>结构示意图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200101211934670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.2二叉树4中遍历方法：<br>
1.前序遍历法<br>
2.中序遍历法<br>
3.后序遍历法<br>
4.层序遍历法</p>
<p><img src="https://img-blog.csdnimg.cn/20200101212151521.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101212228822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.3前序遍历法：</p>
<pre><code class="language-cpp">//二叉树的前序遍历递归算法
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	printf(&quot;%c&quot;,T-&gt;data);      //显示结点数据，可以更改为为其它节点的操作
	PreOrderTraverse(T-&gt;lchild);     //先遍历左子树
	PreOrderTraverse(T-&gt;rchild);        //最后遍历右子树
}
</code></pre>
<p>按照如下的顺序访问：<br>
<img src="https://img-blog.csdnimg.cn/20200101212935308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010121295030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213004977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213046165.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.4中序遍历算法代码：</p>
<pre><code class="language-cpp">//二叉树的中序遍历递归算法
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	InOrderTraverse(T-&gt;lchild);    //中序遍历左子树
	printf(&quot;%c&quot;,T-&gt;data)         //显示节点数据，可以更改为其他对结点操作
	InOrderTraverse(T-&gt;rchild);     //最后中序遍历右子树
}
</code></pre>
<p>中序遍历结点示意图：<br>
<img src="https://img-blog.csdnimg.cn/20200101213810373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.5后续遍历法代码：</p>
<pre><code class="language-cpp">//二叉树后序遍历递归算法：
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	PostOrderTraverse(T-&gt;lchild);   //先后序遍历左子树
	PostOrderTraverse(T-&gt;rchild);    //后序遍历右子树
	printf(&quot;%c&quot;,T-&gt;data);       //显示结点数据，可以更改为对其他结点操作
}
</code></pre>
<p>6.9二叉树的建立：<br>
1.扩展二叉树：将二叉树中每个结点的空指针引出一个虚节点，其值为以特定值，比如&quot;#&quot;，称这种处理后的二叉树为原二叉树的扩展二叉树。如下图：</p>
<p>2.把前序遍历序列：AB#D##C##用键盘诶个输入，代码如下：<br>
也可以用中序或后序遍历的方法实现<br>
中序：输入顺序为#B#D#A#C#      对应代码顺序为：构造左子树—》生成结点-》构造右子树<br>
后序：输入顺序为###DB##CA     对应代码顺序为： 构造左子树-》构造右子树-》生成结点</p>
<pre><code class="language-cpp">//按前序输入二叉树中结点的值（一个字符）
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BiTree *T)
{
	TElemType ch;
	scanf(&quot;%c&quot;, &amp;ch);
	if(ch==&quot;#&quot;)
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)-&gt;data=ch;     //生成根结点
		CreateBiTree(&amp;(*T)-&gt;lchild);             //构造左子树
		CreateBitree(&amp;(*T)-&gt;rchild);            //构造右子树
	}
}

</code></pre>
<p>6.10线索二叉树<br>
以中序遍历为例：下面二叉树中中序遍历的结果为：HDIBJEAFCG<br>
线索二叉树的实质：将二叉链表中的空指针改为指向前驱或后继的线索。<br>
<img src="https://img-blog.csdnimg.cn/202001022049073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将rchild改为后继，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204323143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将lchild改为它的前驱，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204350104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
整个二叉树的中序遍历结果中的前驱后继关系如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204638116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>将lchild,ltag,data,rtag,rchild组合成一个结构，如下图：<br>
具体如下：<br>
ltag为0表示指向该节点的左孩子，为1表示指向该节点的前驱<br>
rtag为0表示指向该结点的右孩子，为1指向该结点的后继<br>
<img src="https://img-blog.csdnimg.cn/20200102204422155.png" alt="在这里插入图片描述" loading="lazy"><br>
二叉树的搜索存储结构定义</p>
<pre><code class="language-cpp">//二叉树的二叉搜索存储结构定义
typedef enum{Link,Thread} PointerTag;         //Link==0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索
typedef struct BiThrNode           //二叉搜索存储结点结构
{
	TElemType data;
	struct BiThrNode *lchild, *rchild;        //左右孩子指针
	PointerTag LTag;                 //左右标志            
	PointerTag RTag;      
}BiThrNode, *BiThrTree;

												

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200102204454222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>中序遍历线索化递归函数代码：(构建线索二叉树)<br>
可以根据上图二叉树来理解</p>
<pre><code class="language-cpp">//中序遍历进行中序线索化
void InThreading(BiThrTree p)
{
	InThreading(p-&gt;lchild);             //递归左子树线索化
	if(!p-&gt;lchild)                //没有左孩子
	{
		p-&gt;LTag=Thread;                   //将LTag改为1
		p-&gt;lchild=pre;               //左孩子指针指向前驱
	}
	if(!pre-&gt;rchild)
	{
		pre-&gt;RTag=Thread;                    //将RTag改为1，为了理解见下图
		pre-&gt;rchild=p;                //前驱右孩子指针指向后继(当前结点p)
	}
	pre=p;                       //保持pre指向p的前驱
	InThreading(p-&gt;rchild);           //递归右子树线索化
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200102214224564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
二叉线索树的遍历，见下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102220110750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
遍历代码如下：</p>
<pre><code class="language-cpp">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T
Status InOrderTraverse_Thr(BiThTree T)
{
	BiThrTree p;
	p=T-&gt;lchild;             //p指向根结点
	while(p!=T)               //空树或遍历结束时，p==T
	{
		while(p=&gt;LTag==Link)            //当LTag==0时循环到中序序列的第一个结点
			p=p-&gt;lchild;
		printf(&quot;%c&quot;,p-&gt;data);           //显示结点数据，可以更改为其他对结点的操作
		while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)
		{
			p=p-&gt;rchild;                  //p中RTag是1表示存放的是他的后继结点
			printf(&quot;%c&quot;,p-&gt;data); 
		}
		p=p-&gt;rchild;            //p中RTag是0表示，p进入他的右子树  区分上面的
	}
	return OK;
}

</code></pre>
<p>如果所用二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，采用线索二叉树的存储结构</p>
<p>6.11.1树转换为二叉树<br>
1.加线。在所有兄弟节点之间加一条线<br>
2.去线。 就是按照你的思路去就对<br>
3.层次调整。 以树的根结点为轴心，顺时针旋转，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来为结点的右孩子<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103194908705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.2将森林转换为二叉树：<br>
1.将每个树按照上面的方法转化成二叉树<br>
2、第一棵树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103195444927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.3二叉树转化为树<br>
1.将结点的左孩子n个右孩子，用线连接起来<br>
2.删除原二叉树中所有结点与其右孩子结点的连线<br>
3.层次调整。  如果只有一个孩子，就直接转化为竖线即可<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103200346330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.4二叉树转化为森林：<br>
1.从根结点开始，若右孩子存在则删除连线，若右孩子存在则删除连线，只要有右孩子就把连线删了<br>
2.再将每棵二叉树转化成树<br>
<img src="https://img-blog.csdnimg.cn/20200103201021824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.5.森林的遍历：<br>
1.前序遍历：一颗树接着一棵树来，每棵树都用先序遍历法，对于上图的二叉树的遍历结果为：ABCDEFGHJI<br>
2.后序遍历：还是一棵树接着一棵树来，每棵树都用后序遍历法，对于上图的二叉树的遍历结果为：BCDAFEJHIG<br>
对于上图而言，森林的前序遍历法和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历法相同。</p>
<p>6.12赫夫曼树及其应用：<br>
树的路径长度表示从根结点到每一个结点的长度总和，如下图中二叉a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+2+3+3+1+2+2=16<br>
<img src="https://img-blog.csdnimg.cn/20200103204819966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
带权路径长度wpl最小的二叉树称作赫夫曼树，上图中二叉树a的wpL=5<em>1+15</em>2+40<em>3+30</em>4+10<em>4=315 ，二叉树b的wpl=40</em>2+15<em>3+5</em>3+30<em>2+10</em>2=220</p>
<p>6.12.2最优赫夫曼树构造方法：<br>
1.将把有权值的叶子结点按照从小到大的顺序排成一个有序列<br>
2.取头两个最小权值的结点之和作为一个新的结点，注意较小的为新的结点的左孩子，每次如此重复，直至结束。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103210711134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210742955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210759426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
赫夫曼编码：<br>
根据赫夫曼树左0右1，对应每个字符编码。这样可以将字符串的长度变少，同样解码也是根据表6-12-3表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103213334549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[大话数据结构第七章笔记（图）]]></title>
        <id>https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/</id>
        <link href="https://wsf123sd.github.io/post/da-hua-shu-ju-jie-gou-di-qi-zhang-bi-ji-tu/">
        </link>
        <updated>2020-03-01T04:18:59.000Z</updated>
        <content type="html"><![CDATA[<p>1.图的定义G（V,E）其中G表示一个图，V表示图G中顶点集，E表示图G中边的集合<br>
2.线性表中数据元素叫元素，树中数据元素叫结点，在图中数据元素称为顶点<br>
3.线性表中没有数据元素称为空表，树中没有数据元素称为空树，在图的结构中，不允许没有顶点<br>
4.在线性表中相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，在图中，任意两个顶点可能有关系，顶点之间的逻辑关系用边来表示。</p>
<p>7.2.1各种图的定义：<br>
1.如下图 7-2-2是无向图G1=(V1,{E1})，其中顶点集合V1={A,B,C,D}   边集合={(A,B),(B,C),(C,D),(D,A),(A,C)}其中边之间用()来表示<br>
2.如下图7-2-3，是有向图G2=(V2,{E2})， 顶点集合V2={A,B,C,D}  弧集合E2={&lt;A,D&gt;,&lt;B,A&gt;,&lt;C,A&gt;,&lt;B,C&gt;} A是弧头，D是弧尾 。无向边用()表示，有向边用&lt;&gt;表示<br>
<img src="https://img-blog.csdnimg.cn/2020010619471683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.无向完全图：任意两顶点之间都存在边。含有n个顶点的无向完全图有n*(n-1)/2条边<br>
4.有向完全图：任意两定点之间存在方向相反互为相反的两条弧，含有n个顶点的有向完全图有n*(n-1)条边<br>
5.无向图：边数就是各顶点度数之和的一半<br>
6.有向图：某顶点的度数=出度数+入度数；所有顶点的入度数之和=所有顶点的出度数之和=边数；<br>
7.路径长度：路径上的边或弧的数目，图7-2-9中上方两条路径长度为2，下放两条路径长度为3；图7-2-10中左侧路径长为2，右侧路径长度为3<br>
<img src="https://img-blog.csdnimg.cn/20200106200638165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
8.回路，简单路径，简单回路：<br>
能从出发点绕了一圈又回到出发点，称为回路或环；<br>
序列中顶点不重复出现的路径称为简单路径。<br>
除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路。<br>
如图7-2-11中，左侧的回路是简单回路，右侧的环是不是简单回路，因为c重复了。<br>
<img src="https://img-blog.csdnimg.cn/20200106200657617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
9.若无重复的边或顶点到自身的边则叫简单图，如下图，就不是简单图：<br>
<img src="https://img-blog.csdnimg.cn/20200106204054344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>7.2.3连通图：任意两点之间都是连通的<br>
无向图中的极大连通子图称为连通分量：</p>
<ul>
<li>要是子图</li>
<li>子图是连通的</li>
<li>连通子图含有极大顶点数</li>
<li>具有极大顶点数的连通子图包含依附于这些顶点的所有边<br>
如图7-2-12,图1不是连通图，图2，图3都是子图且都连通，但图4不是连通分量，因为他只有3个顶点<br>
<img src="https://img-blog.csdnimg.cn/20200106201713177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200106201724638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></li>
</ul>
<p>7.2.3.2强连通图：有向+连通图<br>
图中有子图，若子图极大连通就是连通分量，有向的就是强连通分量，如下图中图1不是强连通图，图2是强连通图，同样图2是图1的强连通分量<br>
<img src="https://img-blog.csdnimg.cn/20200106202052518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.3连通图的生成树：包含图中全部的n个顶点，但只有足以构成一棵树的n-1条边，如图2.图3；如果有n个顶点，但是小于n-1条边则是非连通图；如果边多于n-1，则构成环，如图2,3任意给两个顶点之间一条边，就构成环；不过有n-1条边并不一定是生成树，如图4。<br>
<img src="https://img-blog.csdnimg.cn/20200106202847268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.2.3.4<br>
如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗有向树。<br>
一个有向图的生成森林由若干课有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧，如下图中，图1是有向图，	去掉弧之后，分解为两个有向树，如图2 图3，这两颗就是图1的有向图的生成森林。<br>
<img src="https://img-blog.csdnimg.cn/20200106203812838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.3图的抽象数据类型：<br>
<img src="https://img-blog.csdnimg.cn/20200106204941634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.4图的五种存储结构：<br>
一.邻接矩阵：<br>
1.图的邻接矩阵存储方式用两个数组来表示图，一个一维数组存储图中顶点信息，一个二维数组存储图中的边或弧的信息。<br>
2.无向图的邻接矩阵的特点：<br>
a.矩阵是关于主对角线对称的<br>
b.Vi顶点的度=第i行或者第i列上的元素之和<br>
c.Vi的所有邻接点就是将矩阵中第i行元素扫描一遍，数组元素为1就是邻接点<br>
d.主队角线上元素为0<br>
<img src="https://img-blog.csdnimg.cn/20200106211104874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.有向图的邻接矩阵的特点：<br>
a.不是对称矩阵<br>
b.主队角线上元素为0<br>
c.顶点Vi的入度为第Vi列各数之和；出度数为第Vi行各数之和<br>
d.判断Vi到Vj是否存在弧，只需要查找矩阵中元素是否为1<br>
e.要求Vi的所有邻接点就是将第i行元素扫描一遍，查找矩阵中元素为1的点<br>
<img src="https://img-blog.csdnimg.cn/20200106211123418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.对于边上的权值而言，如果不存在则为无穷；自身到自身的度为矩阵元素为0,<br>
<img src="https://img-blog.csdnimg.cn/20200106211145807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
5.图的邻接矩阵存储的结构：</p>
<pre><code class="language-cpp">typedef char VertexType;              //顶点类型应由用户定义
typedef int EdgeType;                //边上的权值类型应由用户定义
#define MAXVEX 100               //最大顶点数
#define INFINITY 65535          //用65535来表示无穷
typedef struct 
{
	VertexType vexs[MAXVEX];            //顶点表
	EdgeType arc[MAXVEX][MAXVEX];           //邻接矩阵，
	int numVertexes, numEdges;         //图中当前顶点数和边数
}MGraph;
</code></pre>
<p>6.构造一个无向图</p>
<pre><code class="language-cpp">//建立无向图的邻接矩阵
void CreateMGraph(MGraph *G)
{
	int i,j,k,w;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;, &amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);     //输入顶点数，边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)            //读入顶点信息，建立顶点表
		scanf(&amp;G-&gt;vexs[i]);
	for(i=0; i&lt;G-&gt;numVertexes; i++)
		for(j=0; j&lt;G-&gt;numVertexes; j++)
			G-&gt;arc[i][j]=INFINITY;            //邻接矩阵初始化
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的下标i，下标j和权w:\n&quot;);
		scanf(&quot;%d,%d,%d&quot;,&amp;i,&amp;j,&amp;w);    //输入边(Vi,Vj)上的权W
		G-&gt;arc[i][j]=w;
		G-&gt;arc[i][j]=G-&gt;arc[i][j];      //因为是无向图，矩阵对称
	}
//时间复杂度为o(n+n^2+e):n个顶点，e条边 最终为o(n^2)
}
</code></pre>
<p>二.邻接表：<br>
1.顶点用一维数组来存放，另外，对于顶点数组中，每个数据元素还需要存储指向第一个邻接点的指针；每个顶点的所有邻接点构成一个线性表，用单链表存储<br>
2.第Vi个顶点的度，就去查这个顶点的边表中结点的个数<br>
3.要判断Vi与Vj之间是否存在边，只需要测试顶点Vi的边表中是否存在结点Vj的下标j就行<br>
4.若要求顶点的所有邻接点，就对此顶点的边表进行遍历，得到的就是邻接点。见下图7-4-6<br>
5.有向图的逆邻接表，就是看谁往这个点里干，如下图7-4-7(2)<br>
6.有向图的邻接表，如下图7-4-7（1）<br>
7.带权值的邻接表，如下图7-4-8<br>
<img src="https://img-blog.csdnimg.cn/20200106215146181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621520519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010621522774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
邻接表结点定义的代码：</p>
<pre><code class="language-cpp">typedef char VertexType;             //顶点类型由用户定义
typedef int EdgeType;                 //边上的权值类型由用户定义

typedef struct EdgeType          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}GraphAdjList；
</code></pre>
<p>无向图的邻接表创建代码：</p>
<pre><code class="language-cpp">//建立图的邻接表结点
void CreateALGraph (GraphAdjList *G)
{
	int i,j,k;
	EdgeNode *e;
	printf(&quot;输入顶点数和边数:\n&quot;);
	scanf(&quot;%d,%d&quot;,&amp;G-&gt;numVertexes,&amp;G-&gt;numEdges);        //输入顶点数和边数
	for(i=0; i&lt;G-&gt;numVertexes; i++)          //读入顶点信息，建立顶点表
	{
		scanf(&amp;G-&gt;adjList[i].data);       //输入顶点信息
		G-&gt;adjList[i].firstedge=NULL;        //将指向边表的头结点置为空
	}
	for(k=0; k&lt;G-&gt;numEdges; k++)
	{
		printf(&quot;输入边(Vi,Vj)上的顶点序号:\n&quot;);
		scanf(&quot;%d,%d&quot;,&amp;i,&amp;j);          //输入边（vi,vj）上的顶点序号
		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=j;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[i].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[i].firstedge=e;          //把e这个结点在放回头结点 

		e=(EdgeNode *)malloc(sizeof(EdgeNode));        //向内存申请空间 , 生成边表结点
		e-&gt;adjvex=i;             //邻接序号为j
		e-&gt;next=G-&gt;adjList[j].firstedge;       //头插法每次将新的结点连接到顶点表结点的后面的结点
		G-&gt;adjList[j].firstedge=e;          //把e这个结点在放回头结点 
	}
}
时间复杂度为o(n+e)=o(n)  //n个顶点，e条边
</code></pre>
<p>第三种：十字链表：就是将邻接表和逆邻接表相结合方便了解结点的出度和入度<br>
1.重新定义顶点表结点结构，如下图，<br>
firstin 表示入边表头指针，指向该顶点的入边表中第一个结点<br>
firstout 表示出边表指针，指向该顶点的出边表中的第一个结点<br>
<img src="https://img-blog.csdnimg.cn/20200107202857870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义边表结点结构，如下图：<br>
tailvex是指弧起点在顶点表的下标<br>
headvex是指弧终点在顶点表中的下标<br>
headlink是指边表指针域，指向终点相同的下一条边<br>
taillink 是指边表指针域，指向起点相同的下一条边<br>
<img src="https://img-blog.csdnimg.cn/20200107202912422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200107204325664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
v0中firstout指向它自己的边表结点，后面那个边表结点中03表示从0开始走到3；v0中fistrtin表示V1走向它，他犯贱再走向v1，v0再也没有可走的下一个结点，所以taillink为NULL；v0走向v3，没有人与他一样再走向v3所以headlink为NULL<br>
v1中firstou指向自己的边表结点，后面10 。12分别表示从v1走向V0，从v1走向V2；所以v1第一个边表结点中taillink指向下一个，由于1走向0,2也走向0，所以v1中第一个边表结点走到v2中第一个边表结点；同样V2走向V1，v1犯贱它的fisttin指向V2中第2个边表结点<br>
v2也是如此，重点强调由于v2走向v0，没有人再走向v0所以v2中第一个边表结点的healink为空</p>
<p>第四种：邻接多重表<br>
1.如果要删除边，则对于下图的邻接表而言太复杂对于结点而言改动太多<br>
<img src="https://img-blog.csdnimg.cn/20200107210841424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.重新定义如下结构：<br>
ivex和jvex表示与某条边依附的两个顶点在顶点表中的下标。<br>
ilink指向依附顶点ivex的下一条边。<br>
jlink指向依附顶点jvex的下一条边</p>
<p><img src="https://img-blog.csdnimg.cn/20200107211110577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010721132679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
1-4表示连接它自己的边表结点<br>
5表示依附于v0的下一条边：v0--v3   6表示依附于v0的下一条边：v0--v2  7表示依附于v1的下一条边：v1--v0<br>
8表示依附于v2的下一条边：v2--v3  9表示依附于v2的下一条边：v2--v0  10表示依附于v2的下一条边：v3--v2</p>
<p>第五种：边集数组：<br>
如下图，就能看懂</p>
<p><img src="https://img-blog.csdnimg.cn/20200107212244138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.5.1深度优先遍历：<br>
1.简称DFS，说白了就是遍历图中每个顶点然后，所有路径都走一遍。遍历过的顶点做好标记就不在遍历<br>
邻接矩阵的DFS代码如下：</p>
<pre><code class="language-cpp">typedef int Boolean;        //Boolean是布尔类型，其值是TRUE或FALSE
Boolean visited[MAX];       //访问标志的数组
//邻接矩阵的深度优先递归算法
void DFS(MGraph G, int i)
{
	int j;
	visited[i]=TRUE;
	printf(&quot;%c&quot;,G.vexs[i]);              //vexs【】表示顶点数组
	for(j=0; j&lt;G.numVertexes; j++)
			if(G.arc[i][j]==1 &amp;&amp; !visited[j])   //arc表示边表数组，1表示两个点之间有值
				DFS(G,j);          //对访问的邻接顶点递归调用
}
//邻接矩阵的深度遍历操作
void DFSTraverse(MGraph G)
{
	int i;
	for(i=0; i&lt;G.numVeretexes; i++)
		visited[i]=False;          //初始所有顶点都是未访问过的状态
	for(i=0; i&lt;G.numVertexes; i++)
		if(!visited[i])            //对未访问过的顶点调用DFS
			DFS(G,i); 
}
时间复杂度是o(n^2)
</code></pre>
<p>邻接表的深度优先递归算法：</p>
<pre><code class="language-cpp">void DFS(GraphAdjList GL, int i)
{
	EdgeNode *p;
	visited[i]=TRUE;
	printf(&quot;%c &quot;, GL-&gt;adjList[i].data);           //打印顶点，adjLIst表示顶点结构数组，结构成员有data和fistredge指针
	while(p)
	{
		if(!visited[p-&gt;adjvex])
			DFS(GL,p-&gt;adjvex);          //对访问的邻接顶点递归调用
		p=p-&gt;next;
	}
}

//邻接表的深度遍历操作
void DFSTraverse(GraphAdjList GL)
{
	int i;
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		visited[i]=FALSE:     //初始化所有顶点都是未访问过的
	for(i=0; i&lt; GL-&gt;numVertexes; i++)
		if(!visited[i])     //对访问过的顶点调用DFS
		DFS(GL,i);
}

时间复杂度是o(n+e);
</code></pre>
<p>邻接矩阵的广度遍历算法：简称BFS</p>
<pre><code class="language-cpp">/*邻接矩阵的广度遍历算法*/
void BFSTraverse(MGraph G)
{
    int i,j;
    Queue Q;
    for(i=0; i&lt;G.numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //初始化一辅助队列
    for(i=0; i&lt;G.numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, G.vex[i]);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                for(j=0; j&lt;G.numVertexes; j++)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])
                        {
                            visited[j]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, G.vexs[j]);   //打印顶点
                            EnQueue(&amp;Q,j);        //将找到的此顶点入队列
                        }
                    }
            }
        }
    }
}
</code></pre>
<p>邻接表的广度遍历算法</p>
<pre><code class="language-cpp">/*邻接表的广度遍历算法*/
void BFSTraverse(GraphAdjList GL)
{
    int i;
    EdgeNode *p;     //边表结点
    Queue Q;
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
        visited[i]=FALSE;
    InitQueue(&amp;Q);             //舒适化一辅助队列
    for(i=0; i&lt;GL-&gt;numVertexes; i++)
    {
        if(!visited[i])    //若是未访问过
        {
            visited[i]=TRUE; //设置当前顶点访问过
            printf(&quot;%c &quot;, GL-&gt;adjList[i].data);      //打印顶点，也可以其他从操作
            EnQueue(&amp;Q,i);     //将此顶点入队列
            while(!QueueEmpty(Q))    //若当前队列不为空
            {
                DeQueue (&amp;Q, &amp;i);     //将队中元素出队列，赋值给i
                p=GL-&gt;adjList[i].firstedge; //找到当前顶点边表链表表头指针
                while(p)
                    {
                        /*判断其他顶点若与当前顶点存在边且未访问过*/
                        if(!visited[p-&gt;adjvex])  //若顶点未被访问过
                        {
                            visited[p-&gt;adjvex]=TRUE;     //将找到此顶点标记为一访问
                            printf(&quot;%c&quot;, GL-&gt;adjList[p-&gt;adjvex].data);   //打印顶点
                            EnQueue(&amp;Q,p-&gt;adjvex);        //将找到的此顶点入队列
                        }
                        p=p-&gt;next;     //指针指向下一个邻接点
                    }
            }
        }
    }
}
</code></pre>
<p>深度优先遍历：更适合目标比较明确，已找到目标为主要目的，类似于前序遍历<br>
广度优先遍历：更适合在不断扩大遍历范围时找到相对最优解情况 ，类似于层序遍历</p>
<p>7.6.1Prim算法：<br>
<img src="https://img-blog.csdnimg.cn/20200108213856363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
Prim算法生成最小生成树</p>
<pre><code class="language-cpp">/*Prim算法生成最小生成树*/
void MiniSpanTree_Prim(MGraph G)
{
    int min,i,j,k;
    int adjvex[MAXVEX];     //保存相关顶点下标
    int lowcost[MAXVEX];      //保存相关顶点间边的权值
    
    lowcost[0]=0;      //初始化第一个权值为0，即v0加入生成树
                       //lowcost的值为0，在这里就是此下标的顶点已经加入生成树
    adjvex[0]=0;        //初始化第一个顶点下标为0
    
    for(i=1; i&lt;G.numVertexes; i++)      //循环除下标为0外的全部顶点
    {
        lowcost[i]=G.arc[ 0][i];    //将V0顶点与之有边的权值存入数组
        adjvex[i]=0;     //初始化都为v0的下标
    }
    
    for(i=1; i&lt;G.numVertexes; i++)
    {
        min=INFINITY;         //初始化最小权值为无穷
        j=1;k=0;      //j用来做顶点下标循环的变量，k是用来存储最小权值的顶点下标、
        
        //20--29表示找出最小值min和对应的数组下标k
        while(j&lt;G.numVertexes)    //循环全部顶点
        {
            if(lowcost[j]!=0 &amp;&amp; lowcost[j]&lt;min)
                {
                    //如果权值不为0且权值小于min
                    min=lowcost[j];      //则让当前权值称为最小值
                    k=j;                    //将当前最小值的下标存入k
                }
            j++;
        }
        
        printf(&quot;(%d,%d)&quot;,adjvex[k],k);      //打印当前顶点边中权值最小边,比如打印结果为(0,1),表示V0至v1遍为最小生成树的第一条边
        
        lowcost[k]=0;     //将当前顶点的权值设置为0，表示此顶点已经完成任务
        
        for(j=1; j&lt;G.numVertexes; j++)   //循环所有顶点
        {
            if(lowcost[j]!=0 &amp;&amp; G.arc[k][j] &lt; lowcost[j])
            {
                //若下标为k顶点各边权值小于此前这些顶点未被加入生成树权值
                lowcost[j] = G.arc[k][j];   //将较小权值存入lowcost
                adjvex[j]=k;  //将下表为k的顶点存入adjvex
            }
        }
        
    }
}

</code></pre>
<p>以下便是Prim算法的过程，最终构成n-1条边，遍历完所有顶点，以某顶点为起点，逐步找各顶点上权值最小的边构建最小生成树<br>
<img src="https://img-blog.csdnimg.cn/20200108214446923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214454992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200108214744729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>Krskal算法：求最小生成树<br>
1.将邻接矩阵转化为边集数组：<br>
如下图<br>
<img src="https://img-blog.csdnimg.cn/20200109205012741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-cpp">/*Kruskal算法*/
void MiniSpanTree_Kruskal(MGraph G) //生成最小生成树
{
    int i,n,m;
    Edge edges[MAXEDGE];    //定义边集数组
    int parent[MAXEDGE];   //定义一数组用来判断边与边是否形成环路
    
    //此处省略将邻接矩阵G转化为边集数组edges并按权值由小到大排列的代码
    for(i=0; i&lt;G.numVertexes; i++)
            parent[i]=0;      //初始化数组为0
    for(i=0; i&lt;G.numEdges; i++)  //循环每一条边
    {
        n=Find(parent,edges[i].begin);
        m=Find(parent,edges[i].end);
        if(n!=m)
            {
                parent[n]=m;   //将此边的结尾顶点放入下表为起点的parent中
                                //表示此顶点已经在生成树集合中
                print(&quot;(%d,%d)&quot;,edges[i].begin,edges[i].end,edges[i].weight);
            }
    }
}

int Find(int *parent, int f)  //查找连线顶点的尾部下标
{
    while(parent[f]&gt;0)
        f=parent[f];
    return f;
}
算法中find函数有e决定，时间复杂度为o(loge)，而外面有一个for循序e次，所以时间复杂度为o(eloge)

</code></pre>
<p>具体执行过程如下：<br>
<img src="https://img-blog.csdnimg.cn/20200109205414490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205430984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205507351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205531372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205550570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200109205617883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在E中选择最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此加入到T中，否则舍去此边而选择下一条代价最小的边<br>
k式算法主要针对边来展开，边数少效率非常高，适合稀疏图。p式算法对于稠密图，边数非常多情况会更好<br>
锋说：就是每次找最小的边，不要形成回路，然后最终能将图中所有顶点连接起来<br>
总结：p式算法就是以某个顶点开始找与这个点相关的最小 的边，每次这样寻找；而k式算法就是直接上来找最小的边不形成回路，最终将整个点连起来，他俩都是去找连通图的最小生成树</p>
<p>7.7迪杰斯特拉算法：求最短路径</p>
<pre><code class="language-cpp">#define MAXVEX 9
#define INFINITY 65535
typedef int Patharc[MAXVEX];      //用于存储最短路径下标的数组
typedef int ShortPathTable[MAXVEX];    //用于存储到各个顶点路径权值和
//Dijkstra算法，求有向网G的v0顶点到其余顶点V最短路径p[V]即带权长度D[V]
//P[V]的值为前驱顶点下标，D[V]表示v0到v的最短路径长度和
void ShortestPath_Dijkstra (MGraph G, int v0, Patharc *p, ShortPathTable *D)
{
	int v,w,k,min;
	int final[MAXVEX];   //final[w]=1 表示求得顶点v0至vw的最短路径
	for(v=0; v&lt;G.numVertexes; v++)     //初始化数据
	{
		final[v]=0;
		(*D)[V]=G.arc[v0][v];         //将与v0点有连线的顶点加上权值
		（*p）[v]=0;            //初始化路径数组p为0
	}
	(*D)[v0]=0;     //v0至v0的路径为0
	final[v0]=1;           //v0至v0不需要求路径
	
	//开始主循环，每次求得V0到某个顶点v的最短路径
	for(v=1; v&lt;G.numVertexes; v++)
	{
		min=INFNITY;      //当前所知离v0顶点的最近距离
		
		for(w=0; w&lt;G.numVertexes; w++)    //寻找离v0最近的顶点
		{
			if(!final[W] &amp;&amp; (*D)[W]&lt;min)
			{
				k=w;
				min=(*D)[W];         //w顶点离v0顶点更近
			}
		}
		
		final[k]=1;      //将目前找到的最近的顶点置位1
		
		for(w=0; w&lt;G.numVertexes; w++)    //修改当前最短路径及距离
		{
			//如果经过v顶点的路径比现在这条的路径长度短的话
			if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[W]))
			{
				//说明找到了更短的路径，修改D[W]和p[W]
				（*D)[w]=min+G.arc[k][w];    //修改当前路径长度
				(*p)[w]=k;
			}
		}
	}
}
时间复杂度：o(n^2)

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200110010608603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110010632915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
数组D，数组P含义：上图中比如到v3的最短路径长度是7，比如到v5的最短路径长度是8。。<br>
数组p表示V0-----&gt;V8的最短路径中，P[8]=7表示V8的前驱节点为V7；P[4]=2表示V4的前驱节点是2.。。<br>
如果想要知道任意顶点开始到某结点的最短路径，那就没到一个结点就用一次迪杰斯特拉算法，这 样的复杂度为o(n^3)<br>
<img src="https://img-blog.csdnimg.cn/20200110010656741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：其实迪杰斯特拉算法目的是计算从某个点到某个点的最短路径，思想就是每次找到最短的路径，把他放入到已经找到的路径中，很漂亮的思想</p>
<p>7.7.2.FLoyd算法：求最短路径</p>
<pre><code class="language-cpp">typedef int Pathmatirx[MAXVEX][MAXVEX];
typedef int ShortPathTable [MAXVEX][MAXVEX];
//FLoyd算法，求网图中G中各顶点v到其余顶点w最短路径P[v][w]及带权长度D[v][w]
void ShorttestPath_Floyd(MGraph G, Pathmatirx *P, ShortPathTable *D)
{
	int v,w,k;
	for(v=0; v&lt;G.numVertexes; ++w)
	{
		for(w=0; w&lt;G.numVertexes; w++)
		{
			(*D)[v][w]=G.matirx[v][w];     //D[v][w]值即为对应点间的权值
			(*p)[v][w]=w;                 //初始化p
		}
	}
	for(k=0; k&lt;G.numVertexes; ++k)     //k相当于每次拐出来的点
	{
		for(v=0; v&lt;G.numVertexes; ++v)
		{
			for(w=0; w&lt;G.numVertexes; ++w)
			{
				if((*D)[v][w] &gt; (*D)[v][k]+(*D)[k][w])
				{
					//如果经过下标为k顶点路径比原两点间路径更短
					//将当前两点间权值设为更小的一个
					(*D)[v][w]=(*D)[v][k]+(*D)[k][w];
					(*p)[v][w]=(*p)[v][k];           //路径设置为下标为k的顶点
				}
			}
		}
	}
}   时间复杂度o(n^3)

</code></pre>
<p>最短路径的显示代码</p>
<pre><code class="language-cpp">for(v=0; v&lt;G.numVertexes; ++v)
{
	for(w=v+1; w&lt;G.numvertexes; w++)
	{
		printf(&quot;v%d-v%d weight: %d&quot;,v,w,D[v][w]);  //输出从某个点到某个点的路径权值
		k=p[v][w];       //获得第一个路径顶点的下标
		printf(&quot; path: %d&quot;,v);         //打印原点
		while(k!=w)            //如果路径顶点下标不是终点
		{
			printf(&quot; -&gt; %d&quot;,k);          //打印路径顶点
			k=p[k][w];           //获得下一个路径顶点下标，p数组已经设置好了
		}
		printf(&quot; -&gt; %d\n&quot;,w);     //打印终点
	}
	printf(&quot;\n&quot;);         
}

</code></pre>
<p>上面代码图示：<br>
<img src="https://img-blog.csdnimg.cn/20200110220429452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200110215942248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
矩阵D表示从某个点到某个点的最短路径长度<br>
p矩阵的含义不用知道，只要知道怎么通过此矩阵找到最短路径<br>
以v0--v8<br>
首先p[0][8]=1,表示经过v1<br>
再看v[1][8]=2，表示经过v2<br>
再看v[2][8]=4, 表示经过v4.。。。。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200110220005694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
锋说：迪杰斯特拉算法和弗洛伊德算法的相同与不同：<br>
相同点：<br>
1.都是求某个点到某个点的最短路径<br>
2.核心思路都是不断的找最短的路径归并到已经找到的路径集合中<br>
不同点：<br>
1.D通过min+下一次的路径和直接到达路径长度比较；而F通过拐点k来表示i--&gt;k---&gt;j要比i---&gt;j路径要短<br>
2.最终得到的数组D都是表示vi到vj的最短路径，而p不同，其中D中p只能表示以v0为起点，到其余各点的最短路径；比如要想知道v2，v3...到其余各点的最短路径，只能再次将v2，v3当做源头再次使用D式算法。但是F式算法中p可以知道所有顶点到所有顶点的最短路径</p>
<p>7.8.2拓扑排序：判断工程能否顺利进行<br>
在一个有向图中，就像拍电影有先后顺序，这样的网图称为AOV图，如下所示：<br>
下图中的一个拓扑序列是：v0v1v2v3v4v5v6v7v8v9v10v11v12v13v14v15v16<br>
<img src="https://img-blog.csdnimg.cn/2020011221284919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
而且AOV图不存在回路，所以在输出时如果顶点数少了一个，则说明不是回路，如果顶点被全部输出，则说明它不存在回路。</p>
<p>对AOV网进行拓扑排序的基本思路：<br>
从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为0的顶点为止。<br>
在拓扑排序算法中，涉及的结构代码如下，使用邻接表来构造：</p>
<pre><code class="language-cpp">​```cpp
typedef struct EdgeNode          //边表结点
{
	int adjvex;               //邻接点域，存储该结点对应的下标
	EdgeType weight;           //用于存储权值，对于非网图可以不需要
	struct EdgeNode *next;       //链域，指向下一个邻接点
}EdgeNode;

typedef struct VertexNode      //顶点表结点
{
	int in;
	VertexType data;           //顶点域，存储顶点信息
	EdgeNode *firstedge;             //边表头指针
}VertexNode, AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges;         //图中当前顶点数和边数
}graphAdjList,*GraphAdjList；

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200120200549858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
in表示入度域，下面的邻接表就是表示上图<br>
<img src="https://img-blog.csdnimg.cn/20200120200610526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
拓扑排序的代码：</p>
<pre><code class="language-cpp">//拓扑排序
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		printf(&quot;%d -&gt; &quot;,GL-&gt;adjList[gettop].data);        //打印此顶点
		count++;              //统计输出顶点数
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}
时间复杂度：
第一个for循环，一共n个顶点，时间复杂度为o(n)
下面while，从下图6可以看出，最后删除边都没有了，所以时间复杂度为o(e)
最终时间复杂度为o(n+e)

</code></pre>
<p>具体过程如下：<br>
先从v3开始<br>
<img src="https://img-blog.csdnimg.cn/20200120205711970.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
打印输出v3<br>
<img src="https://img-blog.csdnimg.cn/20200120205731362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
依次类推，如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120205817307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200120205824667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
最终拓扑排序的结果为3-&gt;1-&gt;2-&gt;6-&gt;0-&gt;4-&gt;5-&gt;8-&gt;7-&gt;12-&gt;9-&gt;10-&gt;13-&gt;11，当然这个拓扑排序结果不唯一</p>
<p>7.9关键路径：求完成工程最短的时间问题，利用求出关键路径算法，求出完成工程的最短时间和关键活动有哪些？<br>
1.关键路径用AOE表示，AOV表示活动之间以相互制约关系，而AOE是在AOV的基础上来分析完成整个活动所需的最短时间，如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/20200120210958150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
其中每个AOE网图都有一个源点和汇点<br>
路径长度：路径上各个活动所持续的时间之和称为路径长度<br>
从源点到汇点的具有最大长度的路径叫关键路径，关键路径上的活动叫关键活动<br>
<img src="https://img-blog.csdnimg.cn/20200120211017839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
7.9.1关键路径的算法原理：<br>
放学回家到睡觉，一共4个小时。写作业两个小时，最早开始时间是一回来，可以理解为0。最晚开始时间为2个小时之后，可以理解为2。当最早开始时间和最晚开始时间不相同时，表示有空闲时间。当买了很多的习题时，时间全部被占满，则最早和最晚开始时间为都是0，因此他就是关键活动。<br>
1.事件的最早发生时间etv：即顶点vk的最早发生时间<br>
2.事件的最晚发生时间ltv：即顶点vk的最晚发生时间，如果超过此时间，就会延误整个工期<br>
3.活动最早开工时间ete：即弧ak的最早发生时间<br>
4.活动最晚开工时间lte：即弧ak的最晚发生时间<br>
通过1,2求得3,4，然后根据ete[k]与lte[k]是否相等来判断ak是否为关键活动</p>
<p><img src="https://img-blog.csdnimg.cn/20200201213730233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
下列代码求etv的过程，与拓扑排序类似</p>
<pre><code class="language-cpp">int *etv, *ltv;           //时间最早发生时间和最迟发生时间数组
int *stack2;            //用于存储拓扑排序的栈
int top2;            //用于stack2的的指针

//拓扑排序，用于关键路径计算
Status TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i,k,gettop;
	int top=0;           //用于栈指针下标
	int count=0;          //用于统计输出顶点的个数
	int *stack;          //建栈存储入度为0的顶点
	stack=(int *)malloc(GL-&gt;numVertexes * sizeof(int));
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		if(GL-&gt;adjList[i].in==0)
			stack[++top]=i;                 //将入度为0的顶点入栈
	
	top2=0;           //初始化为0
	etv=(int *)malloc(GL-&gt;numVertexes*sizeof(int));        //事件最早发生的时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		etv[i]=0;             //初始化为0
	stack2=(int *)malloc(GL-&gt;numVertexes*sizeof(int));      //初始化
	
	while(top!=0)       //表示栈指针为0时循环结束，也就是再也没有入度为0的顶点了
	{
		gettop=stack[top--];      //出栈
		count++;              //统计输出顶点数
		stack2[++top2]=gettop;       //将弹出的顶点序号压入拓扑序列的栈
		for(e=GL-&gt;adjList[gettop].firstedge;  e;  e=e-&gt;next)   //此循环就是边表的循环
		{
			//对此顶点弧表遍历
			k=e-&gt;adjvex;
			if(!(--GL-&gt;adjList[k].in))          //将k号顶点的入度域减1
				stack[++top]=k; 					//如果为0则入栈
			if((etv[gettop]+e-&gt;weight)&gt;etv[k])     //求各顶点事件最早发生时间
				etv[k]=etv[gettop]+e-&gt;weight;
		}
	}
	if(count &lt; GL-&gt;numVertexes)    //如果count小于此顶点数，说明存在环
		return ERROR;
	else
		return OK;
}

</code></pre>
<p>上面代码的例子如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200201214810950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
对于v3来说，4+8&gt;3+5，所以v3=12。以此类推<br>
<img src="https://img-blog.csdnimg.cn/20200201214925217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
关键路径的算法代码：</p>
<pre><code class="language-cpp">//求关键路径，GL为有向图，输出GL的各项关键活动
void CriticalPath(GraphAdjList GL)
{
	EdgNode *e;
	int i,gettop,k,j;
	int ete,lte;             //声明活动最早发生时间和最迟发生时间
	TopologicalSort(GL);           //求拓扑序列，计算数组etv和stack2
	ltv=(int *)malloc(GL-&gt;numverteces*sizeof(int));    //事件最晚发生时间
	for(i=0; i&lt;GL-&gt;numVertexes; i++)
		ltv[i]=etv[GL-&gt;numVertexes-1];    //初始化ltv
	while(top2!=0)      //计算ltv
	{
		gettop=stack2[top2--];   //将拓扑序列出栈，后进先出
		for(e=GL-&gt;adjList[gettop].firstedge; e; e=e-&gt;next)
		{
			//求各顶点最迟发生时间ltv
			k=e-&gt;adjvex;
			if(ltv[k]-e-&gt;weight&lt;ltv[gettop])   //求各顶点事件最晚发生时间
				ltv[gettop]=ltv[k]-e-&gt;weight;
		}
	}
	for(j=0; j&lt;GL-&gt;numVertexes; j++)    //求ete,lte和关键活动
	{
		for(e=GL-adjList[j].firstedge; e; e=e&gt;next)
		{
			k=e-&gt;adjvex;        
			ete=etv[j];       //活动最早发生时间
			lte=ltv[k]-e-&gt;weight;   //活动最迟发生时间
			if(ete=lte)                //两者相等即在关键路径上
				printf(&quot;&lt;v%d,v%d&gt; length: %d , &quot;,GL-&gt;adjList[j].data,GL-&gt;adjList[k].data,e-&gt;weight);
		}
	}
}


</code></pre>
<p>上述代码所求etv和ltv如下所示+关键路径如下所示：<br>
<img src="https://img-blog.csdnimg.cn/20200201220607841.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200201220623475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
总结：<br>
etv通过拓扑排序算出最早发生的时间，每次找权值较大的<br>
ltv相当于从后向前算出最晚发生时间，每次找权值较小的<br>
ete=etv[j]表示当事件发生时，最早开工时间（当然必须事件发生，才开工）<br>
lte=ltv[k]-e-&gt;weight表示事件最晚发生的时间-要完成工作的时间（比如23点睡觉，写作业2h，可以23点才开始写但要睡觉所以最晚开工时间是21点，最晚21点开始写，就是这意思，有点牵强，理解即可）</p>
]]></content>
    </entry>
</feed>