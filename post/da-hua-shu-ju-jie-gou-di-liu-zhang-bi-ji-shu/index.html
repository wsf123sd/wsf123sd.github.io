
<html>
  <head lang="zh">
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
        <meta content="yes" name="apple-mobile-web-app-capable"/>
        <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
        <meta content="telephone=no" name="format-detection"/>
        <meta name="renderer" content="webkit">
    <title>大话数据结构第六章笔记（树） | Gridea</title>
<link href="https://wsf123sd.github.io//styles/main.css" type="text/css" rel="stylesheet"/>
<script type="text/javascript" src="https://wsf123sd.github.io//media/scripts/jquery.js"></script>
<script type="text/javascript" src="https://wsf123sd.github.io//media/scripts/basic.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  </head>

  <body>
     <div class="header">
      <div class="logo_title">
		  
        <div class="title animated fadeInDown"><img src="https://wsf123sd.github.io//images/avatar.png?v=1584358020213"/>

          <h1 title="Gridea" class="weaklink"><a href="/">Gridea</a>

          </h1>

          <div class="navbar weaklink">
            <div class="normal_nav">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
		
      <ul class="mixed_site_nav site_nav sm sm-base">
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/" class="selected active current nav__item" >首页</a>

  </li>
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/archives" class="selected active current nav__item" >归档</a>

  </li>
 
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/tags" class="selected active current nav__item" >标签</a>

  </li>
 

      </ul>

      <div class="clear clear_nav_inline_end"></div>

    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

            </div>

            <div class="hamberger"><i class="fa fa-bars"></i>
<i class="fa fa-times"></i>

            </div>

          </div>

        </div>

      </div>

      <div class="hidden_nav animated fadeInDown">

<div class="bitcron_nav_container">


  <div class="bitcron_nav">
    <div class="mixed_site_nav_wrap site_nav_wrap">
      <ul class="mixed_site_nav site_nav sm sm-base">
		  
	
  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/" class="selected active current nav__item" >首页</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/archives" class="selected active current nav__item" >归档</a>

  </li>


  <li><a id="d2ef19af68cc211e98f8a0242ac110003" href="https://wsf123sd.github.io/tags" class="selected active current nav__item" >标签</a>

  </li>





      </ul>

      <div class="clear clear_nav_inline_end"></div>

    </div>

  </div>



  <div class="clear clear_nav_end"></div>

</div>

      </div>

    </div>


    <div class="main">
      <div class="main-inner">


<div class="content">






  <div class="post_page" >

<div class="post">
  <div class="post_title sm_margin">
    <h2><a>大话数据结构第六章笔记（树）</a>



    </h2>
  </div>

  <div class="post_details">
    <div class="info"><i class="fa fa-clock-o"></i>
<span class="date_info">2020-03-01</span>
<i class="fa fa-eye"></i>

<span class="date_info"><span id="busuanzi_value_page_pv"></span> Views</span>


<i class="fa fa-bookmark-o"></i>
<span class="tags_info weaklink">
	
	<a href="https://wsf123sd.github.io/tag/VKaKB5u_1/" class="tag">大话数据结构</a>


</span>


    </div>

  </div>





  <div class="post_content markdown"><p class="md_block">
    <span class="md_line md_line_start md_line_end"><p>6.2树的定义：<br>
1.树是n个结点的有限集，n=0时称为空树<br>
2.有且仅有一个特定的根<br>
3.子树的个数没有限制，但他们一定是不相交，如下图，就不是子树<br>
<img src="https://img-blog.csdnimg.cn/20191231202354754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.结点拥有的子树数称为结点的度。度为0的结点称为叶节点；度不为0的结点称为分支结点。除根节点之外，分支节点也称内部结点；树的度是树内各结点的度的最大值，如下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203344509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.3结点间的关系：<br>
1.结点的祖先是从根到该结点所经分支上的所有结点 对于H而言ABD都为他的祖先。其他各种关系见下图<br>
<img src="https://img-blog.csdnimg.cn/20191231203245223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.树的相关概念，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203808831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.树与线性表之间的差别，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231203824606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.3树的抽象数据类型，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231204652847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4树的存储结构=== 双亲表示法<br>
1.除了根节点啊外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲<br>
2.以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置，结构如下：</p>
<pre><code class="language-bash">data parent  //data是数据域，存储结点的数据信息。parent是指针域，存储该结点的双亲在数组中的下标
</code></pre>
<p>双亲表示法的结点结构定义代码：</p>
<pre><code class="language-cpp">//树的双亲表示法结点结构定义
#define MAX_TREE_SIZE 100
typedef int TElemType;   //树结点的数据类型，目前暂定位整型
typedef struct PTNode   //结点结构
{
	TElemType data;   //结点数据
	int parent;        //双亲位置
}PTNode;
typedef struct       //树的结构
{
	PTNode nodes[MAX_TREE_SIZE];   //结点数组
	int r,n;         //根的位置和结点数
}
</code></pre>
<p>上面的代码对应下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231210350239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进1：在结点中加入左孩子：<br>
<img src="https://img-blog.csdnimg.cn/20191231210401533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
改进2：在结点中加入有兄弟：<br>
<img src="https://img-blog.csdnimg.cn/20191231210410793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.2孩子表示法：由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表法：如下图，有两种方案：<br>
方案一：<br>
指针域的个数就是树的度，树的度是树中各个结点度的最大值，结构如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213303600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
方案2：<br>
每个结点指针域的个数等于该结点的度，专门取一个位置来存储结点指针域的个数，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231213251681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
重点是如下：<br>
孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针有组成一个线性表，采用顺序存储结构，存放进一个维数组中，如图</p>
<pre><code class="language-cpp">//树的孩子表示法结构定义：
#define MAX_TREE_SIZE 100
typedef struct CTNode   //孩子结点
{
	int chile;  //数据域：用来存储某个结点在表头数组中的下标
	struct CTNode *next;  //指针域：存储指向某结点另一个孩子结点的指针
}*ChildPtr;
typedef struct 
{
	TElemType data;  //存储某结点的数据信息
	ChildPtr firstchild; //存储该结点的孩子链表的头指针
}CTBox;
typedef struct     //树结构
{
	CTBox nodes[MAX_TREE_SIZE];  //结点数组
	int r,n;        //根的位置和结点数
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2019123121443736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
双亲表示法和孩子表示法综合，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231214837104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.4.3孩子兄弟表示法：<br>
结点结构如下图：<br>
firstchild 为指针域，存储该结点的第一个孩子存储地址<br>
<img src="https://img-blog.csdnimg.cn/2019123121564494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
结构定义代码如下：</p>
<pre><code class="language-cpp">//树的孩子兄弟表示法结构定义：
typedef struct CSNode
{
	TElemType data;
	struct CSNode *fitstchild, *rightsib;
}CSNode, *CSTree;
</code></pre>
<p>上面代码如下图：<br>
<img src="https://img-blog.csdnimg.cn/20191231215849928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.5二叉树<br>
1.如图便是二叉树，不能有3个结点：<br>
<img src="https://img-blog.csdnimg.cn/20191231220217170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">6.5.1二叉树特点：<br>
1.每个结点最多有两颗子树<br>
2.左子树与右子树是有顺序的，次序不能任意颠倒<br>
3.即使树中某结点只有一颗树，也要区分它是左子书还是右子树</p>
<p>二叉树的五种基本形态：<br>
1.空二叉树<br>
2.只有一个根节点<br>
3.根结点只有左子树<br>
4.根结点只有右子树<br>
5.根结点既有左子树又有右子树</p>
<p>6.5.2特殊二叉树<br>
1.斜树，满二叉树，完全二叉树 以及 满二叉树的特点和完全二叉树的特点，：如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101205140586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101205158141.png" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205220907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
完全二叉树与满二叉树的关系：<br>
<img src="https://img-blog.csdnimg.cn/20200101205227988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><img src="https://img-blog.csdnimg.cn/20200101205248318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
满二叉树的特点：<br>
<img src="https://img-blog.csdnimg.cn/20200101205312212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.6二叉树的性质：<br>
1.某一层上最多有多少个结点<br>
<img src="https://img-blog.csdnimg.cn/20200101210138616.png" alt="在这里插入图片描述" loading="lazy"><br>
2.深度为k的二叉树最多有几个结点：<br>
<img src="https://img-blog.csdnimg.cn/20200101210128770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.n0表示度为0的结点个数，n1表示度为1的结点的个数，n2表示度为2的结点的个数<br>
<img src="https://img-blog.csdnimg.cn/20200101210056806.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210115437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.完全二叉树的深度<br>
<img src="https://img-blog.csdnimg.cn/20200101210030592.png" alt="在这里插入图片描述" loading="lazy"><br>
5.对于根结点，左孩子，右孩子的判定方法：<br>
<img src="https://img-blog.csdnimg.cn/20200101210019979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.7.1二叉树的顺序存储结构：<br>
用数组存放，没有就像倒V表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101210629187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101210615923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.7.2二叉链表：<br>
用链式存储结构来存放二叉树，设计一个数据域，两个指针分别指向左孩子和右孩子，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200101211952142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>二叉链表的结点结构定义：</p>
<pre><code class="language-cpp">//二叉树的二叉链表结点结构定义：
typedef struct BiTNode        //结点结构
{
	TElemType data;       //结点数据
	struct BiTNode *lchild, *rchild;    //左右孩子指针
}BiTNode, *BiTree;
</code></pre>
<p>结构示意图如下：<br>
<img src="https://img-blog.csdnimg.cn/20200101211934670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.2二叉树4中遍历方法：<br>
1.前序遍历法<br>
2.中序遍历法<br>
3.后序遍历法<br>
4.层序遍历法</p>
<p><img src="https://img-blog.csdnimg.cn/20200101212151521.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101212228822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.3前序遍历法：</p>
<pre><code class="language-cpp">//二叉树的前序遍历递归算法
void PreOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	printf(&quot;%c&quot;,T-&gt;data);      //显示结点数据，可以更改为为其它节点的操作
	PreOrderTraverse(T-&gt;lchild);     //先遍历左子树
	PreOrderTraverse(T-&gt;rchild);        //最后遍历右子树
}
</code></pre>
<p>按照如下的顺序访问：<br>
<img src="https://img-blog.csdnimg.cn/20200101212935308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020010121295030.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213004977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200101213046165.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.4中序遍历算法代码：</p>
<pre><code class="language-cpp">//二叉树的中序遍历递归算法
void InOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	InOrderTraverse(T-&gt;lchild);    //中序遍历左子树
	printf(&quot;%c&quot;,T-&gt;data)         //显示节点数据，可以更改为其他对结点操作
	InOrderTraverse(T-&gt;rchild);     //最后中序遍历右子树
}
</code></pre>
<p>中序遍历结点示意图：<br>
<img src="https://img-blog.csdnimg.cn/20200101213810373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>6.8.5后续遍历法代码：</p>
<pre><code class="language-cpp">//二叉树后序遍历递归算法：
void PostOrderTraverse(BiTree T)
{
	if(T==NULL)
		return ;
	PostOrderTraverse(T-&gt;lchild);   //先后序遍历左子树
	PostOrderTraverse(T-&gt;rchild);    //后序遍历右子树
	printf(&quot;%c&quot;,T-&gt;data);       //显示结点数据，可以更改为对其他结点操作
}
</code></pre>
<p>6.9二叉树的建立：<br>
1.扩展二叉树：将二叉树中每个结点的空指针引出一个虚节点，其值为以特定值，比如&quot;#&quot;，称这种处理后的二叉树为原二叉树的扩展二叉树。如下图：</p>
<p>2.把前序遍历序列：AB#D##C##用键盘诶个输入，代码如下：<br>
也可以用中序或后序遍历的方法实现<br>
中序：输入顺序为#B#D#A#C#      对应代码顺序为：构造左子树—》生成结点-》构造右子树<br>
后序：输入顺序为###DB##CA     对应代码顺序为： 构造左子树-》构造右子树-》生成结点</p>
<pre><code class="language-cpp">//按前序输入二叉树中结点的值（一个字符）
//#表示空树，构造二叉链表表示二叉树T
void CreateBiTree(BiTree *T)
{
	TElemType ch;
	scanf(&quot;%c&quot;, &amp;ch);
	if(ch==&quot;#&quot;)
		*T=NULL;
	else
	{
		*T=(BiTree)malloc(sizeof(BiTNode));
		if(!*T)
			exit(OVERFLOW);
		(*T)-&gt;data=ch;     //生成根结点
		CreateBiTree(&amp;(*T)-&gt;lchild);             //构造左子树
		CreateBitree(&amp;(*T)-&gt;rchild);            //构造右子树
	}
}

</code></pre>
<p>6.10线索二叉树<br>
以中序遍历为例：下面二叉树中中序遍历的结果为：HDIBJEAFCG<br>
线索二叉树的实质：将二叉链表中的空指针改为指向前驱或后继的线索。<br>
<img src="https://img-blog.csdnimg.cn/202001022049073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将rchild改为后继，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204323143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
将lchild改为它的前驱，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204350104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
整个二叉树的中序遍历结果中的前驱后继关系如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102204638116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<p>将lchild,ltag,data,rtag,rchild组合成一个结构，如下图：<br>
具体如下：<br>
ltag为0表示指向该节点的左孩子，为1表示指向该节点的前驱<br>
rtag为0表示指向该结点的右孩子，为1指向该结点的后继<br>
<img src="https://img-blog.csdnimg.cn/20200102204422155.png" alt="在这里插入图片描述" loading="lazy"><br>
二叉树的搜索存储结构定义</p>
<pre><code class="language-cpp">//二叉树的二叉搜索存储结构定义
typedef enum{Link,Thread} PointerTag;         //Link==0表示指向左右孩子指针，Thread==1表示指向前驱或后继的线索
typedef struct BiThrNode           //二叉搜索存储结点结构
{
	TElemType data;
	struct BiThrNode *lchild, *rchild;        //左右孩子指针
	PointerTag LTag;                 //左右标志            
	PointerTag RTag;      
}BiThrNode, *BiThrTree;

												

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200102204454222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<p>中序遍历线索化递归函数代码：(构建线索二叉树)<br>
可以根据上图二叉树来理解</p>
<pre><code class="language-cpp">//中序遍历进行中序线索化
void InThreading(BiThrTree p)
{
	InThreading(p-&gt;lchild);             //递归左子树线索化
	if(!p-&gt;lchild)                //没有左孩子
	{
		p-&gt;LTag=Thread;                   //将LTag改为1
		p-&gt;lchild=pre;               //左孩子指针指向前驱
	}
	if(!pre-&gt;rchild)
	{
		pre-&gt;RTag=Thread;                    //将RTag改为1，为了理解见下图
		pre-&gt;rchild=p;                //前驱右孩子指针指向后继(当前结点p)
	}
	pre=p;                       //保持pre指向p的前驱
	InThreading(p-&gt;rchild);           //递归右子树线索化
}

</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200102214224564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
二叉线索树的遍历，见下图：<br>
<img src="https://img-blog.csdnimg.cn/20200102220110750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
遍历代码如下：</p>
<pre><code class="language-cpp">//T指向头结点，头结点左链lchild指向根结点，头结点右链rchild指向中序遍历的最后一个结点。中序遍历二叉线索链表表示的二叉树T
Status InOrderTraverse_Thr(BiThTree T)
{
	BiThrTree p;
	p=T-&gt;lchild;             //p指向根结点
	while(p!=T)               //空树或遍历结束时，p==T
	{
		while(p=&gt;LTag==Link)            //当LTag==0时循环到中序序列的第一个结点
			p=p-&gt;lchild;
		printf(&quot;%c&quot;,p-&gt;data);           //显示结点数据，可以更改为其他对结点的操作
		while(p-&gt;RTag==Thread &amp;&amp; p-&gt;rchild!=T)
		{
			p=p-&gt;rchild;                  //p中RTag是1表示存放的是他的后继结点
			printf(&quot;%c&quot;,p-&gt;data); 
		}
		p=p-&gt;rchild;            //p中RTag是0表示，p进入他的右子树  区分上面的
	}
	return OK;
}

</code></pre>
<p>如果所用二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，采用线索二叉树的存储结构</p>
<p>6.11.1树转换为二叉树<br>
1.加线。在所有兄弟节点之间加一条线<br>
2.去线。 就是按照你的思路去就对<br>
3.层次调整。 以树的根结点为轴心，顺时针旋转，注意第一个孩子是二叉树结点的左孩子，兄弟转换过来为结点的右孩子<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103194908705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.2将森林转换为二叉树：<br>
1.将每个树按照上面的方法转化成二叉树<br>
2、第一棵树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103195444927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.3二叉树转化为树<br>
1.将结点的左孩子n个右孩子，用线连接起来<br>
2.删除原二叉树中所有结点与其右孩子结点的连线<br>
3.层次调整。  如果只有一个孩子，就直接转化为竖线即可<br>
如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103200346330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.4二叉树转化为森林：<br>
1.从根结点开始，若右孩子存在则删除连线，若右孩子存在则删除连线，只要有右孩子就把连线删了<br>
2.再将每棵二叉树转化成树<br>
<img src="https://img-blog.csdnimg.cn/20200103201021824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
6.11.5.森林的遍历：<br>
1.前序遍历：一颗树接着一棵树来，每棵树都用先序遍历法，对于上图的二叉树的遍历结果为：ABCDEFGHJI<br>
2.后序遍历：还是一棵树接着一棵树来，每棵树都用后序遍历法，对于上图的二叉树的遍历结果为：BCDAFEJHIG<br>
对于上图而言，森林的前序遍历法和二叉树的前序遍历结果相同，森林的后序遍历和二叉树的中序遍历法相同。</p>
<p>6.12赫夫曼树及其应用：<br>
树的路径长度表示从根结点到每一个结点的长度总和，如下图中二叉a的路径长度为1+1+2+2+3+3+4+4=20，二叉树b的路径长度为1+2+2+3+3+1+2+2=16<br>
<img src="https://img-blog.csdnimg.cn/20200103204819966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
带权路径长度wpl最小的二叉树称作赫夫曼树，上图中二叉树a的wpL=5<em>1+15</em>2+40<em>3+30</em>4+10<em>4=315 ，二叉树b的wpl=40</em>2+15<em>3+5</em>3+30<em>2+10</em>2=220</p>
<p>6.12.2最优赫夫曼树构造方法：<br>
1.将把有权值的叶子结点按照从小到大的顺序排成一个有序列<br>
2.取头两个最小权值的结点之和作为一个新的结点，注意较小的为新的结点的左孩子，每次如此重复，直至结束。如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103210711134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210742955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200103210759426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
赫夫曼编码：<br>
根据赫夫曼树左0右1，对应每个字符编码。这样可以将字符串的长度变少，同样解码也是根据表6-12-3表示，如下图：<br>
<img src="https://img-blog.csdnimg.cn/20200103213334549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzZmhkaGpz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
</p>

     <p class="md_block">
    <div class="reward"><div class="reward-button">赏 <span class="reward-code"> <span class="alipay-code"> <img class="alipay-img" src="https://wsf123sd.github.io//media/images/alipay.png"><b>支付宝扫码打赏</b> </span> <span class="wechat-code"> <img class="wechat-img" src="https://wsf123sd.github.io//media/images/wechat.png"><b>微信打赏</b> </span> </span></div></div>
</p> 
</div>

</div>



<link href="https://wsf123sd.github.io//styles/main.css" type="text/css" rel="stylesheet"/>

<div class="doc_comments">

</div>



  </div>
</div>



      </div>




    </div>

   <div class="footer">
<link href="https://wsf123sd.github.io//styles/main.css" type="text/css" rel="stylesheet"/><div class="site_footer_wrap"><div class="site_footer">

      <div class="mysocials"><div class="my_socials">
		   
			   
    
			   
    
			   
    
			   
    
</div><link href="https://wsf123sd.github.io//styles/main.css" type="text/css" rel="stylesheet"/>

      </div>

      <div class="copyright">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
      </div>

</div></div>

    </div>


<style type="text/css">a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 40px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
}

a.back_to_top span {
    color: #888;
}

a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
}

a.back_to_top:hover span {
    color: #555;
}

@media print, screen and (max-width: 580px) {
    .back_to_top {
        display: none !important;
    }
}



</style><a id="back_to_top" href="#" class="back_to_top"><span>△</span>
</a>
<script type="text/javascript" src="https://wsf123sd.github.io//media/scripts/jquery.js"></script>

<script>$(document).ready((function(_this) {
  return function() {
    var bt;
    bt = $('#back_to_top');
    if ($(document).width() > 480) {
      $(window).scroll(function() {
        var st;
        st = $(window).scrollTop();
        if (st > 30) {
          return bt.css('display', 'block');
        } else {
          return bt.css('display', 'none');
        }
      });
      return bt.click(function() {
        $('body,html').animate({
          scrollTop: 0
        }, 800);
        return false;
      });
    }
  };
})(this));
</script>

</body>

</html>